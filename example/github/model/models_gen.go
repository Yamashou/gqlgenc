// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Autogenerated input type of AddStar
type AddStarInput struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID *string `json:"clientMutationId,omitempty"`
	// The Starrable ID to star.
	StarrableID string `json:"starrableId"`
}

// The actor's type.
type ActorType string

const (
	// Indicates a user actor.
	ActorTypeUser ActorType = "USER"
	// Indicates a team actor.
	ActorTypeTeam ActorType = "TEAM"
)

var AllActorType = []ActorType{
	ActorTypeUser,
	ActorTypeTeam,
}

func (e ActorType) IsValid() bool {
	switch e {
	case ActorTypeUser, ActorTypeTeam:
		return true
	}
	return false
}

func (e ActorType) String() string {
	return string(e)
}

func (e *ActorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActorType", str)
	}
	return nil
}

func (e ActorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Audit Log connections can be ordered.
type AuditLogOrderField string

const (
	// Order audit log entries by timestamp
	AuditLogOrderFieldCreatedAt AuditLogOrderField = "CREATED_AT"
)

var AllAuditLogOrderField = []AuditLogOrderField{
	AuditLogOrderFieldCreatedAt,
}

func (e AuditLogOrderField) IsValid() bool {
	switch e {
	case AuditLogOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e AuditLogOrderField) String() string {
	return string(e)
}

func (e *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditLogOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditLogOrderField", str)
	}
	return nil
}

func (e AuditLogOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents an annotation's information level.
type CheckAnnotationLevel string

const (
	// An annotation indicating an inescapable error.
	CheckAnnotationLevelFailure CheckAnnotationLevel = "FAILURE"
	// An annotation indicating some information.
	CheckAnnotationLevelNotice CheckAnnotationLevel = "NOTICE"
	// An annotation indicating an ignorable error.
	CheckAnnotationLevelWarning CheckAnnotationLevel = "WARNING"
)

var AllCheckAnnotationLevel = []CheckAnnotationLevel{
	CheckAnnotationLevelFailure,
	CheckAnnotationLevelNotice,
	CheckAnnotationLevelWarning,
}

func (e CheckAnnotationLevel) IsValid() bool {
	switch e {
	case CheckAnnotationLevelFailure, CheckAnnotationLevelNotice, CheckAnnotationLevelWarning:
		return true
	}
	return false
}

func (e CheckAnnotationLevel) String() string {
	return string(e)
}

func (e *CheckAnnotationLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckAnnotationLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckAnnotationLevel", str)
	}
	return nil
}

func (e CheckAnnotationLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a check suite or run conclusion.
type CheckConclusionState string

const (
	// The check suite or run requires action.
	CheckConclusionStateActionRequired CheckConclusionState = "ACTION_REQUIRED"
	// The check suite or run has timed out.
	CheckConclusionStateTimedOut CheckConclusionState = "TIMED_OUT"
	// The check suite or run has been cancelled.
	CheckConclusionStateCancelled CheckConclusionState = "CANCELLED"
	// The check suite or run has failed.
	CheckConclusionStateFailure CheckConclusionState = "FAILURE"
	// The check suite or run has succeeded.
	CheckConclusionStateSuccess CheckConclusionState = "SUCCESS"
	// The check suite or run was neutral.
	CheckConclusionStateNeutral CheckConclusionState = "NEUTRAL"
	// The check suite or run was skipped.
	CheckConclusionStateSkipped CheckConclusionState = "SKIPPED"
	// The check suite or run has failed at startup.
	CheckConclusionStateStartupFailure CheckConclusionState = "STARTUP_FAILURE"
	// The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion.
	CheckConclusionStateStale CheckConclusionState = "STALE"
)

var AllCheckConclusionState = []CheckConclusionState{
	CheckConclusionStateActionRequired,
	CheckConclusionStateTimedOut,
	CheckConclusionStateCancelled,
	CheckConclusionStateFailure,
	CheckConclusionStateSuccess,
	CheckConclusionStateNeutral,
	CheckConclusionStateSkipped,
	CheckConclusionStateStartupFailure,
	CheckConclusionStateStale,
}

func (e CheckConclusionState) IsValid() bool {
	switch e {
	case CheckConclusionStateActionRequired, CheckConclusionStateTimedOut, CheckConclusionStateCancelled, CheckConclusionStateFailure, CheckConclusionStateSuccess, CheckConclusionStateNeutral, CheckConclusionStateSkipped, CheckConclusionStateStartupFailure, CheckConclusionStateStale:
		return true
	}
	return false
}

func (e CheckConclusionState) String() string {
	return string(e)
}

func (e *CheckConclusionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckConclusionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckConclusionState", str)
	}
	return nil
}

func (e CheckConclusionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a check run in a status rollup.
type CheckRunState string

const (
	// The check run requires action.
	CheckRunStateActionRequired CheckRunState = "ACTION_REQUIRED"
	// The check run has been cancelled.
	CheckRunStateCancelled CheckRunState = "CANCELLED"
	// The check run has been completed.
	CheckRunStateCompleted CheckRunState = "COMPLETED"
	// The check run has failed.
	CheckRunStateFailure CheckRunState = "FAILURE"
	// The check run is in progress.
	CheckRunStateInProgress CheckRunState = "IN_PROGRESS"
	// The check run was neutral.
	CheckRunStateNeutral CheckRunState = "NEUTRAL"
	// The check run is in pending state.
	CheckRunStatePending CheckRunState = "PENDING"
	// The check run has been queued.
	CheckRunStateQueued CheckRunState = "QUEUED"
	// The check run was skipped.
	CheckRunStateSkipped CheckRunState = "SKIPPED"
	// The check run was marked stale by GitHub. Only GitHub can use this conclusion.
	CheckRunStateStale CheckRunState = "STALE"
	// The check run has failed at startup.
	CheckRunStateStartupFailure CheckRunState = "STARTUP_FAILURE"
	// The check run has succeeded.
	CheckRunStateSuccess CheckRunState = "SUCCESS"
	// The check run has timed out.
	CheckRunStateTimedOut CheckRunState = "TIMED_OUT"
	// The check run is in waiting state.
	CheckRunStateWaiting CheckRunState = "WAITING"
)

var AllCheckRunState = []CheckRunState{
	CheckRunStateActionRequired,
	CheckRunStateCancelled,
	CheckRunStateCompleted,
	CheckRunStateFailure,
	CheckRunStateInProgress,
	CheckRunStateNeutral,
	CheckRunStatePending,
	CheckRunStateQueued,
	CheckRunStateSkipped,
	CheckRunStateStale,
	CheckRunStateStartupFailure,
	CheckRunStateSuccess,
	CheckRunStateTimedOut,
	CheckRunStateWaiting,
}

func (e CheckRunState) IsValid() bool {
	switch e {
	case CheckRunStateActionRequired, CheckRunStateCancelled, CheckRunStateCompleted, CheckRunStateFailure, CheckRunStateInProgress, CheckRunStateNeutral, CheckRunStatePending, CheckRunStateQueued, CheckRunStateSkipped, CheckRunStateStale, CheckRunStateStartupFailure, CheckRunStateSuccess, CheckRunStateTimedOut, CheckRunStateWaiting:
		return true
	}
	return false
}

func (e CheckRunState) String() string {
	return string(e)
}

func (e *CheckRunState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckRunState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckRunState", str)
	}
	return nil
}

func (e CheckRunState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types of check runs.
type CheckRunType string

const (
	// Every check run available.
	CheckRunTypeAll CheckRunType = "ALL"
	// The latest check run.
	CheckRunTypeLatest CheckRunType = "LATEST"
)

var AllCheckRunType = []CheckRunType{
	CheckRunTypeAll,
	CheckRunTypeLatest,
}

func (e CheckRunType) IsValid() bool {
	switch e {
	case CheckRunTypeAll, CheckRunTypeLatest:
		return true
	}
	return false
}

func (e CheckRunType) String() string {
	return string(e)
}

func (e *CheckRunType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckRunType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckRunType", str)
	}
	return nil
}

func (e CheckRunType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a check suite or run status.
type CheckStatusState string

const (
	// The check suite or run has been requested.
	CheckStatusStateRequested CheckStatusState = "REQUESTED"
	// The check suite or run has been queued.
	CheckStatusStateQueued CheckStatusState = "QUEUED"
	// The check suite or run is in progress.
	CheckStatusStateInProgress CheckStatusState = "IN_PROGRESS"
	// The check suite or run has been completed.
	CheckStatusStateCompleted CheckStatusState = "COMPLETED"
	// The check suite or run is in waiting state.
	CheckStatusStateWaiting CheckStatusState = "WAITING"
	// The check suite or run is in pending state.
	CheckStatusStatePending CheckStatusState = "PENDING"
)

var AllCheckStatusState = []CheckStatusState{
	CheckStatusStateRequested,
	CheckStatusStateQueued,
	CheckStatusStateInProgress,
	CheckStatusStateCompleted,
	CheckStatusStateWaiting,
	CheckStatusStatePending,
}

func (e CheckStatusState) IsValid() bool {
	switch e {
	case CheckStatusStateRequested, CheckStatusStateQueued, CheckStatusStateInProgress, CheckStatusStateCompleted, CheckStatusStateWaiting, CheckStatusStatePending:
		return true
	}
	return false
}

func (e CheckStatusState) String() string {
	return string(e)
}

func (e *CheckStatusState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckStatusState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckStatusState", str)
	}
	return nil
}

func (e CheckStatusState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Collaborators affiliation level with a subject.
type CollaboratorAffiliation string

const (
	// All outside collaborators of an organization-owned subject.
	CollaboratorAffiliationOutside CollaboratorAffiliation = "OUTSIDE"
	// All collaborators with permissions to an organization-owned subject, regardless of organization membership status.
	CollaboratorAffiliationDirect CollaboratorAffiliation = "DIRECT"
	// All collaborators the authenticated user can see.
	CollaboratorAffiliationAll CollaboratorAffiliation = "ALL"
)

var AllCollaboratorAffiliation = []CollaboratorAffiliation{
	CollaboratorAffiliationOutside,
	CollaboratorAffiliationDirect,
	CollaboratorAffiliationAll,
}

func (e CollaboratorAffiliation) IsValid() bool {
	switch e {
	case CollaboratorAffiliationOutside, CollaboratorAffiliationDirect, CollaboratorAffiliationAll:
		return true
	}
	return false
}

func (e CollaboratorAffiliation) String() string {
	return string(e)
}

func (e *CollaboratorAffiliation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollaboratorAffiliation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollaboratorAffiliation", str)
	}
	return nil
}

func (e CollaboratorAffiliation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A comment author association with repository.
type CommentAuthorAssociation string

const (
	// Author is a member of the organization that owns the repository.
	CommentAuthorAssociationMember CommentAuthorAssociation = "MEMBER"
	// Author is the owner of the repository.
	CommentAuthorAssociationOwner CommentAuthorAssociation = "OWNER"
	// Author is a placeholder for an unclaimed user.
	CommentAuthorAssociationMannequin CommentAuthorAssociation = "MANNEQUIN"
	// Author has been invited to collaborate on the repository.
	CommentAuthorAssociationCollaborator CommentAuthorAssociation = "COLLABORATOR"
	// Author has previously committed to the repository.
	CommentAuthorAssociationContributor CommentAuthorAssociation = "CONTRIBUTOR"
	// Author has not previously committed to the repository.
	CommentAuthorAssociationFirstTimeContributor CommentAuthorAssociation = "FIRST_TIME_CONTRIBUTOR"
	// Author has not previously committed to GitHub.
	CommentAuthorAssociationFirstTimer CommentAuthorAssociation = "FIRST_TIMER"
	// Author has no association with the repository.
	CommentAuthorAssociationNone CommentAuthorAssociation = "NONE"
)

var AllCommentAuthorAssociation = []CommentAuthorAssociation{
	CommentAuthorAssociationMember,
	CommentAuthorAssociationOwner,
	CommentAuthorAssociationMannequin,
	CommentAuthorAssociationCollaborator,
	CommentAuthorAssociationContributor,
	CommentAuthorAssociationFirstTimeContributor,
	CommentAuthorAssociationFirstTimer,
	CommentAuthorAssociationNone,
}

func (e CommentAuthorAssociation) IsValid() bool {
	switch e {
	case CommentAuthorAssociationMember, CommentAuthorAssociationOwner, CommentAuthorAssociationMannequin, CommentAuthorAssociationCollaborator, CommentAuthorAssociationContributor, CommentAuthorAssociationFirstTimeContributor, CommentAuthorAssociationFirstTimer, CommentAuthorAssociationNone:
		return true
	}
	return false
}

func (e CommentAuthorAssociation) String() string {
	return string(e)
}

func (e *CommentAuthorAssociation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentAuthorAssociation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentAuthorAssociation", str)
	}
	return nil
}

func (e CommentAuthorAssociation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible errors that will prevent a user from updating a comment.
type CommentCannotUpdateReason string

const (
	// Unable to create comment because repository is archived.
	CommentCannotUpdateReasonArchived CommentCannotUpdateReason = "ARCHIVED"
	// You must be the author or have write access to this repository to update this comment.
	CommentCannotUpdateReasonInsufficientAccess CommentCannotUpdateReason = "INSUFFICIENT_ACCESS"
	// Unable to create comment because issue is locked.
	CommentCannotUpdateReasonLocked CommentCannotUpdateReason = "LOCKED"
	// You must be logged in to update this comment.
	CommentCannotUpdateReasonLoginRequired CommentCannotUpdateReason = "LOGIN_REQUIRED"
	// Repository is under maintenance.
	CommentCannotUpdateReasonMaintenance CommentCannotUpdateReason = "MAINTENANCE"
	// At least one email address must be verified to update this comment.
	CommentCannotUpdateReasonVerifiedEmailRequired CommentCannotUpdateReason = "VERIFIED_EMAIL_REQUIRED"
	// You cannot update this comment
	CommentCannotUpdateReasonDenied CommentCannotUpdateReason = "DENIED"
)

var AllCommentCannotUpdateReason = []CommentCannotUpdateReason{
	CommentCannotUpdateReasonArchived,
	CommentCannotUpdateReasonInsufficientAccess,
	CommentCannotUpdateReasonLocked,
	CommentCannotUpdateReasonLoginRequired,
	CommentCannotUpdateReasonMaintenance,
	CommentCannotUpdateReasonVerifiedEmailRequired,
	CommentCannotUpdateReasonDenied,
}

func (e CommentCannotUpdateReason) IsValid() bool {
	switch e {
	case CommentCannotUpdateReasonArchived, CommentCannotUpdateReasonInsufficientAccess, CommentCannotUpdateReasonLocked, CommentCannotUpdateReasonLoginRequired, CommentCannotUpdateReasonMaintenance, CommentCannotUpdateReasonVerifiedEmailRequired, CommentCannotUpdateReasonDenied:
		return true
	}
	return false
}

func (e CommentCannotUpdateReason) String() string {
	return string(e)
}

func (e *CommentCannotUpdateReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentCannotUpdateReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentCannotUpdateReason", str)
	}
	return nil
}

func (e CommentCannotUpdateReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which commit contribution connections can be ordered.
type CommitContributionOrderField string

const (
	// Order commit contributions by when they were made.
	CommitContributionOrderFieldOccurredAt CommitContributionOrderField = "OCCURRED_AT"
	// Order commit contributions by how many commits they represent.
	CommitContributionOrderFieldCommitCount CommitContributionOrderField = "COMMIT_COUNT"
)

var AllCommitContributionOrderField = []CommitContributionOrderField{
	CommitContributionOrderFieldOccurredAt,
	CommitContributionOrderFieldCommitCount,
}

func (e CommitContributionOrderField) IsValid() bool {
	switch e {
	case CommitContributionOrderFieldOccurredAt, CommitContributionOrderFieldCommitCount:
		return true
	}
	return false
}

func (e CommitContributionOrderField) String() string {
	return string(e)
}

func (e *CommitContributionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommitContributionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommitContributionOrderField", str)
	}
	return nil
}

func (e CommitContributionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a git comparison between two refs.
type ComparisonStatus string

const (
	// The head ref is both ahead and behind of the base ref, indicating git history has diverged.
	ComparisonStatusDiverged ComparisonStatus = "DIVERGED"
	// The head ref is ahead of the base ref.
	ComparisonStatusAhead ComparisonStatus = "AHEAD"
	// The head ref is behind the base ref.
	ComparisonStatusBehind ComparisonStatus = "BEHIND"
	// The head ref and base ref are identical.
	ComparisonStatusIdentical ComparisonStatus = "IDENTICAL"
)

var AllComparisonStatus = []ComparisonStatus{
	ComparisonStatusDiverged,
	ComparisonStatusAhead,
	ComparisonStatusBehind,
	ComparisonStatusIdentical,
}

func (e ComparisonStatus) IsValid() bool {
	switch e {
	case ComparisonStatusDiverged, ComparisonStatusAhead, ComparisonStatusBehind, ComparisonStatusIdentical:
		return true
	}
	return false
}

func (e ComparisonStatus) String() string {
	return string(e)
}

func (e *ComparisonStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComparisonStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComparisonStatus", str)
	}
	return nil
}

func (e ComparisonStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Varying levels of contributions from none to many.
type ContributionLevel string

const (
	// No contributions occurred.
	ContributionLevelNone ContributionLevel = "NONE"
	// Lowest 25% of days of contributions.
	ContributionLevelFirstQuartile ContributionLevel = "FIRST_QUARTILE"
	// Second lowest 25% of days of contributions. More contributions than the first quartile.
	ContributionLevelSecondQuartile ContributionLevel = "SECOND_QUARTILE"
	// Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile.
	ContributionLevelThirdQuartile ContributionLevel = "THIRD_QUARTILE"
	// Highest 25% of days of contributions. More contributions than the third quartile.
	ContributionLevelFourthQuartile ContributionLevel = "FOURTH_QUARTILE"
)

var AllContributionLevel = []ContributionLevel{
	ContributionLevelNone,
	ContributionLevelFirstQuartile,
	ContributionLevelSecondQuartile,
	ContributionLevelThirdQuartile,
	ContributionLevelFourthQuartile,
}

func (e ContributionLevel) IsValid() bool {
	switch e {
	case ContributionLevelNone, ContributionLevelFirstQuartile, ContributionLevelSecondQuartile, ContributionLevelThirdQuartile, ContributionLevelFourthQuartile:
		return true
	}
	return false
}

func (e ContributionLevel) String() string {
	return string(e)
}

func (e *ContributionLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContributionLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContributionLevel", str)
	}
	return nil
}

func (e ContributionLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible base permissions for repositories.
type DefaultRepositoryPermissionField string

const (
	// No access
	DefaultRepositoryPermissionFieldNone DefaultRepositoryPermissionField = "NONE"
	// Can read repos by default
	DefaultRepositoryPermissionFieldRead DefaultRepositoryPermissionField = "READ"
	// Can read and write repos by default
	DefaultRepositoryPermissionFieldWrite DefaultRepositoryPermissionField = "WRITE"
	// Can read, write, and administrate repos by default
	DefaultRepositoryPermissionFieldAdmin DefaultRepositoryPermissionField = "ADMIN"
)

var AllDefaultRepositoryPermissionField = []DefaultRepositoryPermissionField{
	DefaultRepositoryPermissionFieldNone,
	DefaultRepositoryPermissionFieldRead,
	DefaultRepositoryPermissionFieldWrite,
	DefaultRepositoryPermissionFieldAdmin,
}

func (e DefaultRepositoryPermissionField) IsValid() bool {
	switch e {
	case DefaultRepositoryPermissionFieldNone, DefaultRepositoryPermissionFieldRead, DefaultRepositoryPermissionFieldWrite, DefaultRepositoryPermissionFieldAdmin:
		return true
	}
	return false
}

func (e DefaultRepositoryPermissionField) String() string {
	return string(e)
}

func (e *DefaultRepositoryPermissionField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DefaultRepositoryPermissionField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DefaultRepositoryPermissionField", str)
	}
	return nil
}

func (e DefaultRepositoryPermissionField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible ecosystems of a dependency graph package.
type DependencyGraphEcosystem string

const (
	// Ruby gems hosted at RubyGems.org
	DependencyGraphEcosystemRubygems DependencyGraphEcosystem = "RUBYGEMS"
	// JavaScript packages hosted at npmjs.com
	DependencyGraphEcosystemNpm DependencyGraphEcosystem = "NPM"
	// Python packages hosted at PyPI.org
	DependencyGraphEcosystemPip DependencyGraphEcosystem = "PIP"
	// Java artifacts hosted at the Maven central repository
	DependencyGraphEcosystemMaven DependencyGraphEcosystem = "MAVEN"
	// .NET packages hosted at the NuGet Gallery
	DependencyGraphEcosystemNuget DependencyGraphEcosystem = "NUGET"
	// PHP packages hosted at packagist.org
	DependencyGraphEcosystemComposer DependencyGraphEcosystem = "COMPOSER"
	// Go modules
	DependencyGraphEcosystemGo DependencyGraphEcosystem = "GO"
	// GitHub Actions
	DependencyGraphEcosystemActions DependencyGraphEcosystem = "ACTIONS"
	// Rust crates
	DependencyGraphEcosystemRust DependencyGraphEcosystem = "RUST"
	// Dart packages hosted at pub.dev
	DependencyGraphEcosystemPub DependencyGraphEcosystem = "PUB"
	// Swift packages
	DependencyGraphEcosystemSwift DependencyGraphEcosystem = "SWIFT"
)

var AllDependencyGraphEcosystem = []DependencyGraphEcosystem{
	DependencyGraphEcosystemRubygems,
	DependencyGraphEcosystemNpm,
	DependencyGraphEcosystemPip,
	DependencyGraphEcosystemMaven,
	DependencyGraphEcosystemNuget,
	DependencyGraphEcosystemComposer,
	DependencyGraphEcosystemGo,
	DependencyGraphEcosystemActions,
	DependencyGraphEcosystemRust,
	DependencyGraphEcosystemPub,
	DependencyGraphEcosystemSwift,
}

func (e DependencyGraphEcosystem) IsValid() bool {
	switch e {
	case DependencyGraphEcosystemRubygems, DependencyGraphEcosystemNpm, DependencyGraphEcosystemPip, DependencyGraphEcosystemMaven, DependencyGraphEcosystemNuget, DependencyGraphEcosystemComposer, DependencyGraphEcosystemGo, DependencyGraphEcosystemActions, DependencyGraphEcosystemRust, DependencyGraphEcosystemPub, DependencyGraphEcosystemSwift:
		return true
	}
	return false
}

func (e DependencyGraphEcosystem) String() string {
	return string(e)
}

func (e *DependencyGraphEcosystem) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DependencyGraphEcosystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DependencyGraphEcosystem", str)
	}
	return nil
}

func (e DependencyGraphEcosystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which deployment connections can be ordered.
type DeploymentOrderField string

const (
	// Order collection by creation time
	DeploymentOrderFieldCreatedAt DeploymentOrderField = "CREATED_AT"
)

var AllDeploymentOrderField = []DeploymentOrderField{
	DeploymentOrderFieldCreatedAt,
}

func (e DeploymentOrderField) IsValid() bool {
	switch e {
	case DeploymentOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e DeploymentOrderField) String() string {
	return string(e)
}

func (e *DeploymentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentOrderField", str)
	}
	return nil
}

func (e DeploymentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible protection rule types.
type DeploymentProtectionRuleType string

const (
	// Required reviewers
	DeploymentProtectionRuleTypeRequiredReviewers DeploymentProtectionRuleType = "REQUIRED_REVIEWERS"
	// Wait timer
	DeploymentProtectionRuleTypeWaitTimer DeploymentProtectionRuleType = "WAIT_TIMER"
	// Branch policy
	DeploymentProtectionRuleTypeBranchPolicy DeploymentProtectionRuleType = "BRANCH_POLICY"
)

var AllDeploymentProtectionRuleType = []DeploymentProtectionRuleType{
	DeploymentProtectionRuleTypeRequiredReviewers,
	DeploymentProtectionRuleTypeWaitTimer,
	DeploymentProtectionRuleTypeBranchPolicy,
}

func (e DeploymentProtectionRuleType) IsValid() bool {
	switch e {
	case DeploymentProtectionRuleTypeRequiredReviewers, DeploymentProtectionRuleTypeWaitTimer, DeploymentProtectionRuleTypeBranchPolicy:
		return true
	}
	return false
}

func (e DeploymentProtectionRuleType) String() string {
	return string(e)
}

func (e *DeploymentProtectionRuleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentProtectionRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentProtectionRuleType", str)
	}
	return nil
}

func (e DeploymentProtectionRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a deployment review.
type DeploymentReviewState string

const (
	// The deployment was approved.
	DeploymentReviewStateApproved DeploymentReviewState = "APPROVED"
	// The deployment was rejected.
	DeploymentReviewStateRejected DeploymentReviewState = "REJECTED"
)

var AllDeploymentReviewState = []DeploymentReviewState{
	DeploymentReviewStateApproved,
	DeploymentReviewStateRejected,
}

func (e DeploymentReviewState) IsValid() bool {
	switch e {
	case DeploymentReviewStateApproved, DeploymentReviewStateRejected:
		return true
	}
	return false
}

func (e DeploymentReviewState) String() string {
	return string(e)
}

func (e *DeploymentReviewState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentReviewState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentReviewState", str)
	}
	return nil
}

func (e DeploymentReviewState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states in which a deployment can be.
type DeploymentState string

const (
	// The pending deployment was not updated after 30 minutes.
	DeploymentStateAbandoned DeploymentState = "ABANDONED"
	// The deployment is currently active.
	DeploymentStateActive DeploymentState = "ACTIVE"
	// An inactive transient deployment.
	DeploymentStateDestroyed DeploymentState = "DESTROYED"
	// The deployment experienced an error.
	DeploymentStateError DeploymentState = "ERROR"
	// The deployment has failed.
	DeploymentStateFailure DeploymentState = "FAILURE"
	// The deployment is inactive.
	DeploymentStateInactive DeploymentState = "INACTIVE"
	// The deployment is pending.
	DeploymentStatePending DeploymentState = "PENDING"
	// The deployment was successful.
	DeploymentStateSuccess DeploymentState = "SUCCESS"
	// The deployment has queued
	DeploymentStateQueued DeploymentState = "QUEUED"
	// The deployment is in progress.
	DeploymentStateInProgress DeploymentState = "IN_PROGRESS"
	// The deployment is waiting.
	DeploymentStateWaiting DeploymentState = "WAITING"
)

var AllDeploymentState = []DeploymentState{
	DeploymentStateAbandoned,
	DeploymentStateActive,
	DeploymentStateDestroyed,
	DeploymentStateError,
	DeploymentStateFailure,
	DeploymentStateInactive,
	DeploymentStatePending,
	DeploymentStateSuccess,
	DeploymentStateQueued,
	DeploymentStateInProgress,
	DeploymentStateWaiting,
}

func (e DeploymentState) IsValid() bool {
	switch e {
	case DeploymentStateAbandoned, DeploymentStateActive, DeploymentStateDestroyed, DeploymentStateError, DeploymentStateFailure, DeploymentStateInactive, DeploymentStatePending, DeploymentStateSuccess, DeploymentStateQueued, DeploymentStateInProgress, DeploymentStateWaiting:
		return true
	}
	return false
}

func (e DeploymentState) String() string {
	return string(e)
}

func (e *DeploymentState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentState", str)
	}
	return nil
}

func (e DeploymentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a deployment status.
type DeploymentStatusState string

const (
	// The deployment is pending.
	DeploymentStatusStatePending DeploymentStatusState = "PENDING"
	// The deployment was successful.
	DeploymentStatusStateSuccess DeploymentStatusState = "SUCCESS"
	// The deployment has failed.
	DeploymentStatusStateFailure DeploymentStatusState = "FAILURE"
	// The deployment is inactive.
	DeploymentStatusStateInactive DeploymentStatusState = "INACTIVE"
	// The deployment experienced an error.
	DeploymentStatusStateError DeploymentStatusState = "ERROR"
	// The deployment is queued
	DeploymentStatusStateQueued DeploymentStatusState = "QUEUED"
	// The deployment is in progress.
	DeploymentStatusStateInProgress DeploymentStatusState = "IN_PROGRESS"
	// The deployment is waiting.
	DeploymentStatusStateWaiting DeploymentStatusState = "WAITING"
)

var AllDeploymentStatusState = []DeploymentStatusState{
	DeploymentStatusStatePending,
	DeploymentStatusStateSuccess,
	DeploymentStatusStateFailure,
	DeploymentStatusStateInactive,
	DeploymentStatusStateError,
	DeploymentStatusStateQueued,
	DeploymentStatusStateInProgress,
	DeploymentStatusStateWaiting,
}

func (e DeploymentStatusState) IsValid() bool {
	switch e {
	case DeploymentStatusStatePending, DeploymentStatusStateSuccess, DeploymentStatusStateFailure, DeploymentStatusStateInactive, DeploymentStatusStateError, DeploymentStatusStateQueued, DeploymentStatusStateInProgress, DeploymentStatusStateWaiting:
		return true
	}
	return false
}

func (e DeploymentStatusState) String() string {
	return string(e)
}

func (e *DeploymentStatusState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentStatusState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentStatusState", str)
	}
	return nil
}

func (e DeploymentStatusState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible sides of a diff.
type DiffSide string

const (
	// The left side of the diff.
	DiffSideLeft DiffSide = "LEFT"
	// The right side of the diff.
	DiffSideRight DiffSide = "RIGHT"
)

var AllDiffSide = []DiffSide{
	DiffSideLeft,
	DiffSideRight,
}

func (e DiffSide) IsValid() bool {
	switch e {
	case DiffSideLeft, DiffSideRight:
		return true
	}
	return false
}

func (e DiffSide) String() string {
	return string(e)
}

func (e *DiffSide) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiffSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiffSide", str)
	}
	return nil
}

func (e DiffSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons for closing a discussion.
type DiscussionCloseReason string

const (
	// The discussion has been resolved
	DiscussionCloseReasonResolved DiscussionCloseReason = "RESOLVED"
	// The discussion is no longer relevant
	DiscussionCloseReasonOutdated DiscussionCloseReason = "OUTDATED"
	// The discussion is a duplicate of another
	DiscussionCloseReasonDuplicate DiscussionCloseReason = "DUPLICATE"
)

var AllDiscussionCloseReason = []DiscussionCloseReason{
	DiscussionCloseReasonResolved,
	DiscussionCloseReasonOutdated,
	DiscussionCloseReasonDuplicate,
}

func (e DiscussionCloseReason) IsValid() bool {
	switch e {
	case DiscussionCloseReasonResolved, DiscussionCloseReasonOutdated, DiscussionCloseReasonDuplicate:
		return true
	}
	return false
}

func (e DiscussionCloseReason) String() string {
	return string(e)
}

func (e *DiscussionCloseReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscussionCloseReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscussionCloseReason", str)
	}
	return nil
}

func (e DiscussionCloseReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which discussion connections can be ordered.
type DiscussionOrderField string

const (
	// Order discussions by creation time.
	DiscussionOrderFieldCreatedAt DiscussionOrderField = "CREATED_AT"
	// Order discussions by most recent modification time.
	DiscussionOrderFieldUpdatedAt DiscussionOrderField = "UPDATED_AT"
)

var AllDiscussionOrderField = []DiscussionOrderField{
	DiscussionOrderFieldCreatedAt,
	DiscussionOrderFieldUpdatedAt,
}

func (e DiscussionOrderField) IsValid() bool {
	switch e {
	case DiscussionOrderFieldCreatedAt, DiscussionOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DiscussionOrderField) String() string {
	return string(e)
}

func (e *DiscussionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscussionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscussionOrderField", str)
	}
	return nil
}

func (e DiscussionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which discussion poll option connections can be ordered.
type DiscussionPollOptionOrderField string

const (
	// Order poll options by the order that the poll author specified when creating the poll.
	DiscussionPollOptionOrderFieldAuthoredOrder DiscussionPollOptionOrderField = "AUTHORED_ORDER"
	// Order poll options by the number of votes it has.
	DiscussionPollOptionOrderFieldVoteCount DiscussionPollOptionOrderField = "VOTE_COUNT"
)

var AllDiscussionPollOptionOrderField = []DiscussionPollOptionOrderField{
	DiscussionPollOptionOrderFieldAuthoredOrder,
	DiscussionPollOptionOrderFieldVoteCount,
}

func (e DiscussionPollOptionOrderField) IsValid() bool {
	switch e {
	case DiscussionPollOptionOrderFieldAuthoredOrder, DiscussionPollOptionOrderFieldVoteCount:
		return true
	}
	return false
}

func (e DiscussionPollOptionOrderField) String() string {
	return string(e)
}

func (e *DiscussionPollOptionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscussionPollOptionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscussionPollOptionOrderField", str)
	}
	return nil
}

func (e DiscussionPollOptionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a discussion.
type DiscussionState string

const (
	// A discussion that is open
	DiscussionStateOpen DiscussionState = "OPEN"
	// A discussion that has been closed
	DiscussionStateClosed DiscussionState = "CLOSED"
)

var AllDiscussionState = []DiscussionState{
	DiscussionStateOpen,
	DiscussionStateClosed,
}

func (e DiscussionState) IsValid() bool {
	switch e {
	case DiscussionStateOpen, DiscussionStateClosed:
		return true
	}
	return false
}

func (e DiscussionState) String() string {
	return string(e)
}

func (e *DiscussionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscussionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscussionState", str)
	}
	return nil
}

func (e DiscussionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible state reasons of a discussion.
type DiscussionStateReason string

const (
	// The discussion has been resolved
	DiscussionStateReasonResolved DiscussionStateReason = "RESOLVED"
	// The discussion is no longer relevant
	DiscussionStateReasonOutdated DiscussionStateReason = "OUTDATED"
	// The discussion is a duplicate of another
	DiscussionStateReasonDuplicate DiscussionStateReason = "DUPLICATE"
	// The discussion was reopened
	DiscussionStateReasonReopened DiscussionStateReason = "REOPENED"
)

var AllDiscussionStateReason = []DiscussionStateReason{
	DiscussionStateReasonResolved,
	DiscussionStateReasonOutdated,
	DiscussionStateReasonDuplicate,
	DiscussionStateReasonReopened,
}

func (e DiscussionStateReason) IsValid() bool {
	switch e {
	case DiscussionStateReasonResolved, DiscussionStateReasonOutdated, DiscussionStateReasonDuplicate, DiscussionStateReasonReopened:
		return true
	}
	return false
}

func (e DiscussionStateReason) String() string {
	return string(e)
}

func (e *DiscussionStateReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscussionStateReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscussionStateReason", str)
	}
	return nil
}

func (e DiscussionStateReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons that a Dependabot alert was dismissed.
type DismissReason string

const (
	// A fix has already been started
	DismissReasonFixStarted DismissReason = "FIX_STARTED"
	// No bandwidth to fix this
	DismissReasonNoBandwidth DismissReason = "NO_BANDWIDTH"
	// Risk is tolerable to this project
	DismissReasonTolerableRisk DismissReason = "TOLERABLE_RISK"
	// This alert is inaccurate or incorrect
	DismissReasonInaccurate DismissReason = "INACCURATE"
	// Vulnerable code is not actually used
	DismissReasonNotUsed DismissReason = "NOT_USED"
)

var AllDismissReason = []DismissReason{
	DismissReasonFixStarted,
	DismissReasonNoBandwidth,
	DismissReasonTolerableRisk,
	DismissReasonInaccurate,
	DismissReasonNotUsed,
}

func (e DismissReason) IsValid() bool {
	switch e {
	case DismissReasonFixStarted, DismissReasonNoBandwidth, DismissReasonTolerableRisk, DismissReasonInaccurate, DismissReasonNotUsed:
		return true
	}
	return false
}

func (e DismissReason) String() string {
	return string(e)
}

func (e *DismissReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DismissReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DismissReason", str)
	}
	return nil
}

func (e DismissReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which enterprise administrator invitation connections can be ordered.
type EnterpriseAdministratorInvitationOrderField string

const (
	// Order enterprise administrator member invitations by creation time
	EnterpriseAdministratorInvitationOrderFieldCreatedAt EnterpriseAdministratorInvitationOrderField = "CREATED_AT"
)

var AllEnterpriseAdministratorInvitationOrderField = []EnterpriseAdministratorInvitationOrderField{
	EnterpriseAdministratorInvitationOrderFieldCreatedAt,
}

func (e EnterpriseAdministratorInvitationOrderField) IsValid() bool {
	switch e {
	case EnterpriseAdministratorInvitationOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseAdministratorInvitationOrderField) String() string {
	return string(e)
}

func (e *EnterpriseAdministratorInvitationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseAdministratorInvitationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseAdministratorInvitationOrderField", str)
	}
	return nil
}

func (e EnterpriseAdministratorInvitationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible administrator roles in an enterprise account.
type EnterpriseAdministratorRole string

const (
	// Represents an owner of the enterprise account.
	EnterpriseAdministratorRoleOwner EnterpriseAdministratorRole = "OWNER"
	// Represents a billing manager of the enterprise account.
	EnterpriseAdministratorRoleBillingManager EnterpriseAdministratorRole = "BILLING_MANAGER"
)

var AllEnterpriseAdministratorRole = []EnterpriseAdministratorRole{
	EnterpriseAdministratorRoleOwner,
	EnterpriseAdministratorRoleBillingManager,
}

func (e EnterpriseAdministratorRole) IsValid() bool {
	switch e {
	case EnterpriseAdministratorRoleOwner, EnterpriseAdministratorRoleBillingManager:
		return true
	}
	return false
}

func (e EnterpriseAdministratorRole) String() string {
	return string(e)
}

func (e *EnterpriseAdministratorRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseAdministratorRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseAdministratorRole", str)
	}
	return nil
}

func (e EnterpriseAdministratorRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the enterprise allow private repository forking policy value.
type EnterpriseAllowPrivateRepositoryForkingPolicyValue string

const (
	// Members can fork a repository to an organization within this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizations EnterpriseAllowPrivateRepositoryForkingPolicyValue = "ENTERPRISE_ORGANIZATIONS"
	// Members can fork a repository only within the same organization (intra-org).
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganization EnterpriseAllowPrivateRepositoryForkingPolicyValue = "SAME_ORGANIZATION"
	// Members can fork a repository to their user account or within the same organization.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganizationUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "SAME_ORGANIZATION_USER_ACCOUNTS"
	// Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizationsUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS"
	// Members can fork a repository to their user account.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueUserAccounts EnterpriseAllowPrivateRepositoryForkingPolicyValue = "USER_ACCOUNTS"
	// Members can fork a repository to their user account or an organization, either inside or outside of this enterprise.
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEverywhere EnterpriseAllowPrivateRepositoryForkingPolicyValue = "EVERYWHERE"
)

var AllEnterpriseAllowPrivateRepositoryForkingPolicyValue = []EnterpriseAllowPrivateRepositoryForkingPolicyValue{
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizations,
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganization,
	EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganizationUserAccounts,
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizationsUserAccounts,
	EnterpriseAllowPrivateRepositoryForkingPolicyValueUserAccounts,
	EnterpriseAllowPrivateRepositoryForkingPolicyValueEverywhere,
}

func (e EnterpriseAllowPrivateRepositoryForkingPolicyValue) IsValid() bool {
	switch e {
	case EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizations, EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganization, EnterpriseAllowPrivateRepositoryForkingPolicyValueSameOrganizationUserAccounts, EnterpriseAllowPrivateRepositoryForkingPolicyValueEnterpriseOrganizationsUserAccounts, EnterpriseAllowPrivateRepositoryForkingPolicyValueUserAccounts, EnterpriseAllowPrivateRepositoryForkingPolicyValueEverywhere:
		return true
	}
	return false
}

func (e EnterpriseAllowPrivateRepositoryForkingPolicyValue) String() string {
	return string(e)
}

func (e *EnterpriseAllowPrivateRepositoryForkingPolicyValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseAllowPrivateRepositoryForkingPolicyValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseAllowPrivateRepositoryForkingPolicyValue", str)
	}
	return nil
}

func (e EnterpriseAllowPrivateRepositoryForkingPolicyValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the enterprise base repository permission setting.
type EnterpriseDefaultRepositoryPermissionSettingValue string

const (
	// Organizations in the enterprise choose base repository permissions for their members.
	EnterpriseDefaultRepositoryPermissionSettingValueNoPolicy EnterpriseDefaultRepositoryPermissionSettingValue = "NO_POLICY"
	// Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueAdmin EnterpriseDefaultRepositoryPermissionSettingValue = "ADMIN"
	// Organization members will be able to clone, pull, and push all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueWrite EnterpriseDefaultRepositoryPermissionSettingValue = "WRITE"
	// Organization members will be able to clone and pull all organization repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueRead EnterpriseDefaultRepositoryPermissionSettingValue = "READ"
	// Organization members will only be able to clone and pull public repositories.
	EnterpriseDefaultRepositoryPermissionSettingValueNone EnterpriseDefaultRepositoryPermissionSettingValue = "NONE"
)

var AllEnterpriseDefaultRepositoryPermissionSettingValue = []EnterpriseDefaultRepositoryPermissionSettingValue{
	EnterpriseDefaultRepositoryPermissionSettingValueNoPolicy,
	EnterpriseDefaultRepositoryPermissionSettingValueAdmin,
	EnterpriseDefaultRepositoryPermissionSettingValueWrite,
	EnterpriseDefaultRepositoryPermissionSettingValueRead,
	EnterpriseDefaultRepositoryPermissionSettingValueNone,
}

func (e EnterpriseDefaultRepositoryPermissionSettingValue) IsValid() bool {
	switch e {
	case EnterpriseDefaultRepositoryPermissionSettingValueNoPolicy, EnterpriseDefaultRepositoryPermissionSettingValueAdmin, EnterpriseDefaultRepositoryPermissionSettingValueWrite, EnterpriseDefaultRepositoryPermissionSettingValueRead, EnterpriseDefaultRepositoryPermissionSettingValueNone:
		return true
	}
	return false
}

func (e EnterpriseDefaultRepositoryPermissionSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseDefaultRepositoryPermissionSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseDefaultRepositoryPermissionSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseDefaultRepositoryPermissionSettingValue", str)
	}
	return nil
}

func (e EnterpriseDefaultRepositoryPermissionSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for an enabled/no policy enterprise setting.
type EnterpriseDisallowedMethodsSettingValue string

const (
	// The setting prevents insecure 2FA methods from being used by members of the enterprise.
	EnterpriseDisallowedMethodsSettingValueInsecure EnterpriseDisallowedMethodsSettingValue = "INSECURE"
	// There is no policy set for preventing insecure 2FA methods from being used by members of the enterprise.
	EnterpriseDisallowedMethodsSettingValueNoPolicy EnterpriseDisallowedMethodsSettingValue = "NO_POLICY"
)

var AllEnterpriseDisallowedMethodsSettingValue = []EnterpriseDisallowedMethodsSettingValue{
	EnterpriseDisallowedMethodsSettingValueInsecure,
	EnterpriseDisallowedMethodsSettingValueNoPolicy,
}

func (e EnterpriseDisallowedMethodsSettingValue) IsValid() bool {
	switch e {
	case EnterpriseDisallowedMethodsSettingValueInsecure, EnterpriseDisallowedMethodsSettingValueNoPolicy:
		return true
	}
	return false
}

func (e EnterpriseDisallowedMethodsSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseDisallowedMethodsSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseDisallowedMethodsSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseDisallowedMethodsSettingValue", str)
	}
	return nil
}

func (e EnterpriseDisallowedMethodsSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for an enabled/disabled enterprise setting.
type EnterpriseEnabledDisabledSettingValue string

const (
	// The setting is enabled for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueEnabled EnterpriseEnabledDisabledSettingValue = "ENABLED"
	// The setting is disabled for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueDisabled EnterpriseEnabledDisabledSettingValue = "DISABLED"
	// There is no policy set for organizations in the enterprise.
	EnterpriseEnabledDisabledSettingValueNoPolicy EnterpriseEnabledDisabledSettingValue = "NO_POLICY"
)

var AllEnterpriseEnabledDisabledSettingValue = []EnterpriseEnabledDisabledSettingValue{
	EnterpriseEnabledDisabledSettingValueEnabled,
	EnterpriseEnabledDisabledSettingValueDisabled,
	EnterpriseEnabledDisabledSettingValueNoPolicy,
}

func (e EnterpriseEnabledDisabledSettingValue) IsValid() bool {
	switch e {
	case EnterpriseEnabledDisabledSettingValueEnabled, EnterpriseEnabledDisabledSettingValueDisabled, EnterpriseEnabledDisabledSettingValueNoPolicy:
		return true
	}
	return false
}

func (e EnterpriseEnabledDisabledSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseEnabledDisabledSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseEnabledDisabledSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseEnabledDisabledSettingValue", str)
	}
	return nil
}

func (e EnterpriseEnabledDisabledSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for an enabled/no policy enterprise setting.
type EnterpriseEnabledSettingValue string

const (
	// The setting is enabled for organizations in the enterprise.
	EnterpriseEnabledSettingValueEnabled EnterpriseEnabledSettingValue = "ENABLED"
	// There is no policy set for organizations in the enterprise.
	EnterpriseEnabledSettingValueNoPolicy EnterpriseEnabledSettingValue = "NO_POLICY"
)

var AllEnterpriseEnabledSettingValue = []EnterpriseEnabledSettingValue{
	EnterpriseEnabledSettingValueEnabled,
	EnterpriseEnabledSettingValueNoPolicy,
}

func (e EnterpriseEnabledSettingValue) IsValid() bool {
	switch e {
	case EnterpriseEnabledSettingValueEnabled, EnterpriseEnabledSettingValueNoPolicy:
		return true
	}
	return false
}

func (e EnterpriseEnabledSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseEnabledSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseEnabledSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseEnabledSettingValue", str)
	}
	return nil
}

func (e EnterpriseEnabledSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which enterprise member invitation connections can be ordered.
type EnterpriseMemberInvitationOrderField string

const (
	// Order enterprise member invitations by creation time
	EnterpriseMemberInvitationOrderFieldCreatedAt EnterpriseMemberInvitationOrderField = "CREATED_AT"
)

var AllEnterpriseMemberInvitationOrderField = []EnterpriseMemberInvitationOrderField{
	EnterpriseMemberInvitationOrderFieldCreatedAt,
}

func (e EnterpriseMemberInvitationOrderField) IsValid() bool {
	switch e {
	case EnterpriseMemberInvitationOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseMemberInvitationOrderField) String() string {
	return string(e)
}

func (e *EnterpriseMemberInvitationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseMemberInvitationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseMemberInvitationOrderField", str)
	}
	return nil
}

func (e EnterpriseMemberInvitationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which enterprise member connections can be ordered.
type EnterpriseMemberOrderField string

const (
	// Order enterprise members by login
	EnterpriseMemberOrderFieldLogin EnterpriseMemberOrderField = "LOGIN"
	// Order enterprise members by creation time
	EnterpriseMemberOrderFieldCreatedAt EnterpriseMemberOrderField = "CREATED_AT"
)

var AllEnterpriseMemberOrderField = []EnterpriseMemberOrderField{
	EnterpriseMemberOrderFieldLogin,
	EnterpriseMemberOrderFieldCreatedAt,
}

func (e EnterpriseMemberOrderField) IsValid() bool {
	switch e {
	case EnterpriseMemberOrderFieldLogin, EnterpriseMemberOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseMemberOrderField) String() string {
	return string(e)
}

func (e *EnterpriseMemberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseMemberOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseMemberOrderField", str)
	}
	return nil
}

func (e EnterpriseMemberOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the enterprise members can create repositories setting.
type EnterpriseMembersCanCreateRepositoriesSettingValue string

const (
	// Organization owners choose whether to allow members to create repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueNoPolicy EnterpriseMembersCanCreateRepositoriesSettingValue = "NO_POLICY"
	// Members will be able to create public and private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueAll EnterpriseMembersCanCreateRepositoriesSettingValue = "ALL"
	// Members will be able to create only public repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValuePublic EnterpriseMembersCanCreateRepositoriesSettingValue = "PUBLIC"
	// Members will be able to create only private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValuePrivate EnterpriseMembersCanCreateRepositoriesSettingValue = "PRIVATE"
	// Members will not be able to create public or private repositories.
	EnterpriseMembersCanCreateRepositoriesSettingValueDisabled EnterpriseMembersCanCreateRepositoriesSettingValue = "DISABLED"
)

var AllEnterpriseMembersCanCreateRepositoriesSettingValue = []EnterpriseMembersCanCreateRepositoriesSettingValue{
	EnterpriseMembersCanCreateRepositoriesSettingValueNoPolicy,
	EnterpriseMembersCanCreateRepositoriesSettingValueAll,
	EnterpriseMembersCanCreateRepositoriesSettingValuePublic,
	EnterpriseMembersCanCreateRepositoriesSettingValuePrivate,
	EnterpriseMembersCanCreateRepositoriesSettingValueDisabled,
}

func (e EnterpriseMembersCanCreateRepositoriesSettingValue) IsValid() bool {
	switch e {
	case EnterpriseMembersCanCreateRepositoriesSettingValueNoPolicy, EnterpriseMembersCanCreateRepositoriesSettingValueAll, EnterpriseMembersCanCreateRepositoriesSettingValuePublic, EnterpriseMembersCanCreateRepositoriesSettingValuePrivate, EnterpriseMembersCanCreateRepositoriesSettingValueDisabled:
		return true
	}
	return false
}

func (e EnterpriseMembersCanCreateRepositoriesSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseMembersCanCreateRepositoriesSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseMembersCanCreateRepositoriesSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseMembersCanCreateRepositoriesSettingValue", str)
	}
	return nil
}

func (e EnterpriseMembersCanCreateRepositoriesSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the members can make purchases setting.
type EnterpriseMembersCanMakePurchasesSettingValue string

const (
	// The setting is enabled for organizations in the enterprise.
	EnterpriseMembersCanMakePurchasesSettingValueEnabled EnterpriseMembersCanMakePurchasesSettingValue = "ENABLED"
	// The setting is disabled for organizations in the enterprise.
	EnterpriseMembersCanMakePurchasesSettingValueDisabled EnterpriseMembersCanMakePurchasesSettingValue = "DISABLED"
)

var AllEnterpriseMembersCanMakePurchasesSettingValue = []EnterpriseMembersCanMakePurchasesSettingValue{
	EnterpriseMembersCanMakePurchasesSettingValueEnabled,
	EnterpriseMembersCanMakePurchasesSettingValueDisabled,
}

func (e EnterpriseMembersCanMakePurchasesSettingValue) IsValid() bool {
	switch e {
	case EnterpriseMembersCanMakePurchasesSettingValueEnabled, EnterpriseMembersCanMakePurchasesSettingValueDisabled:
		return true
	}
	return false
}

func (e EnterpriseMembersCanMakePurchasesSettingValue) String() string {
	return string(e)
}

func (e *EnterpriseMembersCanMakePurchasesSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseMembersCanMakePurchasesSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseMembersCanMakePurchasesSettingValue", str)
	}
	return nil
}

func (e EnterpriseMembersCanMakePurchasesSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values we have for filtering Platform::Objects::User#enterprises.
type EnterpriseMembershipType string

const (
	// Returns all enterprises in which the user is a member, admin, or billing manager.
	EnterpriseMembershipTypeAll EnterpriseMembershipType = "ALL"
	// Returns all enterprises in which the user is an admin.
	EnterpriseMembershipTypeAdmin EnterpriseMembershipType = "ADMIN"
	// Returns all enterprises in which the user is a billing manager.
	EnterpriseMembershipTypeBillingManager EnterpriseMembershipType = "BILLING_MANAGER"
	// Returns all enterprises in which the user is a member of an org that is owned by the enterprise.
	EnterpriseMembershipTypeOrgMembership EnterpriseMembershipType = "ORG_MEMBERSHIP"
)

var AllEnterpriseMembershipType = []EnterpriseMembershipType{
	EnterpriseMembershipTypeAll,
	EnterpriseMembershipTypeAdmin,
	EnterpriseMembershipTypeBillingManager,
	EnterpriseMembershipTypeOrgMembership,
}

func (e EnterpriseMembershipType) IsValid() bool {
	switch e {
	case EnterpriseMembershipTypeAll, EnterpriseMembershipTypeAdmin, EnterpriseMembershipTypeBillingManager, EnterpriseMembershipTypeOrgMembership:
		return true
	}
	return false
}

func (e EnterpriseMembershipType) String() string {
	return string(e)
}

func (e *EnterpriseMembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseMembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseMembershipType", str)
	}
	return nil
}

func (e EnterpriseMembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which enterprise connections can be ordered.
type EnterpriseOrderField string

const (
	// Order enterprises by name
	EnterpriseOrderFieldName EnterpriseOrderField = "NAME"
)

var AllEnterpriseOrderField = []EnterpriseOrderField{
	EnterpriseOrderFieldName,
}

func (e EnterpriseOrderField) IsValid() bool {
	switch e {
	case EnterpriseOrderFieldName:
		return true
	}
	return false
}

func (e EnterpriseOrderField) String() string {
	return string(e)
}

func (e *EnterpriseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseOrderField", str)
	}
	return nil
}

func (e EnterpriseOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Enterprise Server installation connections can be ordered.
type EnterpriseServerInstallationOrderField string

const (
	// Order Enterprise Server installations by host name
	EnterpriseServerInstallationOrderFieldHostName EnterpriseServerInstallationOrderField = "HOST_NAME"
	// Order Enterprise Server installations by customer name
	EnterpriseServerInstallationOrderFieldCustomerName EnterpriseServerInstallationOrderField = "CUSTOMER_NAME"
	// Order Enterprise Server installations by creation time
	EnterpriseServerInstallationOrderFieldCreatedAt EnterpriseServerInstallationOrderField = "CREATED_AT"
)

var AllEnterpriseServerInstallationOrderField = []EnterpriseServerInstallationOrderField{
	EnterpriseServerInstallationOrderFieldHostName,
	EnterpriseServerInstallationOrderFieldCustomerName,
	EnterpriseServerInstallationOrderFieldCreatedAt,
}

func (e EnterpriseServerInstallationOrderField) IsValid() bool {
	switch e {
	case EnterpriseServerInstallationOrderFieldHostName, EnterpriseServerInstallationOrderFieldCustomerName, EnterpriseServerInstallationOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseServerInstallationOrderField) String() string {
	return string(e)
}

func (e *EnterpriseServerInstallationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseServerInstallationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseServerInstallationOrderField", str)
	}
	return nil
}

func (e EnterpriseServerInstallationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Enterprise Server user account email connections can be ordered.
type EnterpriseServerUserAccountEmailOrderField string

const (
	// Order emails by email
	EnterpriseServerUserAccountEmailOrderFieldEmail EnterpriseServerUserAccountEmailOrderField = "EMAIL"
)

var AllEnterpriseServerUserAccountEmailOrderField = []EnterpriseServerUserAccountEmailOrderField{
	EnterpriseServerUserAccountEmailOrderFieldEmail,
}

func (e EnterpriseServerUserAccountEmailOrderField) IsValid() bool {
	switch e {
	case EnterpriseServerUserAccountEmailOrderFieldEmail:
		return true
	}
	return false
}

func (e EnterpriseServerUserAccountEmailOrderField) String() string {
	return string(e)
}

func (e *EnterpriseServerUserAccountEmailOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseServerUserAccountEmailOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseServerUserAccountEmailOrderField", str)
	}
	return nil
}

func (e EnterpriseServerUserAccountEmailOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Enterprise Server user account connections can be ordered.
type EnterpriseServerUserAccountOrderField string

const (
	// Order user accounts by login
	EnterpriseServerUserAccountOrderFieldLogin EnterpriseServerUserAccountOrderField = "LOGIN"
	// Order user accounts by creation time on the Enterprise Server installation
	EnterpriseServerUserAccountOrderFieldRemoteCreatedAt EnterpriseServerUserAccountOrderField = "REMOTE_CREATED_AT"
)

var AllEnterpriseServerUserAccountOrderField = []EnterpriseServerUserAccountOrderField{
	EnterpriseServerUserAccountOrderFieldLogin,
	EnterpriseServerUserAccountOrderFieldRemoteCreatedAt,
}

func (e EnterpriseServerUserAccountOrderField) IsValid() bool {
	switch e {
	case EnterpriseServerUserAccountOrderFieldLogin, EnterpriseServerUserAccountOrderFieldRemoteCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseServerUserAccountOrderField) String() string {
	return string(e)
}

func (e *EnterpriseServerUserAccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseServerUserAccountOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseServerUserAccountOrderField", str)
	}
	return nil
}

func (e EnterpriseServerUserAccountOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Enterprise Server user accounts upload connections can be ordered.
type EnterpriseServerUserAccountsUploadOrderField string

const (
	// Order user accounts uploads by creation time
	EnterpriseServerUserAccountsUploadOrderFieldCreatedAt EnterpriseServerUserAccountsUploadOrderField = "CREATED_AT"
)

var AllEnterpriseServerUserAccountsUploadOrderField = []EnterpriseServerUserAccountsUploadOrderField{
	EnterpriseServerUserAccountsUploadOrderFieldCreatedAt,
}

func (e EnterpriseServerUserAccountsUploadOrderField) IsValid() bool {
	switch e {
	case EnterpriseServerUserAccountsUploadOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e EnterpriseServerUserAccountsUploadOrderField) String() string {
	return string(e)
}

func (e *EnterpriseServerUserAccountsUploadOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseServerUserAccountsUploadOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseServerUserAccountsUploadOrderField", str)
	}
	return nil
}

func (e EnterpriseServerUserAccountsUploadOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Synchronization state of the Enterprise Server user accounts upload
type EnterpriseServerUserAccountsUploadSyncState string

const (
	// The synchronization of the upload is pending.
	EnterpriseServerUserAccountsUploadSyncStatePending EnterpriseServerUserAccountsUploadSyncState = "PENDING"
	// The synchronization of the upload succeeded.
	EnterpriseServerUserAccountsUploadSyncStateSuccess EnterpriseServerUserAccountsUploadSyncState = "SUCCESS"
	// The synchronization of the upload failed.
	EnterpriseServerUserAccountsUploadSyncStateFailure EnterpriseServerUserAccountsUploadSyncState = "FAILURE"
)

var AllEnterpriseServerUserAccountsUploadSyncState = []EnterpriseServerUserAccountsUploadSyncState{
	EnterpriseServerUserAccountsUploadSyncStatePending,
	EnterpriseServerUserAccountsUploadSyncStateSuccess,
	EnterpriseServerUserAccountsUploadSyncStateFailure,
}

func (e EnterpriseServerUserAccountsUploadSyncState) IsValid() bool {
	switch e {
	case EnterpriseServerUserAccountsUploadSyncStatePending, EnterpriseServerUserAccountsUploadSyncStateSuccess, EnterpriseServerUserAccountsUploadSyncStateFailure:
		return true
	}
	return false
}

func (e EnterpriseServerUserAccountsUploadSyncState) String() string {
	return string(e)
}

func (e *EnterpriseServerUserAccountsUploadSyncState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseServerUserAccountsUploadSyncState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseServerUserAccountsUploadSyncState", str)
	}
	return nil
}

func (e EnterpriseServerUserAccountsUploadSyncState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible roles for enterprise membership.
type EnterpriseUserAccountMembershipRole string

const (
	// The user is a member of an organization in the enterprise.
	EnterpriseUserAccountMembershipRoleMember EnterpriseUserAccountMembershipRole = "MEMBER"
	// The user is an owner of an organization in the enterprise.
	EnterpriseUserAccountMembershipRoleOwner EnterpriseUserAccountMembershipRole = "OWNER"
	// The user is not an owner of the enterprise, and not a member or owner of any organizations in the enterprise; only for EMU-enabled enterprises.
	EnterpriseUserAccountMembershipRoleUnaffiliated EnterpriseUserAccountMembershipRole = "UNAFFILIATED"
)

var AllEnterpriseUserAccountMembershipRole = []EnterpriseUserAccountMembershipRole{
	EnterpriseUserAccountMembershipRoleMember,
	EnterpriseUserAccountMembershipRoleOwner,
	EnterpriseUserAccountMembershipRoleUnaffiliated,
}

func (e EnterpriseUserAccountMembershipRole) IsValid() bool {
	switch e {
	case EnterpriseUserAccountMembershipRoleMember, EnterpriseUserAccountMembershipRoleOwner, EnterpriseUserAccountMembershipRoleUnaffiliated:
		return true
	}
	return false
}

func (e EnterpriseUserAccountMembershipRole) String() string {
	return string(e)
}

func (e *EnterpriseUserAccountMembershipRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseUserAccountMembershipRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseUserAccountMembershipRole", str)
	}
	return nil
}

func (e EnterpriseUserAccountMembershipRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible GitHub Enterprise deployments where this user can exist.
type EnterpriseUserDeployment string

const (
	// The user is part of a GitHub Enterprise Cloud deployment.
	EnterpriseUserDeploymentCloud EnterpriseUserDeployment = "CLOUD"
	// The user is part of a GitHub Enterprise Server deployment.
	EnterpriseUserDeploymentServer EnterpriseUserDeployment = "SERVER"
)

var AllEnterpriseUserDeployment = []EnterpriseUserDeployment{
	EnterpriseUserDeploymentCloud,
	EnterpriseUserDeploymentServer,
}

func (e EnterpriseUserDeployment) IsValid() bool {
	switch e {
	case EnterpriseUserDeploymentCloud, EnterpriseUserDeploymentServer:
		return true
	}
	return false
}

func (e EnterpriseUserDeployment) String() string {
	return string(e)
}

func (e *EnterpriseUserDeployment) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnterpriseUserDeployment(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnterpriseUserDeployment", str)
	}
	return nil
}

func (e EnterpriseUserDeployment) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which environments connections can be ordered
type EnvironmentOrderField string

const (
	// Order environments by name.
	EnvironmentOrderFieldName EnvironmentOrderField = "NAME"
)

var AllEnvironmentOrderField = []EnvironmentOrderField{
	EnvironmentOrderFieldName,
}

func (e EnvironmentOrderField) IsValid() bool {
	switch e {
	case EnvironmentOrderFieldName:
		return true
	}
	return false
}

func (e EnvironmentOrderField) String() string {
	return string(e)
}

func (e *EnvironmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentOrderField", str)
	}
	return nil
}

func (e EnvironmentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which environments connections can be ordered
type EnvironmentPinnedFilterField string

const (
	// All environments will be returned.
	EnvironmentPinnedFilterFieldAll EnvironmentPinnedFilterField = "ALL"
	// Only pinned environment will be returned
	EnvironmentPinnedFilterFieldOnly EnvironmentPinnedFilterField = "ONLY"
	// Environments exclude pinned will be returned
	EnvironmentPinnedFilterFieldNone EnvironmentPinnedFilterField = "NONE"
)

var AllEnvironmentPinnedFilterField = []EnvironmentPinnedFilterField{
	EnvironmentPinnedFilterFieldAll,
	EnvironmentPinnedFilterFieldOnly,
	EnvironmentPinnedFilterFieldNone,
}

func (e EnvironmentPinnedFilterField) IsValid() bool {
	switch e {
	case EnvironmentPinnedFilterFieldAll, EnvironmentPinnedFilterFieldOnly, EnvironmentPinnedFilterFieldNone:
		return true
	}
	return false
}

func (e EnvironmentPinnedFilterField) String() string {
	return string(e)
}

func (e *EnvironmentPinnedFilterField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EnvironmentPinnedFilterField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EnvironmentPinnedFilterField", str)
	}
	return nil
}

func (e EnvironmentPinnedFilterField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible viewed states of a file .
type FileViewedState string

const (
	// The file has new changes since last viewed.
	FileViewedStateDismissed FileViewedState = "DISMISSED"
	// The file has been marked as viewed.
	FileViewedStateViewed FileViewedState = "VIEWED"
	// The file has not been marked as viewed.
	FileViewedStateUnviewed FileViewedState = "UNVIEWED"
)

var AllFileViewedState = []FileViewedState{
	FileViewedStateDismissed,
	FileViewedStateViewed,
	FileViewedStateUnviewed,
}

func (e FileViewedState) IsValid() bool {
	switch e {
	case FileViewedStateDismissed, FileViewedStateViewed, FileViewedStateUnviewed:
		return true
	}
	return false
}

func (e FileViewedState) String() string {
	return string(e)
}

func (e *FileViewedState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileViewedState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileViewedState", str)
	}
	return nil
}

func (e FileViewedState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible funding platforms for repository funding links.
type FundingPlatform string

const (
	// GitHub funding platform.
	FundingPlatformGithub FundingPlatform = "GITHUB"
	// Patreon funding platform.
	FundingPlatformPatreon FundingPlatform = "PATREON"
	// Open Collective funding platform.
	FundingPlatformOpenCollective FundingPlatform = "OPEN_COLLECTIVE"
	// Ko-fi funding platform.
	FundingPlatformKoFi FundingPlatform = "KO_FI"
	// Tidelift funding platform.
	FundingPlatformTidelift FundingPlatform = "TIDELIFT"
	// Community Bridge funding platform.
	FundingPlatformCommunityBridge FundingPlatform = "COMMUNITY_BRIDGE"
	// Liberapay funding platform.
	FundingPlatformLiberapay FundingPlatform = "LIBERAPAY"
	// IssueHunt funding platform.
	FundingPlatformIssuehunt FundingPlatform = "ISSUEHUNT"
	// LFX Crowdfunding funding platform.
	FundingPlatformLfxCrowdfunding FundingPlatform = "LFX_CROWDFUNDING"
	// Polar funding platform.
	FundingPlatformPolar FundingPlatform = "POLAR"
	// Buy Me a Coffee funding platform.
	FundingPlatformBuyMeACoffee FundingPlatform = "BUY_ME_A_COFFEE"
	// thanks.dev funding platform.
	FundingPlatformThanksDev FundingPlatform = "THANKS_DEV"
	// Custom funding platform.
	FundingPlatformCustom FundingPlatform = "CUSTOM"
)

var AllFundingPlatform = []FundingPlatform{
	FundingPlatformGithub,
	FundingPlatformPatreon,
	FundingPlatformOpenCollective,
	FundingPlatformKoFi,
	FundingPlatformTidelift,
	FundingPlatformCommunityBridge,
	FundingPlatformLiberapay,
	FundingPlatformIssuehunt,
	FundingPlatformLfxCrowdfunding,
	FundingPlatformPolar,
	FundingPlatformBuyMeACoffee,
	FundingPlatformThanksDev,
	FundingPlatformCustom,
}

func (e FundingPlatform) IsValid() bool {
	switch e {
	case FundingPlatformGithub, FundingPlatformPatreon, FundingPlatformOpenCollective, FundingPlatformKoFi, FundingPlatformTidelift, FundingPlatformCommunityBridge, FundingPlatformLiberapay, FundingPlatformIssuehunt, FundingPlatformLfxCrowdfunding, FundingPlatformPolar, FundingPlatformBuyMeACoffee, FundingPlatformThanksDev, FundingPlatformCustom:
		return true
	}
	return false
}

func (e FundingPlatform) String() string {
	return string(e)
}

func (e *FundingPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FundingPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FundingPlatform", str)
	}
	return nil
}

func (e FundingPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which gist connections can be ordered.
type GistOrderField string

const (
	// Order gists by creation time
	GistOrderFieldCreatedAt GistOrderField = "CREATED_AT"
	// Order gists by update time
	GistOrderFieldUpdatedAt GistOrderField = "UPDATED_AT"
	// Order gists by push time
	GistOrderFieldPushedAt GistOrderField = "PUSHED_AT"
)

var AllGistOrderField = []GistOrderField{
	GistOrderFieldCreatedAt,
	GistOrderFieldUpdatedAt,
	GistOrderFieldPushedAt,
}

func (e GistOrderField) IsValid() bool {
	switch e {
	case GistOrderFieldCreatedAt, GistOrderFieldUpdatedAt, GistOrderFieldPushedAt:
		return true
	}
	return false
}

func (e GistOrderField) String() string {
	return string(e)
}

func (e *GistOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GistOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GistOrderField", str)
	}
	return nil
}

func (e GistOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a Gist
type GistPrivacy string

const (
	// Public
	GistPrivacyPublic GistPrivacy = "PUBLIC"
	// Secret
	GistPrivacySecret GistPrivacy = "SECRET"
	// Gists that are public and secret
	GistPrivacyAll GistPrivacy = "ALL"
)

var AllGistPrivacy = []GistPrivacy{
	GistPrivacyPublic,
	GistPrivacySecret,
	GistPrivacyAll,
}

func (e GistPrivacy) IsValid() bool {
	switch e {
	case GistPrivacyPublic, GistPrivacySecret, GistPrivacyAll:
		return true
	}
	return false
}

func (e GistPrivacy) String() string {
	return string(e)
}

func (e *GistPrivacy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GistPrivacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GistPrivacy", str)
	}
	return nil
}

func (e GistPrivacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The state of a Git signature.
type GitSignatureState string

const (
	// Valid signature and verified by GitHub
	GitSignatureStateValid GitSignatureState = "VALID"
	// Invalid signature
	GitSignatureStateInvalid GitSignatureState = "INVALID"
	// Malformed signature
	GitSignatureStateMalformedSig GitSignatureState = "MALFORMED_SIG"
	// Key used for signing not known to GitHub
	GitSignatureStateUnknownKey GitSignatureState = "UNKNOWN_KEY"
	// Invalid email used for signing
	GitSignatureStateBadEmail GitSignatureState = "BAD_EMAIL"
	// Email used for signing unverified on GitHub
	GitSignatureStateUnverifiedEmail GitSignatureState = "UNVERIFIED_EMAIL"
	// Email used for signing not known to GitHub
	GitSignatureStateNoUser GitSignatureState = "NO_USER"
	// Unknown signature type
	GitSignatureStateUnknownSigType GitSignatureState = "UNKNOWN_SIG_TYPE"
	// Unsigned
	GitSignatureStateUnsigned GitSignatureState = "UNSIGNED"
	// Internal error - the GPG verification service is unavailable at the moment
	GitSignatureStateGpgverifyUnavailable GitSignatureState = "GPGVERIFY_UNAVAILABLE"
	// Internal error - the GPG verification service misbehaved
	GitSignatureStateGpgverifyError GitSignatureState = "GPGVERIFY_ERROR"
	// The usage flags for the key that signed this don't allow signing
	GitSignatureStateNotSigningKey GitSignatureState = "NOT_SIGNING_KEY"
	// Signing key expired
	GitSignatureStateExpiredKey GitSignatureState = "EXPIRED_KEY"
	// Valid signature, pending certificate revocation checking
	GitSignatureStateOcspPending GitSignatureState = "OCSP_PENDING"
	// Valid signature, though certificate revocation check failed
	GitSignatureStateOcspError GitSignatureState = "OCSP_ERROR"
	// The signing certificate or its chain could not be verified
	GitSignatureStateBadCert GitSignatureState = "BAD_CERT"
	// One or more certificates in chain has been revoked
	GitSignatureStateOcspRevoked GitSignatureState = "OCSP_REVOKED"
)

var AllGitSignatureState = []GitSignatureState{
	GitSignatureStateValid,
	GitSignatureStateInvalid,
	GitSignatureStateMalformedSig,
	GitSignatureStateUnknownKey,
	GitSignatureStateBadEmail,
	GitSignatureStateUnverifiedEmail,
	GitSignatureStateNoUser,
	GitSignatureStateUnknownSigType,
	GitSignatureStateUnsigned,
	GitSignatureStateGpgverifyUnavailable,
	GitSignatureStateGpgverifyError,
	GitSignatureStateNotSigningKey,
	GitSignatureStateExpiredKey,
	GitSignatureStateOcspPending,
	GitSignatureStateOcspError,
	GitSignatureStateBadCert,
	GitSignatureStateOcspRevoked,
}

func (e GitSignatureState) IsValid() bool {
	switch e {
	case GitSignatureStateValid, GitSignatureStateInvalid, GitSignatureStateMalformedSig, GitSignatureStateUnknownKey, GitSignatureStateBadEmail, GitSignatureStateUnverifiedEmail, GitSignatureStateNoUser, GitSignatureStateUnknownSigType, GitSignatureStateUnsigned, GitSignatureStateGpgverifyUnavailable, GitSignatureStateGpgverifyError, GitSignatureStateNotSigningKey, GitSignatureStateExpiredKey, GitSignatureStateOcspPending, GitSignatureStateOcspError, GitSignatureStateBadCert, GitSignatureStateOcspRevoked:
		return true
	}
	return false
}

func (e GitSignatureState) String() string {
	return string(e)
}

func (e *GitSignatureState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitSignatureState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitSignatureState", str)
	}
	return nil
}

func (e GitSignatureState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states in which authentication can be configured with an identity provider.
type IdentityProviderConfigurationState string

const (
	// Authentication with an identity provider is configured and enforced.
	IdentityProviderConfigurationStateEnforced IdentityProviderConfigurationState = "ENFORCED"
	// Authentication with an identity provider is configured but not enforced.
	IdentityProviderConfigurationStateConfigured IdentityProviderConfigurationState = "CONFIGURED"
	// Authentication with an identity provider is not configured.
	IdentityProviderConfigurationStateUnconfigured IdentityProviderConfigurationState = "UNCONFIGURED"
)

var AllIdentityProviderConfigurationState = []IdentityProviderConfigurationState{
	IdentityProviderConfigurationStateEnforced,
	IdentityProviderConfigurationStateConfigured,
	IdentityProviderConfigurationStateUnconfigured,
}

func (e IdentityProviderConfigurationState) IsValid() bool {
	switch e {
	case IdentityProviderConfigurationStateEnforced, IdentityProviderConfigurationStateConfigured, IdentityProviderConfigurationStateUnconfigured:
		return true
	}
	return false
}

func (e IdentityProviderConfigurationState) String() string {
	return string(e)
}

func (e *IdentityProviderConfigurationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentityProviderConfigurationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentityProviderConfigurationState", str)
	}
	return nil
}

func (e IdentityProviderConfigurationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the IP allow list enabled setting.
type IPAllowListEnabledSettingValue string

const (
	// The setting is enabled for the owner.
	IPAllowListEnabledSettingValueEnabled IPAllowListEnabledSettingValue = "ENABLED"
	// The setting is disabled for the owner.
	IPAllowListEnabledSettingValueDisabled IPAllowListEnabledSettingValue = "DISABLED"
)

var AllIPAllowListEnabledSettingValue = []IPAllowListEnabledSettingValue{
	IPAllowListEnabledSettingValueEnabled,
	IPAllowListEnabledSettingValueDisabled,
}

func (e IPAllowListEnabledSettingValue) IsValid() bool {
	switch e {
	case IPAllowListEnabledSettingValueEnabled, IPAllowListEnabledSettingValueDisabled:
		return true
	}
	return false
}

func (e IPAllowListEnabledSettingValue) String() string {
	return string(e)
}

func (e *IPAllowListEnabledSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPAllowListEnabledSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpAllowListEnabledSettingValue", str)
	}
	return nil
}

func (e IPAllowListEnabledSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IP allow list entry connections can be ordered.
type IPAllowListEntryOrderField string

const (
	// Order IP allow list entries by creation time.
	IPAllowListEntryOrderFieldCreatedAt IPAllowListEntryOrderField = "CREATED_AT"
	// Order IP allow list entries by the allow list value.
	IPAllowListEntryOrderFieldAllowListValue IPAllowListEntryOrderField = "ALLOW_LIST_VALUE"
)

var AllIPAllowListEntryOrderField = []IPAllowListEntryOrderField{
	IPAllowListEntryOrderFieldCreatedAt,
	IPAllowListEntryOrderFieldAllowListValue,
}

func (e IPAllowListEntryOrderField) IsValid() bool {
	switch e {
	case IPAllowListEntryOrderFieldCreatedAt, IPAllowListEntryOrderFieldAllowListValue:
		return true
	}
	return false
}

func (e IPAllowListEntryOrderField) String() string {
	return string(e)
}

func (e *IPAllowListEntryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPAllowListEntryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpAllowListEntryOrderField", str)
	}
	return nil
}

func (e IPAllowListEntryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the IP allow list configuration for installed GitHub Apps setting.
type IPAllowListForInstalledAppsEnabledSettingValue string

const (
	// The setting is enabled for the owner.
	IPAllowListForInstalledAppsEnabledSettingValueEnabled IPAllowListForInstalledAppsEnabledSettingValue = "ENABLED"
	// The setting is disabled for the owner.
	IPAllowListForInstalledAppsEnabledSettingValueDisabled IPAllowListForInstalledAppsEnabledSettingValue = "DISABLED"
)

var AllIPAllowListForInstalledAppsEnabledSettingValue = []IPAllowListForInstalledAppsEnabledSettingValue{
	IPAllowListForInstalledAppsEnabledSettingValueEnabled,
	IPAllowListForInstalledAppsEnabledSettingValueDisabled,
}

func (e IPAllowListForInstalledAppsEnabledSettingValue) IsValid() bool {
	switch e {
	case IPAllowListForInstalledAppsEnabledSettingValueEnabled, IPAllowListForInstalledAppsEnabledSettingValueDisabled:
		return true
	}
	return false
}

func (e IPAllowListForInstalledAppsEnabledSettingValue) String() string {
	return string(e)
}

func (e *IPAllowListForInstalledAppsEnabledSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPAllowListForInstalledAppsEnabledSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpAllowListForInstalledAppsEnabledSettingValue", str)
	}
	return nil
}

func (e IPAllowListForInstalledAppsEnabledSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible state reasons of a closed issue.
type IssueClosedStateReason string

const (
	// An issue that has been closed as completed
	IssueClosedStateReasonCompleted IssueClosedStateReason = "COMPLETED"
	// An issue that has been closed as not planned
	IssueClosedStateReasonNotPlanned IssueClosedStateReason = "NOT_PLANNED"
	// An issue that has been closed as a duplicate
	IssueClosedStateReasonDuplicate IssueClosedStateReason = "DUPLICATE"
)

var AllIssueClosedStateReason = []IssueClosedStateReason{
	IssueClosedStateReasonCompleted,
	IssueClosedStateReasonNotPlanned,
	IssueClosedStateReasonDuplicate,
}

func (e IssueClosedStateReason) IsValid() bool {
	switch e {
	case IssueClosedStateReasonCompleted, IssueClosedStateReasonNotPlanned, IssueClosedStateReasonDuplicate:
		return true
	}
	return false
}

func (e IssueClosedStateReason) String() string {
	return string(e)
}

func (e *IssueClosedStateReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueClosedStateReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueClosedStateReason", str)
	}
	return nil
}

func (e IssueClosedStateReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which issue comment connections can be ordered.
type IssueCommentOrderField string

const (
	// Order issue comments by update time
	IssueCommentOrderFieldUpdatedAt IssueCommentOrderField = "UPDATED_AT"
)

var AllIssueCommentOrderField = []IssueCommentOrderField{
	IssueCommentOrderFieldUpdatedAt,
}

func (e IssueCommentOrderField) IsValid() bool {
	switch e {
	case IssueCommentOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e IssueCommentOrderField) String() string {
	return string(e)
}

func (e *IssueCommentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueCommentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueCommentOrderField", str)
	}
	return nil
}

func (e IssueCommentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which issue connections can be ordered.
type IssueOrderField string

const (
	// Order issues by creation time
	IssueOrderFieldCreatedAt IssueOrderField = "CREATED_AT"
	// Order issues by update time
	IssueOrderFieldUpdatedAt IssueOrderField = "UPDATED_AT"
	// Order issues by comment count
	IssueOrderFieldComments IssueOrderField = "COMMENTS"
)

var AllIssueOrderField = []IssueOrderField{
	IssueOrderFieldCreatedAt,
	IssueOrderFieldUpdatedAt,
	IssueOrderFieldComments,
}

func (e IssueOrderField) IsValid() bool {
	switch e {
	case IssueOrderFieldCreatedAt, IssueOrderFieldUpdatedAt, IssueOrderFieldComments:
		return true
	}
	return false
}

func (e IssueOrderField) String() string {
	return string(e)
}

func (e *IssueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueOrderField", str)
	}
	return nil
}

func (e IssueOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of an issue.
type IssueState string

const (
	// An issue that is still open
	IssueStateOpen IssueState = "OPEN"
	// An issue that has been closed
	IssueStateClosed IssueState = "CLOSED"
)

var AllIssueState = []IssueState{
	IssueStateOpen,
	IssueStateClosed,
}

func (e IssueState) IsValid() bool {
	switch e {
	case IssueStateOpen, IssueStateClosed:
		return true
	}
	return false
}

func (e IssueState) String() string {
	return string(e)
}

func (e *IssueState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueState", str)
	}
	return nil
}

func (e IssueState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible state reasons of an issue.
type IssueStateReason string

const (
	// An issue that has been reopened
	IssueStateReasonReopened IssueStateReason = "REOPENED"
	// An issue that has been closed as not planned
	IssueStateReasonNotPlanned IssueStateReason = "NOT_PLANNED"
	// An issue that has been closed as completed
	IssueStateReasonCompleted IssueStateReason = "COMPLETED"
	// An issue that has been closed as a duplicate
	IssueStateReasonDuplicate IssueStateReason = "DUPLICATE"
)

var AllIssueStateReason = []IssueStateReason{
	IssueStateReasonReopened,
	IssueStateReasonNotPlanned,
	IssueStateReasonCompleted,
	IssueStateReasonDuplicate,
}

func (e IssueStateReason) IsValid() bool {
	switch e {
	case IssueStateReasonReopened, IssueStateReasonNotPlanned, IssueStateReasonCompleted, IssueStateReasonDuplicate:
		return true
	}
	return false
}

func (e IssueStateReason) String() string {
	return string(e)
}

func (e *IssueStateReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueStateReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueStateReason", str)
	}
	return nil
}

func (e IssueStateReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible item types found in a timeline.
type IssueTimelineItemsItemType string

const (
	// Represents a comment on an Issue.
	IssueTimelineItemsItemTypeIssueComment IssueTimelineItemsItemType = "ISSUE_COMMENT"
	// Represents a mention made by one issue or pull request to another.
	IssueTimelineItemsItemTypeCrossReferencedEvent IssueTimelineItemsItemType = "CROSS_REFERENCED_EVENT"
	// Represents a 'added_to_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeAddedToProjectEvent IssueTimelineItemsItemType = "ADDED_TO_PROJECT_EVENT"
	// Represents an 'assigned' event on any assignable object.
	IssueTimelineItemsItemTypeAssignedEvent IssueTimelineItemsItemType = "ASSIGNED_EVENT"
	// Represents a 'closed' event on any `Closable`.
	IssueTimelineItemsItemTypeClosedEvent IssueTimelineItemsItemType = "CLOSED_EVENT"
	// Represents a 'comment_deleted' event on a given issue or pull request.
	IssueTimelineItemsItemTypeCommentDeletedEvent IssueTimelineItemsItemType = "COMMENT_DELETED_EVENT"
	// Represents a 'connected' event on a given issue or pull request.
	IssueTimelineItemsItemTypeConnectedEvent IssueTimelineItemsItemType = "CONNECTED_EVENT"
	// Represents a 'converted_note_to_issue' event on a given issue or pull request.
	IssueTimelineItemsItemTypeConvertedNoteToIssueEvent IssueTimelineItemsItemType = "CONVERTED_NOTE_TO_ISSUE_EVENT"
	// Represents a 'converted_to_discussion' event on a given issue.
	IssueTimelineItemsItemTypeConvertedToDiscussionEvent IssueTimelineItemsItemType = "CONVERTED_TO_DISCUSSION_EVENT"
	// Represents a 'demilestoned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeDemilestonedEvent IssueTimelineItemsItemType = "DEMILESTONED_EVENT"
	// Represents a 'disconnected' event on a given issue or pull request.
	IssueTimelineItemsItemTypeDisconnectedEvent IssueTimelineItemsItemType = "DISCONNECTED_EVENT"
	// Represents a 'labeled' event on a given issue or pull request.
	IssueTimelineItemsItemTypeLabeledEvent IssueTimelineItemsItemType = "LABELED_EVENT"
	// Represents a 'locked' event on a given issue or pull request.
	IssueTimelineItemsItemTypeLockedEvent IssueTimelineItemsItemType = "LOCKED_EVENT"
	// Represents a 'marked_as_duplicate' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMarkedAsDuplicateEvent IssueTimelineItemsItemType = "MARKED_AS_DUPLICATE_EVENT"
	// Represents a 'mentioned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMentionedEvent IssueTimelineItemsItemType = "MENTIONED_EVENT"
	// Represents a 'milestoned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMilestonedEvent IssueTimelineItemsItemType = "MILESTONED_EVENT"
	// Represents a 'moved_columns_in_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeMovedColumnsInProjectEvent IssueTimelineItemsItemType = "MOVED_COLUMNS_IN_PROJECT_EVENT"
	// Represents a 'pinned' event on a given issue or pull request.
	IssueTimelineItemsItemTypePinnedEvent IssueTimelineItemsItemType = "PINNED_EVENT"
	// Represents a 'referenced' event on a given `ReferencedSubject`.
	IssueTimelineItemsItemTypeReferencedEvent IssueTimelineItemsItemType = "REFERENCED_EVENT"
	// Represents a 'removed_from_project' event on a given issue or pull request.
	IssueTimelineItemsItemTypeRemovedFromProjectEvent IssueTimelineItemsItemType = "REMOVED_FROM_PROJECT_EVENT"
	// Represents a 'renamed' event on a given issue or pull request
	IssueTimelineItemsItemTypeRenamedTitleEvent IssueTimelineItemsItemType = "RENAMED_TITLE_EVENT"
	// Represents a 'reopened' event on any `Closable`.
	IssueTimelineItemsItemTypeReopenedEvent IssueTimelineItemsItemType = "REOPENED_EVENT"
	// Represents a 'subscribed' event on a given `Subscribable`.
	IssueTimelineItemsItemTypeSubscribedEvent IssueTimelineItemsItemType = "SUBSCRIBED_EVENT"
	// Represents a 'transferred' event on a given issue or pull request.
	IssueTimelineItemsItemTypeTransferredEvent IssueTimelineItemsItemType = "TRANSFERRED_EVENT"
	// Represents an 'unassigned' event on any assignable object.
	IssueTimelineItemsItemTypeUnassignedEvent IssueTimelineItemsItemType = "UNASSIGNED_EVENT"
	// Represents an 'unlabeled' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnlabeledEvent IssueTimelineItemsItemType = "UNLABELED_EVENT"
	// Represents an 'unlocked' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnlockedEvent IssueTimelineItemsItemType = "UNLOCKED_EVENT"
	// Represents a 'user_blocked' event on a given user.
	IssueTimelineItemsItemTypeUserBlockedEvent IssueTimelineItemsItemType = "USER_BLOCKED_EVENT"
	// Represents an 'unmarked_as_duplicate' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnmarkedAsDuplicateEvent IssueTimelineItemsItemType = "UNMARKED_AS_DUPLICATE_EVENT"
	// Represents an 'unpinned' event on a given issue or pull request.
	IssueTimelineItemsItemTypeUnpinnedEvent IssueTimelineItemsItemType = "UNPINNED_EVENT"
	// Represents an 'unsubscribed' event on a given `Subscribable`.
	IssueTimelineItemsItemTypeUnsubscribedEvent IssueTimelineItemsItemType = "UNSUBSCRIBED_EVENT"
)

var AllIssueTimelineItemsItemType = []IssueTimelineItemsItemType{
	IssueTimelineItemsItemTypeIssueComment,
	IssueTimelineItemsItemTypeCrossReferencedEvent,
	IssueTimelineItemsItemTypeAddedToProjectEvent,
	IssueTimelineItemsItemTypeAssignedEvent,
	IssueTimelineItemsItemTypeClosedEvent,
	IssueTimelineItemsItemTypeCommentDeletedEvent,
	IssueTimelineItemsItemTypeConnectedEvent,
	IssueTimelineItemsItemTypeConvertedNoteToIssueEvent,
	IssueTimelineItemsItemTypeConvertedToDiscussionEvent,
	IssueTimelineItemsItemTypeDemilestonedEvent,
	IssueTimelineItemsItemTypeDisconnectedEvent,
	IssueTimelineItemsItemTypeLabeledEvent,
	IssueTimelineItemsItemTypeLockedEvent,
	IssueTimelineItemsItemTypeMarkedAsDuplicateEvent,
	IssueTimelineItemsItemTypeMentionedEvent,
	IssueTimelineItemsItemTypeMilestonedEvent,
	IssueTimelineItemsItemTypeMovedColumnsInProjectEvent,
	IssueTimelineItemsItemTypePinnedEvent,
	IssueTimelineItemsItemTypeReferencedEvent,
	IssueTimelineItemsItemTypeRemovedFromProjectEvent,
	IssueTimelineItemsItemTypeRenamedTitleEvent,
	IssueTimelineItemsItemTypeReopenedEvent,
	IssueTimelineItemsItemTypeSubscribedEvent,
	IssueTimelineItemsItemTypeTransferredEvent,
	IssueTimelineItemsItemTypeUnassignedEvent,
	IssueTimelineItemsItemTypeUnlabeledEvent,
	IssueTimelineItemsItemTypeUnlockedEvent,
	IssueTimelineItemsItemTypeUserBlockedEvent,
	IssueTimelineItemsItemTypeUnmarkedAsDuplicateEvent,
	IssueTimelineItemsItemTypeUnpinnedEvent,
	IssueTimelineItemsItemTypeUnsubscribedEvent,
}

func (e IssueTimelineItemsItemType) IsValid() bool {
	switch e {
	case IssueTimelineItemsItemTypeIssueComment, IssueTimelineItemsItemTypeCrossReferencedEvent, IssueTimelineItemsItemTypeAddedToProjectEvent, IssueTimelineItemsItemTypeAssignedEvent, IssueTimelineItemsItemTypeClosedEvent, IssueTimelineItemsItemTypeCommentDeletedEvent, IssueTimelineItemsItemTypeConnectedEvent, IssueTimelineItemsItemTypeConvertedNoteToIssueEvent, IssueTimelineItemsItemTypeConvertedToDiscussionEvent, IssueTimelineItemsItemTypeDemilestonedEvent, IssueTimelineItemsItemTypeDisconnectedEvent, IssueTimelineItemsItemTypeLabeledEvent, IssueTimelineItemsItemTypeLockedEvent, IssueTimelineItemsItemTypeMarkedAsDuplicateEvent, IssueTimelineItemsItemTypeMentionedEvent, IssueTimelineItemsItemTypeMilestonedEvent, IssueTimelineItemsItemTypeMovedColumnsInProjectEvent, IssueTimelineItemsItemTypePinnedEvent, IssueTimelineItemsItemTypeReferencedEvent, IssueTimelineItemsItemTypeRemovedFromProjectEvent, IssueTimelineItemsItemTypeRenamedTitleEvent, IssueTimelineItemsItemTypeReopenedEvent, IssueTimelineItemsItemTypeSubscribedEvent, IssueTimelineItemsItemTypeTransferredEvent, IssueTimelineItemsItemTypeUnassignedEvent, IssueTimelineItemsItemTypeUnlabeledEvent, IssueTimelineItemsItemTypeUnlockedEvent, IssueTimelineItemsItemTypeUserBlockedEvent, IssueTimelineItemsItemTypeUnmarkedAsDuplicateEvent, IssueTimelineItemsItemTypeUnpinnedEvent, IssueTimelineItemsItemTypeUnsubscribedEvent:
		return true
	}
	return false
}

func (e IssueTimelineItemsItemType) String() string {
	return string(e)
}

func (e *IssueTimelineItemsItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueTimelineItemsItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueTimelineItemsItemType", str)
	}
	return nil
}

func (e IssueTimelineItemsItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which label connections can be ordered.
type LabelOrderField string

const (
	// Order labels by name
	LabelOrderFieldName LabelOrderField = "NAME"
	// Order labels by creation time
	LabelOrderFieldCreatedAt LabelOrderField = "CREATED_AT"
)

var AllLabelOrderField = []LabelOrderField{
	LabelOrderFieldName,
	LabelOrderFieldCreatedAt,
}

func (e LabelOrderField) IsValid() bool {
	switch e {
	case LabelOrderFieldName, LabelOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e LabelOrderField) String() string {
	return string(e)
}

func (e *LabelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelOrderField", str)
	}
	return nil
}

func (e LabelOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which language connections can be ordered.
type LanguageOrderField string

const (
	// Order languages by the size of all files containing the language
	LanguageOrderFieldSize LanguageOrderField = "SIZE"
)

var AllLanguageOrderField = []LanguageOrderField{
	LanguageOrderFieldSize,
}

func (e LanguageOrderField) IsValid() bool {
	switch e {
	case LanguageOrderFieldSize:
		return true
	}
	return false
}

func (e LanguageOrderField) String() string {
	return string(e)
}

func (e *LanguageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LanguageOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LanguageOrderField", str)
	}
	return nil
}

func (e LanguageOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons that an issue or pull request was locked.
type LockReason string

const (
	// The issue or pull request was locked because the conversation was off-topic.
	LockReasonOffTopic LockReason = "OFF_TOPIC"
	// The issue or pull request was locked because the conversation was too heated.
	LockReasonTooHeated LockReason = "TOO_HEATED"
	// The issue or pull request was locked because the conversation was resolved.
	LockReasonResolved LockReason = "RESOLVED"
	// The issue or pull request was locked because the conversation was spam.
	LockReasonSpam LockReason = "SPAM"
)

var AllLockReason = []LockReason{
	LockReasonOffTopic,
	LockReasonTooHeated,
	LockReasonResolved,
	LockReasonSpam,
}

func (e LockReason) IsValid() bool {
	switch e {
	case LockReasonOffTopic, LockReasonTooHeated, LockReasonResolved, LockReasonSpam:
		return true
	}
	return false
}

func (e LockReason) String() string {
	return string(e)
}

func (e *LockReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LockReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LockReason", str)
	}
	return nil
}

func (e LockReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which mannequins can be ordered.
type MannequinOrderField string

const (
	// Order mannequins alphabetically by their source login.
	MannequinOrderFieldLogin MannequinOrderField = "LOGIN"
	// Order mannequins why when they were created.
	MannequinOrderFieldCreatedAt MannequinOrderField = "CREATED_AT"
)

var AllMannequinOrderField = []MannequinOrderField{
	MannequinOrderFieldLogin,
	MannequinOrderFieldCreatedAt,
}

func (e MannequinOrderField) IsValid() bool {
	switch e {
	case MannequinOrderFieldLogin, MannequinOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e MannequinOrderField) String() string {
	return string(e)
}

func (e *MannequinOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MannequinOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MannequinOrderField", str)
	}
	return nil
}

func (e MannequinOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible default commit messages for merges.
type MergeCommitMessage string

const (
	// Default to the pull request's title.
	MergeCommitMessagePrTitle MergeCommitMessage = "PR_TITLE"
	// Default to the pull request's body.
	MergeCommitMessagePrBody MergeCommitMessage = "PR_BODY"
	// Default to a blank commit message.
	MergeCommitMessageBlank MergeCommitMessage = "BLANK"
)

var AllMergeCommitMessage = []MergeCommitMessage{
	MergeCommitMessagePrTitle,
	MergeCommitMessagePrBody,
	MergeCommitMessageBlank,
}

func (e MergeCommitMessage) IsValid() bool {
	switch e {
	case MergeCommitMessagePrTitle, MergeCommitMessagePrBody, MergeCommitMessageBlank:
		return true
	}
	return false
}

func (e MergeCommitMessage) String() string {
	return string(e)
}

func (e *MergeCommitMessage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeCommitMessage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeCommitMessage", str)
	}
	return nil
}

func (e MergeCommitMessage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible default commit titles for merges.
type MergeCommitTitle string

const (
	// Default to the pull request's title.
	MergeCommitTitlePrTitle MergeCommitTitle = "PR_TITLE"
	// Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
	MergeCommitTitleMergeMessage MergeCommitTitle = "MERGE_MESSAGE"
)

var AllMergeCommitTitle = []MergeCommitTitle{
	MergeCommitTitlePrTitle,
	MergeCommitTitleMergeMessage,
}

func (e MergeCommitTitle) IsValid() bool {
	switch e {
	case MergeCommitTitlePrTitle, MergeCommitTitleMergeMessage:
		return true
	}
	return false
}

func (e MergeCommitTitle) String() string {
	return string(e)
}

func (e *MergeCommitTitle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeCommitTitle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeCommitTitle", str)
	}
	return nil
}

func (e MergeCommitTitle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a merge queue entry.
type MergeQueueEntryState string

const (
	// The entry is currently queued.
	MergeQueueEntryStateQueued MergeQueueEntryState = "QUEUED"
	// The entry is currently waiting for checks to pass.
	MergeQueueEntryStateAwaitingChecks MergeQueueEntryState = "AWAITING_CHECKS"
	// The entry is currently mergeable.
	MergeQueueEntryStateMergeable MergeQueueEntryState = "MERGEABLE"
	// The entry is currently unmergeable.
	MergeQueueEntryStateUnmergeable MergeQueueEntryState = "UNMERGEABLE"
	// The entry is currently locked.
	MergeQueueEntryStateLocked MergeQueueEntryState = "LOCKED"
)

var AllMergeQueueEntryState = []MergeQueueEntryState{
	MergeQueueEntryStateQueued,
	MergeQueueEntryStateAwaitingChecks,
	MergeQueueEntryStateMergeable,
	MergeQueueEntryStateUnmergeable,
	MergeQueueEntryStateLocked,
}

func (e MergeQueueEntryState) IsValid() bool {
	switch e {
	case MergeQueueEntryStateQueued, MergeQueueEntryStateAwaitingChecks, MergeQueueEntryStateMergeable, MergeQueueEntryStateUnmergeable, MergeQueueEntryStateLocked:
		return true
	}
	return false
}

func (e MergeQueueEntryState) String() string {
	return string(e)
}

func (e *MergeQueueEntryState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeQueueEntryState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeQueueEntryState", str)
	}
	return nil
}

func (e MergeQueueEntryState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.
type MergeQueueGroupingStrategy string

const (
	// The merge commit created by merge queue for each PR in the group must pass all required checks to merge
	MergeQueueGroupingStrategyAllgreen MergeQueueGroupingStrategy = "ALLGREEN"
	// Only the commit at the head of the merge group must pass its required checks to merge.
	MergeQueueGroupingStrategyHeadgreen MergeQueueGroupingStrategy = "HEADGREEN"
)

var AllMergeQueueGroupingStrategy = []MergeQueueGroupingStrategy{
	MergeQueueGroupingStrategyAllgreen,
	MergeQueueGroupingStrategyHeadgreen,
}

func (e MergeQueueGroupingStrategy) IsValid() bool {
	switch e {
	case MergeQueueGroupingStrategyAllgreen, MergeQueueGroupingStrategyHeadgreen:
		return true
	}
	return false
}

func (e MergeQueueGroupingStrategy) String() string {
	return string(e)
}

func (e *MergeQueueGroupingStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeQueueGroupingStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeQueueGroupingStrategy", str)
	}
	return nil
}

func (e MergeQueueGroupingStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Method to use when merging changes from queued pull requests.
type MergeQueueMergeMethod string

const (
	// Merge commit
	MergeQueueMergeMethodMerge MergeQueueMergeMethod = "MERGE"
	// Squash and merge
	MergeQueueMergeMethodSquash MergeQueueMergeMethod = "SQUASH"
	// Rebase and merge
	MergeQueueMergeMethodRebase MergeQueueMergeMethod = "REBASE"
)

var AllMergeQueueMergeMethod = []MergeQueueMergeMethod{
	MergeQueueMergeMethodMerge,
	MergeQueueMergeMethodSquash,
	MergeQueueMergeMethodRebase,
}

func (e MergeQueueMergeMethod) IsValid() bool {
	switch e {
	case MergeQueueMergeMethodMerge, MergeQueueMergeMethodSquash, MergeQueueMergeMethodRebase:
		return true
	}
	return false
}

func (e MergeQueueMergeMethod) String() string {
	return string(e)
}

func (e *MergeQueueMergeMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeQueueMergeMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeQueueMergeMethod", str)
	}
	return nil
}

func (e MergeQueueMergeMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible merging strategies for a merge queue.
type MergeQueueMergingStrategy string

const (
	// Entries only allowed to merge if they are passing.
	MergeQueueMergingStrategyAllgreen MergeQueueMergingStrategy = "ALLGREEN"
	// Failing Entires are allowed to merge if they are with a passing entry.
	MergeQueueMergingStrategyHeadgreen MergeQueueMergingStrategy = "HEADGREEN"
)

var AllMergeQueueMergingStrategy = []MergeQueueMergingStrategy{
	MergeQueueMergingStrategyAllgreen,
	MergeQueueMergingStrategyHeadgreen,
}

func (e MergeQueueMergingStrategy) IsValid() bool {
	switch e {
	case MergeQueueMergingStrategyAllgreen, MergeQueueMergingStrategyHeadgreen:
		return true
	}
	return false
}

func (e MergeQueueMergingStrategy) String() string {
	return string(e)
}

func (e *MergeQueueMergingStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeQueueMergingStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeQueueMergingStrategy", str)
	}
	return nil
}

func (e MergeQueueMergingStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Detailed status information about a pull request merge.
type MergeStateStatus string

const (
	// The merge commit cannot be cleanly created.
	MergeStateStatusDirty MergeStateStatus = "DIRTY"
	// The state cannot currently be determined.
	MergeStateStatusUnknown MergeStateStatus = "UNKNOWN"
	// The merge is blocked.
	MergeStateStatusBlocked MergeStateStatus = "BLOCKED"
	// The head ref is out of date.
	MergeStateStatusBehind MergeStateStatus = "BEHIND"
	// The merge is blocked due to the pull request being a draft.
	MergeStateStatusDraft MergeStateStatus = "DRAFT"
	// Mergeable with non-passing commit status.
	MergeStateStatusUnstable MergeStateStatus = "UNSTABLE"
	// Mergeable with passing commit status and pre-receive hooks.
	MergeStateStatusHasHooks MergeStateStatus = "HAS_HOOKS"
	// Mergeable and passing commit status.
	MergeStateStatusClean MergeStateStatus = "CLEAN"
)

var AllMergeStateStatus = []MergeStateStatus{
	MergeStateStatusDirty,
	MergeStateStatusUnknown,
	MergeStateStatusBlocked,
	MergeStateStatusBehind,
	MergeStateStatusDraft,
	MergeStateStatusUnstable,
	MergeStateStatusHasHooks,
	MergeStateStatusClean,
}

func (e MergeStateStatus) IsValid() bool {
	switch e {
	case MergeStateStatusDirty, MergeStateStatusUnknown, MergeStateStatusBlocked, MergeStateStatusBehind, MergeStateStatusDraft, MergeStateStatusUnstable, MergeStateStatusHasHooks, MergeStateStatusClean:
		return true
	}
	return false
}

func (e MergeStateStatus) String() string {
	return string(e)
}

func (e *MergeStateStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeStateStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeStateStatus", str)
	}
	return nil
}

func (e MergeStateStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether or not a PullRequest can be merged.
type MergeableState string

const (
	// The pull request can be merged.
	MergeableStateMergeable MergeableState = "MERGEABLE"
	// The pull request cannot be merged due to merge conflicts.
	MergeableStateConflicting MergeableState = "CONFLICTING"
	// The mergeability of the pull request is still being calculated.
	MergeableStateUnknown MergeableState = "UNKNOWN"
)

var AllMergeableState = []MergeableState{
	MergeableStateMergeable,
	MergeableStateConflicting,
	MergeableStateUnknown,
}

func (e MergeableState) IsValid() bool {
	switch e {
	case MergeableStateMergeable, MergeableStateConflicting, MergeableStateUnknown:
		return true
	}
	return false
}

func (e MergeableState) String() string {
	return string(e)
}

func (e *MergeableState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MergeableState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MergeableState", str)
	}
	return nil
}

func (e MergeableState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different GitHub Enterprise Importer (GEI) migration sources.
type MigrationSourceType string

const (
	// An Azure DevOps migration source.
	MigrationSourceTypeAzureDevops MigrationSourceType = "AZURE_DEVOPS"
	// A Bitbucket Server migration source.
	MigrationSourceTypeBitbucketServer MigrationSourceType = "BITBUCKET_SERVER"
	// A GitHub Migration API source.
	MigrationSourceTypeGithubArchive MigrationSourceType = "GITHUB_ARCHIVE"
)

var AllMigrationSourceType = []MigrationSourceType{
	MigrationSourceTypeAzureDevops,
	MigrationSourceTypeBitbucketServer,
	MigrationSourceTypeGithubArchive,
}

func (e MigrationSourceType) IsValid() bool {
	switch e {
	case MigrationSourceTypeAzureDevops, MigrationSourceTypeBitbucketServer, MigrationSourceTypeGithubArchive:
		return true
	}
	return false
}

func (e MigrationSourceType) String() string {
	return string(e)
}

func (e *MigrationSourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MigrationSourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MigrationSourceType", str)
	}
	return nil
}

func (e MigrationSourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The GitHub Enterprise Importer (GEI) migration state.
type MigrationState string

const (
	// The migration has not started.
	MigrationStateNotStarted MigrationState = "NOT_STARTED"
	// The migration has been queued.
	MigrationStateQueued MigrationState = "QUEUED"
	// The migration is in progress.
	MigrationStateInProgress MigrationState = "IN_PROGRESS"
	// The migration has succeeded.
	MigrationStateSucceeded MigrationState = "SUCCEEDED"
	// The migration has failed.
	MigrationStateFailed MigrationState = "FAILED"
	// The migration needs to have its credentials validated.
	MigrationStatePendingValidation MigrationState = "PENDING_VALIDATION"
	// The migration has invalid credentials.
	MigrationStateFailedValidation MigrationState = "FAILED_VALIDATION"
)

var AllMigrationState = []MigrationState{
	MigrationStateNotStarted,
	MigrationStateQueued,
	MigrationStateInProgress,
	MigrationStateSucceeded,
	MigrationStateFailed,
	MigrationStatePendingValidation,
	MigrationStateFailedValidation,
}

func (e MigrationState) IsValid() bool {
	switch e {
	case MigrationStateNotStarted, MigrationStateQueued, MigrationStateInProgress, MigrationStateSucceeded, MigrationStateFailed, MigrationStatePendingValidation, MigrationStateFailedValidation:
		return true
	}
	return false
}

func (e MigrationState) String() string {
	return string(e)
}

func (e *MigrationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MigrationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MigrationState", str)
	}
	return nil
}

func (e MigrationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which milestone connections can be ordered.
type MilestoneOrderField string

const (
	// Order milestones by when they are due.
	MilestoneOrderFieldDueDate MilestoneOrderField = "DUE_DATE"
	// Order milestones by when they were created.
	MilestoneOrderFieldCreatedAt MilestoneOrderField = "CREATED_AT"
	// Order milestones by when they were last updated.
	MilestoneOrderFieldUpdatedAt MilestoneOrderField = "UPDATED_AT"
	// Order milestones by their number.
	MilestoneOrderFieldNumber MilestoneOrderField = "NUMBER"
)

var AllMilestoneOrderField = []MilestoneOrderField{
	MilestoneOrderFieldDueDate,
	MilestoneOrderFieldCreatedAt,
	MilestoneOrderFieldUpdatedAt,
	MilestoneOrderFieldNumber,
}

func (e MilestoneOrderField) IsValid() bool {
	switch e {
	case MilestoneOrderFieldDueDate, MilestoneOrderFieldCreatedAt, MilestoneOrderFieldUpdatedAt, MilestoneOrderFieldNumber:
		return true
	}
	return false
}

func (e MilestoneOrderField) String() string {
	return string(e)
}

func (e *MilestoneOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MilestoneOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MilestoneOrderField", str)
	}
	return nil
}

func (e MilestoneOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a milestone.
type MilestoneState string

const (
	// A milestone that is still open.
	MilestoneStateOpen MilestoneState = "OPEN"
	// A milestone that has been closed.
	MilestoneStateClosed MilestoneState = "CLOSED"
)

var AllMilestoneState = []MilestoneState{
	MilestoneStateOpen,
	MilestoneStateClosed,
}

func (e MilestoneState) IsValid() bool {
	switch e {
	case MilestoneStateOpen, MilestoneStateClosed:
		return true
	}
	return false
}

func (e MilestoneState) String() string {
	return string(e)
}

func (e *MilestoneState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MilestoneState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MilestoneState", str)
	}
	return nil
}

func (e MilestoneState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the notification restriction setting.
type NotificationRestrictionSettingValue string

const (
	// The setting is enabled for the owner.
	NotificationRestrictionSettingValueEnabled NotificationRestrictionSettingValue = "ENABLED"
	// The setting is disabled for the owner.
	NotificationRestrictionSettingValueDisabled NotificationRestrictionSettingValue = "DISABLED"
)

var AllNotificationRestrictionSettingValue = []NotificationRestrictionSettingValue{
	NotificationRestrictionSettingValueEnabled,
	NotificationRestrictionSettingValueDisabled,
}

func (e NotificationRestrictionSettingValue) IsValid() bool {
	switch e {
	case NotificationRestrictionSettingValueEnabled, NotificationRestrictionSettingValueDisabled:
		return true
	}
	return false
}

func (e NotificationRestrictionSettingValue) String() string {
	return string(e)
}

func (e *NotificationRestrictionSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationRestrictionSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationRestrictionSettingValue", str)
	}
	return nil
}

func (e NotificationRestrictionSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The OIDC identity provider type
type OIDCProviderType string

const (
	// Azure Active Directory
	OIDCProviderTypeAad OIDCProviderType = "AAD"
)

var AllOIDCProviderType = []OIDCProviderType{
	OIDCProviderTypeAad,
}

func (e OIDCProviderType) IsValid() bool {
	switch e {
	case OIDCProviderTypeAad:
		return true
	}
	return false
}

func (e OIDCProviderType) String() string {
	return string(e)
}

func (e *OIDCProviderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OIDCProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OIDCProviderType", str)
	}
	return nil
}

func (e OIDCProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The state of an OAuth application when it was created.
type OauthApplicationCreateAuditEntryState string

const (
	// The OAuth application was active and allowed to have OAuth Accesses.
	OauthApplicationCreateAuditEntryStateActive OauthApplicationCreateAuditEntryState = "ACTIVE"
	// The OAuth application was suspended from generating OAuth Accesses due to abuse or security concerns.
	OauthApplicationCreateAuditEntryStateSuspended OauthApplicationCreateAuditEntryState = "SUSPENDED"
	// The OAuth application was in the process of being deleted.
	OauthApplicationCreateAuditEntryStatePendingDeletion OauthApplicationCreateAuditEntryState = "PENDING_DELETION"
)

var AllOauthApplicationCreateAuditEntryState = []OauthApplicationCreateAuditEntryState{
	OauthApplicationCreateAuditEntryStateActive,
	OauthApplicationCreateAuditEntryStateSuspended,
	OauthApplicationCreateAuditEntryStatePendingDeletion,
}

func (e OauthApplicationCreateAuditEntryState) IsValid() bool {
	switch e {
	case OauthApplicationCreateAuditEntryStateActive, OauthApplicationCreateAuditEntryStateSuspended, OauthApplicationCreateAuditEntryStatePendingDeletion:
		return true
	}
	return false
}

func (e OauthApplicationCreateAuditEntryState) String() string {
	return string(e)
}

func (e *OauthApplicationCreateAuditEntryState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OauthApplicationCreateAuditEntryState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OauthApplicationCreateAuditEntryState", str)
	}
	return nil
}

func (e OauthApplicationCreateAuditEntryState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The corresponding operation type for the action
type OperationType string

const (
	// An existing resource was accessed
	OperationTypeAccess OperationType = "ACCESS"
	// A resource performed an authentication event
	OperationTypeAuthentication OperationType = "AUTHENTICATION"
	// A new resource was created
	OperationTypeCreate OperationType = "CREATE"
	// An existing resource was modified
	OperationTypeModify OperationType = "MODIFY"
	// An existing resource was removed
	OperationTypeRemove OperationType = "REMOVE"
	// An existing resource was restored
	OperationTypeRestore OperationType = "RESTORE"
	// An existing resource was transferred between multiple resources
	OperationTypeTransfer OperationType = "TRANSFER"
)

var AllOperationType = []OperationType{
	OperationTypeAccess,
	OperationTypeAuthentication,
	OperationTypeCreate,
	OperationTypeModify,
	OperationTypeRemove,
	OperationTypeRestore,
	OperationTypeTransfer,
}

func (e OperationType) IsValid() bool {
	switch e {
	case OperationTypeAccess, OperationTypeAuthentication, OperationTypeCreate, OperationTypeModify, OperationTypeRemove, OperationTypeRestore, OperationTypeTransfer:
		return true
	}
	return false
}

func (e OperationType) String() string {
	return string(e)
}

func (e *OperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationType", str)
	}
	return nil
}

func (e OperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The permissions available to members on an Organization.
type OrgAddMemberAuditEntryPermission string

const (
	// Can read and clone repositories.
	OrgAddMemberAuditEntryPermissionRead OrgAddMemberAuditEntryPermission = "READ"
	// Can read, clone, push, and add collaborators to repositories.
	OrgAddMemberAuditEntryPermissionAdmin OrgAddMemberAuditEntryPermission = "ADMIN"
)

var AllOrgAddMemberAuditEntryPermission = []OrgAddMemberAuditEntryPermission{
	OrgAddMemberAuditEntryPermissionRead,
	OrgAddMemberAuditEntryPermissionAdmin,
}

func (e OrgAddMemberAuditEntryPermission) IsValid() bool {
	switch e {
	case OrgAddMemberAuditEntryPermissionRead, OrgAddMemberAuditEntryPermissionAdmin:
		return true
	}
	return false
}

func (e OrgAddMemberAuditEntryPermission) String() string {
	return string(e)
}

func (e *OrgAddMemberAuditEntryPermission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgAddMemberAuditEntryPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgAddMemberAuditEntryPermission", str)
	}
	return nil
}

func (e OrgAddMemberAuditEntryPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The billing plans available for organizations.
type OrgCreateAuditEntryBillingPlan string

const (
	// Free Plan
	OrgCreateAuditEntryBillingPlanFree OrgCreateAuditEntryBillingPlan = "FREE"
	// Team Plan
	OrgCreateAuditEntryBillingPlanBusiness OrgCreateAuditEntryBillingPlan = "BUSINESS"
	// Enterprise Cloud Plan
	OrgCreateAuditEntryBillingPlanBusinessPlus OrgCreateAuditEntryBillingPlan = "BUSINESS_PLUS"
	// Legacy Unlimited Plan
	OrgCreateAuditEntryBillingPlanUnlimited OrgCreateAuditEntryBillingPlan = "UNLIMITED"
	// Tiered Per Seat Plan
	OrgCreateAuditEntryBillingPlanTieredPerSeat OrgCreateAuditEntryBillingPlan = "TIERED_PER_SEAT"
)

var AllOrgCreateAuditEntryBillingPlan = []OrgCreateAuditEntryBillingPlan{
	OrgCreateAuditEntryBillingPlanFree,
	OrgCreateAuditEntryBillingPlanBusiness,
	OrgCreateAuditEntryBillingPlanBusinessPlus,
	OrgCreateAuditEntryBillingPlanUnlimited,
	OrgCreateAuditEntryBillingPlanTieredPerSeat,
}

func (e OrgCreateAuditEntryBillingPlan) IsValid() bool {
	switch e {
	case OrgCreateAuditEntryBillingPlanFree, OrgCreateAuditEntryBillingPlanBusiness, OrgCreateAuditEntryBillingPlanBusinessPlus, OrgCreateAuditEntryBillingPlanUnlimited, OrgCreateAuditEntryBillingPlanTieredPerSeat:
		return true
	}
	return false
}

func (e OrgCreateAuditEntryBillingPlan) String() string {
	return string(e)
}

func (e *OrgCreateAuditEntryBillingPlan) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgCreateAuditEntryBillingPlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgCreateAuditEntryBillingPlan", str)
	}
	return nil
}

func (e OrgCreateAuditEntryBillingPlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which enterprise owners can be ordered.
type OrgEnterpriseOwnerOrderField string

const (
	// Order enterprise owners by login.
	OrgEnterpriseOwnerOrderFieldLogin OrgEnterpriseOwnerOrderField = "LOGIN"
)

var AllOrgEnterpriseOwnerOrderField = []OrgEnterpriseOwnerOrderField{
	OrgEnterpriseOwnerOrderFieldLogin,
}

func (e OrgEnterpriseOwnerOrderField) IsValid() bool {
	switch e {
	case OrgEnterpriseOwnerOrderFieldLogin:
		return true
	}
	return false
}

func (e OrgEnterpriseOwnerOrderField) String() string {
	return string(e)
}

func (e *OrgEnterpriseOwnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgEnterpriseOwnerOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgEnterpriseOwnerOrderField", str)
	}
	return nil
}

func (e OrgEnterpriseOwnerOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason a billing manager was removed from an Organization.
type OrgRemoveBillingManagerAuditEntryReason string

const (
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveBillingManagerAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveBillingManagerAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
	// SAML external identity missing
	OrgRemoveBillingManagerAuditEntryReasonSamlExternalIDEntityMissing OrgRemoveBillingManagerAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
	// SAML SSO enforcement requires an external identity
	OrgRemoveBillingManagerAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity OrgRemoveBillingManagerAuditEntryReason = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY"
)

var AllOrgRemoveBillingManagerAuditEntryReason = []OrgRemoveBillingManagerAuditEntryReason{
	OrgRemoveBillingManagerAuditEntryReasonTwoFactorRequirementNonCompliance,
	OrgRemoveBillingManagerAuditEntryReasonSamlExternalIDEntityMissing,
	OrgRemoveBillingManagerAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity,
}

func (e OrgRemoveBillingManagerAuditEntryReason) IsValid() bool {
	switch e {
	case OrgRemoveBillingManagerAuditEntryReasonTwoFactorRequirementNonCompliance, OrgRemoveBillingManagerAuditEntryReasonSamlExternalIDEntityMissing, OrgRemoveBillingManagerAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity:
		return true
	}
	return false
}

func (e OrgRemoveBillingManagerAuditEntryReason) String() string {
	return string(e)
}

func (e *OrgRemoveBillingManagerAuditEntryReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgRemoveBillingManagerAuditEntryReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgRemoveBillingManagerAuditEntryReason", str)
	}
	return nil
}

func (e OrgRemoveBillingManagerAuditEntryReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of membership a user has with an Organization.
type OrgRemoveMemberAuditEntryMembershipType string

const (
	// A suspended member.
	OrgRemoveMemberAuditEntryMembershipTypeSuspended OrgRemoveMemberAuditEntryMembershipType = "SUSPENDED"
	// A direct member is a user that is a member of the Organization.
	OrgRemoveMemberAuditEntryMembershipTypeDirectMember OrgRemoveMemberAuditEntryMembershipType = "DIRECT_MEMBER"
	// Organization owners have full access and can change several settings, including the names of repositories that belong to the Organization and Owners team membership. In addition, organization owners can delete the organization and all of its repositories.
	OrgRemoveMemberAuditEntryMembershipTypeAdmin OrgRemoveMemberAuditEntryMembershipType = "ADMIN"
	// A billing manager is a user who manages the billing settings for the Organization, such as updating payment information.
	OrgRemoveMemberAuditEntryMembershipTypeBillingManager OrgRemoveMemberAuditEntryMembershipType = "BILLING_MANAGER"
	// An unaffiliated collaborator is a person who is not a member of the Organization and does not have access to any repositories in the Organization.
	OrgRemoveMemberAuditEntryMembershipTypeUnaffiliated OrgRemoveMemberAuditEntryMembershipType = "UNAFFILIATED"
	// An outside collaborator is a person who isn't explicitly a member of the Organization, but who has Read, Write, or Admin permissions to one or more repositories in the organization.
	OrgRemoveMemberAuditEntryMembershipTypeOutsideCollaborator OrgRemoveMemberAuditEntryMembershipType = "OUTSIDE_COLLABORATOR"
)

var AllOrgRemoveMemberAuditEntryMembershipType = []OrgRemoveMemberAuditEntryMembershipType{
	OrgRemoveMemberAuditEntryMembershipTypeSuspended,
	OrgRemoveMemberAuditEntryMembershipTypeDirectMember,
	OrgRemoveMemberAuditEntryMembershipTypeAdmin,
	OrgRemoveMemberAuditEntryMembershipTypeBillingManager,
	OrgRemoveMemberAuditEntryMembershipTypeUnaffiliated,
	OrgRemoveMemberAuditEntryMembershipTypeOutsideCollaborator,
}

func (e OrgRemoveMemberAuditEntryMembershipType) IsValid() bool {
	switch e {
	case OrgRemoveMemberAuditEntryMembershipTypeSuspended, OrgRemoveMemberAuditEntryMembershipTypeDirectMember, OrgRemoveMemberAuditEntryMembershipTypeAdmin, OrgRemoveMemberAuditEntryMembershipTypeBillingManager, OrgRemoveMemberAuditEntryMembershipTypeUnaffiliated, OrgRemoveMemberAuditEntryMembershipTypeOutsideCollaborator:
		return true
	}
	return false
}

func (e OrgRemoveMemberAuditEntryMembershipType) String() string {
	return string(e)
}

func (e *OrgRemoveMemberAuditEntryMembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgRemoveMemberAuditEntryMembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgRemoveMemberAuditEntryMembershipType", str)
	}
	return nil
}

func (e OrgRemoveMemberAuditEntryMembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason a member was removed from an Organization.
type OrgRemoveMemberAuditEntryReason string

const (
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveMemberAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveMemberAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
	// SAML external identity missing
	OrgRemoveMemberAuditEntryReasonSamlExternalIDEntityMissing OrgRemoveMemberAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
	// SAML SSO enforcement requires an external identity
	OrgRemoveMemberAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity OrgRemoveMemberAuditEntryReason = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY"
	// User account has been deleted
	OrgRemoveMemberAuditEntryReasonUserAccountDeleted OrgRemoveMemberAuditEntryReason = "USER_ACCOUNT_DELETED"
	// User was removed from organization during account recovery
	OrgRemoveMemberAuditEntryReasonTwoFactorAccountRecovery OrgRemoveMemberAuditEntryReason = "TWO_FACTOR_ACCOUNT_RECOVERY"
)

var AllOrgRemoveMemberAuditEntryReason = []OrgRemoveMemberAuditEntryReason{
	OrgRemoveMemberAuditEntryReasonTwoFactorRequirementNonCompliance,
	OrgRemoveMemberAuditEntryReasonSamlExternalIDEntityMissing,
	OrgRemoveMemberAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity,
	OrgRemoveMemberAuditEntryReasonUserAccountDeleted,
	OrgRemoveMemberAuditEntryReasonTwoFactorAccountRecovery,
}

func (e OrgRemoveMemberAuditEntryReason) IsValid() bool {
	switch e {
	case OrgRemoveMemberAuditEntryReasonTwoFactorRequirementNonCompliance, OrgRemoveMemberAuditEntryReasonSamlExternalIDEntityMissing, OrgRemoveMemberAuditEntryReasonSamlSsoEnforcementRequiresExternalIDEntity, OrgRemoveMemberAuditEntryReasonUserAccountDeleted, OrgRemoveMemberAuditEntryReasonTwoFactorAccountRecovery:
		return true
	}
	return false
}

func (e OrgRemoveMemberAuditEntryReason) String() string {
	return string(e)
}

func (e *OrgRemoveMemberAuditEntryReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgRemoveMemberAuditEntryReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgRemoveMemberAuditEntryReason", str)
	}
	return nil
}

func (e OrgRemoveMemberAuditEntryReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of membership a user has with an Organization.
type OrgRemoveOutsideCollaboratorAuditEntryMembershipType string

const (
	// An outside collaborator is a person who isn't explicitly a member of the Organization, but who has Read, Write, or Admin permissions to one or more repositories in the organization.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeOutsideCollaborator OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "OUTSIDE_COLLABORATOR"
	// An unaffiliated collaborator is a person who is not a member of the Organization and does not have access to any repositories in the organization.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeUnaffiliated OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "UNAFFILIATED"
	// A billing manager is a user who manages the billing settings for the Organization, such as updating payment information.
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeBillingManager OrgRemoveOutsideCollaboratorAuditEntryMembershipType = "BILLING_MANAGER"
)

var AllOrgRemoveOutsideCollaboratorAuditEntryMembershipType = []OrgRemoveOutsideCollaboratorAuditEntryMembershipType{
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeOutsideCollaborator,
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeUnaffiliated,
	OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeBillingManager,
}

func (e OrgRemoveOutsideCollaboratorAuditEntryMembershipType) IsValid() bool {
	switch e {
	case OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeOutsideCollaborator, OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeUnaffiliated, OrgRemoveOutsideCollaboratorAuditEntryMembershipTypeBillingManager:
		return true
	}
	return false
}

func (e OrgRemoveOutsideCollaboratorAuditEntryMembershipType) String() string {
	return string(e)
}

func (e *OrgRemoveOutsideCollaboratorAuditEntryMembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgRemoveOutsideCollaboratorAuditEntryMembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgRemoveOutsideCollaboratorAuditEntryMembershipType", str)
	}
	return nil
}

func (e OrgRemoveOutsideCollaboratorAuditEntryMembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason an outside collaborator was removed from an Organization.
type OrgRemoveOutsideCollaboratorAuditEntryReason string

const (
	// The organization required 2FA of its billing managers and this user did not have 2FA enabled.
	OrgRemoveOutsideCollaboratorAuditEntryReasonTwoFactorRequirementNonCompliance OrgRemoveOutsideCollaboratorAuditEntryReason = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE"
	// SAML external identity missing
	OrgRemoveOutsideCollaboratorAuditEntryReasonSamlExternalIDEntityMissing OrgRemoveOutsideCollaboratorAuditEntryReason = "SAML_EXTERNAL_IDENTITY_MISSING"
)

var AllOrgRemoveOutsideCollaboratorAuditEntryReason = []OrgRemoveOutsideCollaboratorAuditEntryReason{
	OrgRemoveOutsideCollaboratorAuditEntryReasonTwoFactorRequirementNonCompliance,
	OrgRemoveOutsideCollaboratorAuditEntryReasonSamlExternalIDEntityMissing,
}

func (e OrgRemoveOutsideCollaboratorAuditEntryReason) IsValid() bool {
	switch e {
	case OrgRemoveOutsideCollaboratorAuditEntryReasonTwoFactorRequirementNonCompliance, OrgRemoveOutsideCollaboratorAuditEntryReasonSamlExternalIDEntityMissing:
		return true
	}
	return false
}

func (e OrgRemoveOutsideCollaboratorAuditEntryReason) String() string {
	return string(e)
}

func (e *OrgRemoveOutsideCollaboratorAuditEntryReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgRemoveOutsideCollaboratorAuditEntryReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgRemoveOutsideCollaboratorAuditEntryReason", str)
	}
	return nil
}

func (e OrgRemoveOutsideCollaboratorAuditEntryReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The default permission a repository can have in an Organization.
type OrgUpdateDefaultRepositoryPermissionAuditEntryPermission string

const (
	// Can read and clone repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionRead OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "READ"
	// Can read, clone and push to repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionWrite OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "WRITE"
	// Can read, clone, push, and add collaborators to repositories.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionAdmin OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "ADMIN"
	// No default permission value.
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionNone OrgUpdateDefaultRepositoryPermissionAuditEntryPermission = "NONE"
)

var AllOrgUpdateDefaultRepositoryPermissionAuditEntryPermission = []OrgUpdateDefaultRepositoryPermissionAuditEntryPermission{
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionRead,
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionWrite,
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionAdmin,
	OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionNone,
}

func (e OrgUpdateDefaultRepositoryPermissionAuditEntryPermission) IsValid() bool {
	switch e {
	case OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionRead, OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionWrite, OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionAdmin, OrgUpdateDefaultRepositoryPermissionAuditEntryPermissionNone:
		return true
	}
	return false
}

func (e OrgUpdateDefaultRepositoryPermissionAuditEntryPermission) String() string {
	return string(e)
}

func (e *OrgUpdateDefaultRepositoryPermissionAuditEntryPermission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgUpdateDefaultRepositoryPermissionAuditEntryPermission", str)
	}
	return nil
}

func (e OrgUpdateDefaultRepositoryPermissionAuditEntryPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The permissions available to members on an Organization.
type OrgUpdateMemberAuditEntryPermission string

const (
	// Can read and clone repositories.
	OrgUpdateMemberAuditEntryPermissionRead OrgUpdateMemberAuditEntryPermission = "READ"
	// Can read, clone, push, and add collaborators to repositories.
	OrgUpdateMemberAuditEntryPermissionAdmin OrgUpdateMemberAuditEntryPermission = "ADMIN"
)

var AllOrgUpdateMemberAuditEntryPermission = []OrgUpdateMemberAuditEntryPermission{
	OrgUpdateMemberAuditEntryPermissionRead,
	OrgUpdateMemberAuditEntryPermissionAdmin,
}

func (e OrgUpdateMemberAuditEntryPermission) IsValid() bool {
	switch e {
	case OrgUpdateMemberAuditEntryPermissionRead, OrgUpdateMemberAuditEntryPermissionAdmin:
		return true
	}
	return false
}

func (e OrgUpdateMemberAuditEntryPermission) String() string {
	return string(e)
}

func (e *OrgUpdateMemberAuditEntryPermission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgUpdateMemberAuditEntryPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgUpdateMemberAuditEntryPermission", str)
	}
	return nil
}

func (e OrgUpdateMemberAuditEntryPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The permissions available for repository creation on an Organization.
type OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility string

const (
	// All organization members are restricted from creating any repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityAll OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "ALL"
	// All organization members are restricted from creating public repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublic OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC"
	// All organization members are allowed to create any repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityNone OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "NONE"
	// All organization members are restricted from creating private repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivate OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PRIVATE"
	// All organization members are restricted from creating internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "INTERNAL"
	// All organization members are restricted from creating public or internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC_INTERNAL"
	// All organization members are restricted from creating private or internal repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivateInternal OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PRIVATE_INTERNAL"
	// All organization members are restricted from creating public or private repositories.
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicPrivate OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = "PUBLIC_PRIVATE"
)

var AllOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility = []OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility{
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityAll,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublic,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityNone,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivate,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityInternal,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicInternal,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivateInternal,
	OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicPrivate,
}

func (e OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility) IsValid() bool {
	switch e {
	case OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityAll, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublic, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityNone, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivate, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityInternal, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicInternal, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPrivateInternal, OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibilityPublicPrivate:
		return true
	}
	return false
}

func (e OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility) String() string {
	return string(e)
}

func (e *OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility", str)
	}
	return nil
}

func (e OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible organization invitation roles.
type OrganizationInvitationRole string

const (
	// The user is invited to be a direct member of the organization.
	OrganizationInvitationRoleDirectMember OrganizationInvitationRole = "DIRECT_MEMBER"
	// The user is invited to be an admin of the organization.
	OrganizationInvitationRoleAdmin OrganizationInvitationRole = "ADMIN"
	// The user is invited to be a billing manager of the organization.
	OrganizationInvitationRoleBillingManager OrganizationInvitationRole = "BILLING_MANAGER"
	// The user's previous role will be reinstated.
	OrganizationInvitationRoleReinstate OrganizationInvitationRole = "REINSTATE"
)

var AllOrganizationInvitationRole = []OrganizationInvitationRole{
	OrganizationInvitationRoleDirectMember,
	OrganizationInvitationRoleAdmin,
	OrganizationInvitationRoleBillingManager,
	OrganizationInvitationRoleReinstate,
}

func (e OrganizationInvitationRole) IsValid() bool {
	switch e {
	case OrganizationInvitationRoleDirectMember, OrganizationInvitationRoleAdmin, OrganizationInvitationRoleBillingManager, OrganizationInvitationRoleReinstate:
		return true
	}
	return false
}

func (e OrganizationInvitationRole) String() string {
	return string(e)
}

func (e *OrganizationInvitationRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationInvitationRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationInvitationRole", str)
	}
	return nil
}

func (e OrganizationInvitationRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible organization invitation sources.
type OrganizationInvitationSource string

const (
	// The invitation was sent before this feature was added
	OrganizationInvitationSourceUnknown OrganizationInvitationSource = "UNKNOWN"
	// The invitation was created from the web interface or from API
	OrganizationInvitationSourceMember OrganizationInvitationSource = "MEMBER"
	// The invitation was created from SCIM
	OrganizationInvitationSourceScim OrganizationInvitationSource = "SCIM"
)

var AllOrganizationInvitationSource = []OrganizationInvitationSource{
	OrganizationInvitationSourceUnknown,
	OrganizationInvitationSourceMember,
	OrganizationInvitationSourceScim,
}

func (e OrganizationInvitationSource) IsValid() bool {
	switch e {
	case OrganizationInvitationSourceUnknown, OrganizationInvitationSourceMember, OrganizationInvitationSourceScim:
		return true
	}
	return false
}

func (e OrganizationInvitationSource) String() string {
	return string(e)
}

func (e *OrganizationInvitationSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationInvitationSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationInvitationSource", str)
	}
	return nil
}

func (e OrganizationInvitationSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible organization invitation types.
type OrganizationInvitationType string

const (
	// The invitation was to an existing user.
	OrganizationInvitationTypeUser OrganizationInvitationType = "USER"
	// The invitation was to an email address.
	OrganizationInvitationTypeEmail OrganizationInvitationType = "EMAIL"
)

var AllOrganizationInvitationType = []OrganizationInvitationType{
	OrganizationInvitationTypeUser,
	OrganizationInvitationTypeEmail,
}

func (e OrganizationInvitationType) IsValid() bool {
	switch e {
	case OrganizationInvitationTypeUser, OrganizationInvitationTypeEmail:
		return true
	}
	return false
}

func (e OrganizationInvitationType) String() string {
	return string(e)
}

func (e *OrganizationInvitationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationInvitationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationInvitationType", str)
	}
	return nil
}

func (e OrganizationInvitationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible roles within an organization for its members.
type OrganizationMemberRole string

const (
	// The user is a member of the organization.
	OrganizationMemberRoleMember OrganizationMemberRole = "MEMBER"
	// The user is an administrator of the organization.
	OrganizationMemberRoleAdmin OrganizationMemberRole = "ADMIN"
)

var AllOrganizationMemberRole = []OrganizationMemberRole{
	OrganizationMemberRoleMember,
	OrganizationMemberRoleAdmin,
}

func (e OrganizationMemberRole) IsValid() bool {
	switch e {
	case OrganizationMemberRoleMember, OrganizationMemberRoleAdmin:
		return true
	}
	return false
}

func (e OrganizationMemberRole) String() string {
	return string(e)
}

func (e *OrganizationMemberRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMemberRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationMemberRole", str)
	}
	return nil
}

func (e OrganizationMemberRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible values for the members can create repositories setting on an organization.
type OrganizationMembersCanCreateRepositoriesSettingValue string

const (
	// Members will be able to create public and private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueAll OrganizationMembersCanCreateRepositoriesSettingValue = "ALL"
	// Members will be able to create only private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValuePrivate OrganizationMembersCanCreateRepositoriesSettingValue = "PRIVATE"
	// Members will be able to create only internal repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueInternal OrganizationMembersCanCreateRepositoriesSettingValue = "INTERNAL"
	// Members will not be able to create public or private repositories.
	OrganizationMembersCanCreateRepositoriesSettingValueDisabled OrganizationMembersCanCreateRepositoriesSettingValue = "DISABLED"
)

var AllOrganizationMembersCanCreateRepositoriesSettingValue = []OrganizationMembersCanCreateRepositoriesSettingValue{
	OrganizationMembersCanCreateRepositoriesSettingValueAll,
	OrganizationMembersCanCreateRepositoriesSettingValuePrivate,
	OrganizationMembersCanCreateRepositoriesSettingValueInternal,
	OrganizationMembersCanCreateRepositoriesSettingValueDisabled,
}

func (e OrganizationMembersCanCreateRepositoriesSettingValue) IsValid() bool {
	switch e {
	case OrganizationMembersCanCreateRepositoriesSettingValueAll, OrganizationMembersCanCreateRepositoriesSettingValuePrivate, OrganizationMembersCanCreateRepositoriesSettingValueInternal, OrganizationMembersCanCreateRepositoriesSettingValueDisabled:
		return true
	}
	return false
}

func (e OrganizationMembersCanCreateRepositoriesSettingValue) String() string {
	return string(e)
}

func (e *OrganizationMembersCanCreateRepositoriesSettingValue) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMembersCanCreateRepositoriesSettingValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationMembersCanCreateRepositoriesSettingValue", str)
	}
	return nil
}

func (e OrganizationMembersCanCreateRepositoriesSettingValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The Octoshift Organization migration state.
type OrganizationMigrationState string

const (
	// The Octoshift migration has not started.
	OrganizationMigrationStateNotStarted OrganizationMigrationState = "NOT_STARTED"
	// The Octoshift migration has been queued.
	OrganizationMigrationStateQueued OrganizationMigrationState = "QUEUED"
	// The Octoshift migration is in progress.
	OrganizationMigrationStateInProgress OrganizationMigrationState = "IN_PROGRESS"
	// The Octoshift migration is performing pre repository migrations.
	OrganizationMigrationStatePreRepoMigration OrganizationMigrationState = "PRE_REPO_MIGRATION"
	// The Octoshift org migration is performing repository migrations.
	OrganizationMigrationStateRepoMigration OrganizationMigrationState = "REPO_MIGRATION"
	// The Octoshift migration is performing post repository migrations.
	OrganizationMigrationStatePostRepoMigration OrganizationMigrationState = "POST_REPO_MIGRATION"
	// The Octoshift migration has succeeded.
	OrganizationMigrationStateSucceeded OrganizationMigrationState = "SUCCEEDED"
	// The Octoshift migration has failed.
	OrganizationMigrationStateFailed OrganizationMigrationState = "FAILED"
	// The Octoshift migration needs to have its credentials validated.
	OrganizationMigrationStatePendingValidation OrganizationMigrationState = "PENDING_VALIDATION"
	// The Octoshift migration has invalid credentials.
	OrganizationMigrationStateFailedValidation OrganizationMigrationState = "FAILED_VALIDATION"
)

var AllOrganizationMigrationState = []OrganizationMigrationState{
	OrganizationMigrationStateNotStarted,
	OrganizationMigrationStateQueued,
	OrganizationMigrationStateInProgress,
	OrganizationMigrationStatePreRepoMigration,
	OrganizationMigrationStateRepoMigration,
	OrganizationMigrationStatePostRepoMigration,
	OrganizationMigrationStateSucceeded,
	OrganizationMigrationStateFailed,
	OrganizationMigrationStatePendingValidation,
	OrganizationMigrationStateFailedValidation,
}

func (e OrganizationMigrationState) IsValid() bool {
	switch e {
	case OrganizationMigrationStateNotStarted, OrganizationMigrationStateQueued, OrganizationMigrationStateInProgress, OrganizationMigrationStatePreRepoMigration, OrganizationMigrationStateRepoMigration, OrganizationMigrationStatePostRepoMigration, OrganizationMigrationStateSucceeded, OrganizationMigrationStateFailed, OrganizationMigrationStatePendingValidation, OrganizationMigrationStateFailedValidation:
		return true
	}
	return false
}

func (e OrganizationMigrationState) String() string {
	return string(e)
}

func (e *OrganizationMigrationState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMigrationState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationMigrationState", str)
	}
	return nil
}

func (e OrganizationMigrationState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which organization connections can be ordered.
type OrganizationOrderField string

const (
	// Order organizations by creation time
	OrganizationOrderFieldCreatedAt OrganizationOrderField = "CREATED_AT"
	// Order organizations by login
	OrganizationOrderFieldLogin OrganizationOrderField = "LOGIN"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldCreatedAt,
	OrganizationOrderFieldLogin,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldCreatedAt, OrganizationOrderFieldLogin:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which package file connections can be ordered.
type PackageFileOrderField string

const (
	// Order package files by creation time
	PackageFileOrderFieldCreatedAt PackageFileOrderField = "CREATED_AT"
)

var AllPackageFileOrderField = []PackageFileOrderField{
	PackageFileOrderFieldCreatedAt,
}

func (e PackageFileOrderField) IsValid() bool {
	switch e {
	case PackageFileOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e PackageFileOrderField) String() string {
	return string(e)
}

func (e *PackageFileOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageFileOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageFileOrderField", str)
	}
	return nil
}

func (e PackageFileOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which package connections can be ordered.
type PackageOrderField string

const (
	// Order packages by creation time
	PackageOrderFieldCreatedAt PackageOrderField = "CREATED_AT"
)

var AllPackageOrderField = []PackageOrderField{
	PackageOrderFieldCreatedAt,
}

func (e PackageOrderField) IsValid() bool {
	switch e {
	case PackageOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e PackageOrderField) String() string {
	return string(e)
}

func (e *PackageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageOrderField", str)
	}
	return nil
}

func (e PackageOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types of a package.
type PackageType string

const (
	// An npm package.
	PackageTypeNpm PackageType = "NPM"
	// A rubygems package.
	PackageTypeRubygems PackageType = "RUBYGEMS"
	// A maven package.
	PackageTypeMaven PackageType = "MAVEN"
	// A docker image.
	PackageTypeDocker PackageType = "DOCKER"
	// A debian package.
	PackageTypeDebian PackageType = "DEBIAN"
	// A nuget package.
	PackageTypeNuget PackageType = "NUGET"
	// A python package.
	PackageTypePypi PackageType = "PYPI"
)

var AllPackageType = []PackageType{
	PackageTypeNpm,
	PackageTypeRubygems,
	PackageTypeMaven,
	PackageTypeDocker,
	PackageTypeDebian,
	PackageTypeNuget,
	PackageTypePypi,
}

func (e PackageType) IsValid() bool {
	switch e {
	case PackageTypeNpm, PackageTypeRubygems, PackageTypeMaven, PackageTypeDocker, PackageTypeDebian, PackageTypeNuget, PackageTypePypi:
		return true
	}
	return false
}

func (e PackageType) String() string {
	return string(e)
}

func (e *PackageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageType", str)
	}
	return nil
}

func (e PackageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which package version connections can be ordered.
type PackageVersionOrderField string

const (
	// Order package versions by creation time
	PackageVersionOrderFieldCreatedAt PackageVersionOrderField = "CREATED_AT"
)

var AllPackageVersionOrderField = []PackageVersionOrderField{
	PackageVersionOrderFieldCreatedAt,
}

func (e PackageVersionOrderField) IsValid() bool {
	switch e {
	case PackageVersionOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e PackageVersionOrderField) String() string {
	return string(e)
}

func (e *PackageVersionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageVersionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageVersionOrderField", str)
	}
	return nil
}

func (e PackageVersionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types of patch statuses.
type PatchStatus string

const (
	// The file was added. Git status 'A'.
	PatchStatusAdded PatchStatus = "ADDED"
	// The file was deleted. Git status 'D'.
	PatchStatusDeleted PatchStatus = "DELETED"
	// The file was renamed. Git status 'R'.
	PatchStatusRenamed PatchStatus = "RENAMED"
	// The file was copied. Git status 'C'.
	PatchStatusCopied PatchStatus = "COPIED"
	// The file's contents were changed. Git status 'M'.
	PatchStatusModified PatchStatus = "MODIFIED"
	// The file's type was changed. Git status 'T'.
	PatchStatusChanged PatchStatus = "CHANGED"
)

var AllPatchStatus = []PatchStatus{
	PatchStatusAdded,
	PatchStatusDeleted,
	PatchStatusRenamed,
	PatchStatusCopied,
	PatchStatusModified,
	PatchStatusChanged,
}

func (e PatchStatus) IsValid() bool {
	switch e {
	case PatchStatusAdded, PatchStatusDeleted, PatchStatusRenamed, PatchStatusCopied, PatchStatusModified, PatchStatusChanged:
		return true
	}
	return false
}

func (e PatchStatus) String() string {
	return string(e)
}

func (e *PatchStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PatchStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PatchStatus", str)
	}
	return nil
}

func (e PatchStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents items that can be pinned to a profile page or dashboard.
type PinnableItemType string

const (
	// A repository.
	PinnableItemTypeRepository PinnableItemType = "REPOSITORY"
	// A gist.
	PinnableItemTypeGist PinnableItemType = "GIST"
	// An issue.
	PinnableItemTypeIssue PinnableItemType = "ISSUE"
	// A project.
	PinnableItemTypeProject PinnableItemType = "PROJECT"
	// A pull request.
	PinnableItemTypePullRequest PinnableItemType = "PULL_REQUEST"
	// A user.
	PinnableItemTypeUser PinnableItemType = "USER"
	// An organization.
	PinnableItemTypeOrganization PinnableItemType = "ORGANIZATION"
	// A team.
	PinnableItemTypeTeam PinnableItemType = "TEAM"
)

var AllPinnableItemType = []PinnableItemType{
	PinnableItemTypeRepository,
	PinnableItemTypeGist,
	PinnableItemTypeIssue,
	PinnableItemTypeProject,
	PinnableItemTypePullRequest,
	PinnableItemTypeUser,
	PinnableItemTypeOrganization,
	PinnableItemTypeTeam,
}

func (e PinnableItemType) IsValid() bool {
	switch e {
	case PinnableItemTypeRepository, PinnableItemTypeGist, PinnableItemTypeIssue, PinnableItemTypeProject, PinnableItemTypePullRequest, PinnableItemTypeUser, PinnableItemTypeOrganization, PinnableItemTypeTeam:
		return true
	}
	return false
}

func (e PinnableItemType) String() string {
	return string(e)
}

func (e *PinnableItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PinnableItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PinnableItemType", str)
	}
	return nil
}

func (e PinnableItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Preconfigured gradients that may be used to style discussions pinned within a repository.
type PinnedDiscussionGradient string

const (
	// A gradient of red to orange
	PinnedDiscussionGradientRedOrange PinnedDiscussionGradient = "RED_ORANGE"
	// A gradient of blue to mint
	PinnedDiscussionGradientBlueMint PinnedDiscussionGradient = "BLUE_MINT"
	// A gradient of blue to purple
	PinnedDiscussionGradientBluePurple PinnedDiscussionGradient = "BLUE_PURPLE"
	// A gradient of pink to blue
	PinnedDiscussionGradientPinkBlue PinnedDiscussionGradient = "PINK_BLUE"
	// A gradient of purple to coral
	PinnedDiscussionGradientPurpleCoral PinnedDiscussionGradient = "PURPLE_CORAL"
)

var AllPinnedDiscussionGradient = []PinnedDiscussionGradient{
	PinnedDiscussionGradientRedOrange,
	PinnedDiscussionGradientBlueMint,
	PinnedDiscussionGradientBluePurple,
	PinnedDiscussionGradientPinkBlue,
	PinnedDiscussionGradientPurpleCoral,
}

func (e PinnedDiscussionGradient) IsValid() bool {
	switch e {
	case PinnedDiscussionGradientRedOrange, PinnedDiscussionGradientBlueMint, PinnedDiscussionGradientBluePurple, PinnedDiscussionGradientPinkBlue, PinnedDiscussionGradientPurpleCoral:
		return true
	}
	return false
}

func (e PinnedDiscussionGradient) String() string {
	return string(e)
}

func (e *PinnedDiscussionGradient) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PinnedDiscussionGradient(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PinnedDiscussionGradient", str)
	}
	return nil
}

func (e PinnedDiscussionGradient) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Preconfigured background patterns that may be used to style discussions pinned within a repository.
type PinnedDiscussionPattern string

const (
	// A solid dot pattern
	PinnedDiscussionPatternDotFill PinnedDiscussionPattern = "DOT_FILL"
	// A plus sign pattern
	PinnedDiscussionPatternPlus PinnedDiscussionPattern = "PLUS"
	// A lightning bolt pattern
	PinnedDiscussionPatternZap PinnedDiscussionPattern = "ZAP"
	// An upward-facing chevron pattern
	PinnedDiscussionPatternChevronUp PinnedDiscussionPattern = "CHEVRON_UP"
	// A hollow dot pattern
	PinnedDiscussionPatternDot PinnedDiscussionPattern = "DOT"
	// A heart pattern
	PinnedDiscussionPatternHeartFill PinnedDiscussionPattern = "HEART_FILL"
)

var AllPinnedDiscussionPattern = []PinnedDiscussionPattern{
	PinnedDiscussionPatternDotFill,
	PinnedDiscussionPatternPlus,
	PinnedDiscussionPatternZap,
	PinnedDiscussionPatternChevronUp,
	PinnedDiscussionPatternDot,
	PinnedDiscussionPatternHeartFill,
}

func (e PinnedDiscussionPattern) IsValid() bool {
	switch e {
	case PinnedDiscussionPatternDotFill, PinnedDiscussionPatternPlus, PinnedDiscussionPatternZap, PinnedDiscussionPatternChevronUp, PinnedDiscussionPatternDot, PinnedDiscussionPatternHeartFill:
		return true
	}
	return false
}

func (e PinnedDiscussionPattern) String() string {
	return string(e)
}

func (e *PinnedDiscussionPattern) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PinnedDiscussionPattern(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PinnedDiscussionPattern", str)
	}
	return nil
}

func (e PinnedDiscussionPattern) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which pinned environments connections can be ordered
type PinnedEnvironmentOrderField string

const (
	// Order pinned environments by position
	PinnedEnvironmentOrderFieldPosition PinnedEnvironmentOrderField = "POSITION"
)

var AllPinnedEnvironmentOrderField = []PinnedEnvironmentOrderField{
	PinnedEnvironmentOrderFieldPosition,
}

func (e PinnedEnvironmentOrderField) IsValid() bool {
	switch e {
	case PinnedEnvironmentOrderFieldPosition:
		return true
	}
	return false
}

func (e PinnedEnvironmentOrderField) String() string {
	return string(e)
}

func (e *PinnedEnvironmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PinnedEnvironmentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PinnedEnvironmentOrderField", str)
	}
	return nil
}

func (e PinnedEnvironmentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible archived states of a project card.
type ProjectCardArchivedState string

const (
	// A project card that is archived
	ProjectCardArchivedStateArchived ProjectCardArchivedState = "ARCHIVED"
	// A project card that is not archived
	ProjectCardArchivedStateNotArchived ProjectCardArchivedState = "NOT_ARCHIVED"
)

var AllProjectCardArchivedState = []ProjectCardArchivedState{
	ProjectCardArchivedStateArchived,
	ProjectCardArchivedStateNotArchived,
}

func (e ProjectCardArchivedState) IsValid() bool {
	switch e {
	case ProjectCardArchivedStateArchived, ProjectCardArchivedStateNotArchived:
		return true
	}
	return false
}

func (e ProjectCardArchivedState) String() string {
	return string(e)
}

func (e *ProjectCardArchivedState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectCardArchivedState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectCardArchivedState", str)
	}
	return nil
}

func (e ProjectCardArchivedState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Various content states of a ProjectCard
type ProjectCardState string

const (
	// The card has content only.
	ProjectCardStateContentOnly ProjectCardState = "CONTENT_ONLY"
	// The card has a note only.
	ProjectCardStateNoteOnly ProjectCardState = "NOTE_ONLY"
	// The card is redacted.
	ProjectCardStateRedacted ProjectCardState = "REDACTED"
)

var AllProjectCardState = []ProjectCardState{
	ProjectCardStateContentOnly,
	ProjectCardStateNoteOnly,
	ProjectCardStateRedacted,
}

func (e ProjectCardState) IsValid() bool {
	switch e {
	case ProjectCardStateContentOnly, ProjectCardStateNoteOnly, ProjectCardStateRedacted:
		return true
	}
	return false
}

func (e ProjectCardState) String() string {
	return string(e)
}

func (e *ProjectCardState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectCardState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectCardState", str)
	}
	return nil
}

func (e ProjectCardState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The semantic purpose of the column - todo, in progress, or done.
type ProjectColumnPurpose string

const (
	// The column contains cards still to be worked on
	ProjectColumnPurposeTodo ProjectColumnPurpose = "TODO"
	// The column contains cards which are currently being worked on
	ProjectColumnPurposeInProgress ProjectColumnPurpose = "IN_PROGRESS"
	// The column contains cards which are complete
	ProjectColumnPurposeDone ProjectColumnPurpose = "DONE"
)

var AllProjectColumnPurpose = []ProjectColumnPurpose{
	ProjectColumnPurposeTodo,
	ProjectColumnPurposeInProgress,
	ProjectColumnPurposeDone,
}

func (e ProjectColumnPurpose) IsValid() bool {
	switch e {
	case ProjectColumnPurposeTodo, ProjectColumnPurposeInProgress, ProjectColumnPurposeDone:
		return true
	}
	return false
}

func (e ProjectColumnPurpose) String() string {
	return string(e)
}

func (e *ProjectColumnPurpose) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectColumnPurpose(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectColumnPurpose", str)
	}
	return nil
}

func (e ProjectColumnPurpose) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project connections can be ordered.
type ProjectOrderField string

const (
	// Order projects by creation time
	ProjectOrderFieldCreatedAt ProjectOrderField = "CREATED_AT"
	// Order projects by update time
	ProjectOrderFieldUpdatedAt ProjectOrderField = "UPDATED_AT"
	// Order projects by name
	ProjectOrderFieldName ProjectOrderField = "NAME"
)

var AllProjectOrderField = []ProjectOrderField{
	ProjectOrderFieldCreatedAt,
	ProjectOrderFieldUpdatedAt,
	ProjectOrderFieldName,
}

func (e ProjectOrderField) IsValid() bool {
	switch e {
	case ProjectOrderFieldCreatedAt, ProjectOrderFieldUpdatedAt, ProjectOrderFieldName:
		return true
	}
	return false
}

func (e ProjectOrderField) String() string {
	return string(e)
}

func (e *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

func (e ProjectOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// State of the project; either 'open' or 'closed'
type ProjectState string

const (
	// The project is open.
	ProjectStateOpen ProjectState = "OPEN"
	// The project is closed.
	ProjectStateClosed ProjectState = "CLOSED"
)

var AllProjectState = []ProjectState{
	ProjectStateOpen,
	ProjectStateClosed,
}

func (e ProjectState) IsValid() bool {
	switch e {
	case ProjectStateOpen, ProjectStateClosed:
		return true
	}
	return false
}

func (e ProjectState) String() string {
	return string(e)
}

func (e *ProjectState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectState", str)
	}
	return nil
}

func (e ProjectState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// GitHub-provided templates for Projects
type ProjectTemplate string

const (
	// Create a board with columns for To do, In progress and Done.
	ProjectTemplateBasicKanban ProjectTemplate = "BASIC_KANBAN"
	// Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns.
	ProjectTemplateAutomatedKanbanV2 ProjectTemplate = "AUTOMATED_KANBAN_V2"
	// Create a board with triggers to automatically move cards across columns with review automation.
	ProjectTemplateAutomatedReviewsKanban ProjectTemplate = "AUTOMATED_REVIEWS_KANBAN"
	// Create a board to triage and prioritize bugs with To do, priority, and Done columns.
	ProjectTemplateBugTriage ProjectTemplate = "BUG_TRIAGE"
)

var AllProjectTemplate = []ProjectTemplate{
	ProjectTemplateBasicKanban,
	ProjectTemplateAutomatedKanbanV2,
	ProjectTemplateAutomatedReviewsKanban,
	ProjectTemplateBugTriage,
}

func (e ProjectTemplate) IsValid() bool {
	switch e {
	case ProjectTemplateBasicKanban, ProjectTemplateAutomatedKanbanV2, ProjectTemplateAutomatedReviewsKanban, ProjectTemplateBugTriage:
		return true
	}
	return false
}

func (e ProjectTemplate) String() string {
	return string(e)
}

func (e *ProjectTemplate) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectTemplate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectTemplate", str)
	}
	return nil
}

func (e ProjectTemplate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of a project field.
type ProjectV2CustomFieldType string

const (
	// Text
	ProjectV2CustomFieldTypeText ProjectV2CustomFieldType = "TEXT"
	// Single Select
	ProjectV2CustomFieldTypeSingleSelect ProjectV2CustomFieldType = "SINGLE_SELECT"
	// Number
	ProjectV2CustomFieldTypeNumber ProjectV2CustomFieldType = "NUMBER"
	// Date
	ProjectV2CustomFieldTypeDate ProjectV2CustomFieldType = "DATE"
)

var AllProjectV2CustomFieldType = []ProjectV2CustomFieldType{
	ProjectV2CustomFieldTypeText,
	ProjectV2CustomFieldTypeSingleSelect,
	ProjectV2CustomFieldTypeNumber,
	ProjectV2CustomFieldTypeDate,
}

func (e ProjectV2CustomFieldType) IsValid() bool {
	switch e {
	case ProjectV2CustomFieldTypeText, ProjectV2CustomFieldTypeSingleSelect, ProjectV2CustomFieldTypeNumber, ProjectV2CustomFieldTypeDate:
		return true
	}
	return false
}

func (e ProjectV2CustomFieldType) String() string {
	return string(e)
}

func (e *ProjectV2CustomFieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2CustomFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2CustomFieldType", str)
	}
	return nil
}

func (e ProjectV2CustomFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project v2 field connections can be ordered.
type ProjectV2FieldOrderField string

const (
	// Order project v2 fields by position
	ProjectV2FieldOrderFieldPosition ProjectV2FieldOrderField = "POSITION"
	// Order project v2 fields by creation time
	ProjectV2FieldOrderFieldCreatedAt ProjectV2FieldOrderField = "CREATED_AT"
	// Order project v2 fields by name
	ProjectV2FieldOrderFieldName ProjectV2FieldOrderField = "NAME"
)

var AllProjectV2FieldOrderField = []ProjectV2FieldOrderField{
	ProjectV2FieldOrderFieldPosition,
	ProjectV2FieldOrderFieldCreatedAt,
	ProjectV2FieldOrderFieldName,
}

func (e ProjectV2FieldOrderField) IsValid() bool {
	switch e {
	case ProjectV2FieldOrderFieldPosition, ProjectV2FieldOrderFieldCreatedAt, ProjectV2FieldOrderFieldName:
		return true
	}
	return false
}

func (e ProjectV2FieldOrderField) String() string {
	return string(e)
}

func (e *ProjectV2FieldOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2FieldOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2FieldOrderField", str)
	}
	return nil
}

func (e ProjectV2FieldOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of a project field.
type ProjectV2FieldType string

const (
	// Assignees
	ProjectV2FieldTypeAssignees ProjectV2FieldType = "ASSIGNEES"
	// Linked Pull Requests
	ProjectV2FieldTypeLinkedPullRequests ProjectV2FieldType = "LINKED_PULL_REQUESTS"
	// Reviewers
	ProjectV2FieldTypeReviewers ProjectV2FieldType = "REVIEWERS"
	// Labels
	ProjectV2FieldTypeLabels ProjectV2FieldType = "LABELS"
	// Milestone
	ProjectV2FieldTypeMilestone ProjectV2FieldType = "MILESTONE"
	// Repository
	ProjectV2FieldTypeRepository ProjectV2FieldType = "REPOSITORY"
	// Title
	ProjectV2FieldTypeTitle ProjectV2FieldType = "TITLE"
	// Text
	ProjectV2FieldTypeText ProjectV2FieldType = "TEXT"
	// Single Select
	ProjectV2FieldTypeSingleSelect ProjectV2FieldType = "SINGLE_SELECT"
	// Number
	ProjectV2FieldTypeNumber ProjectV2FieldType = "NUMBER"
	// Date
	ProjectV2FieldTypeDate ProjectV2FieldType = "DATE"
	// Iteration
	ProjectV2FieldTypeIteration ProjectV2FieldType = "ITERATION"
	// Tracks
	ProjectV2FieldTypeTracks ProjectV2FieldType = "TRACKS"
	// Tracked by
	ProjectV2FieldTypeTrackedBy ProjectV2FieldType = "TRACKED_BY"
)

var AllProjectV2FieldType = []ProjectV2FieldType{
	ProjectV2FieldTypeAssignees,
	ProjectV2FieldTypeLinkedPullRequests,
	ProjectV2FieldTypeReviewers,
	ProjectV2FieldTypeLabels,
	ProjectV2FieldTypeMilestone,
	ProjectV2FieldTypeRepository,
	ProjectV2FieldTypeTitle,
	ProjectV2FieldTypeText,
	ProjectV2FieldTypeSingleSelect,
	ProjectV2FieldTypeNumber,
	ProjectV2FieldTypeDate,
	ProjectV2FieldTypeIteration,
	ProjectV2FieldTypeTracks,
	ProjectV2FieldTypeTrackedBy,
}

func (e ProjectV2FieldType) IsValid() bool {
	switch e {
	case ProjectV2FieldTypeAssignees, ProjectV2FieldTypeLinkedPullRequests, ProjectV2FieldTypeReviewers, ProjectV2FieldTypeLabels, ProjectV2FieldTypeMilestone, ProjectV2FieldTypeRepository, ProjectV2FieldTypeTitle, ProjectV2FieldTypeText, ProjectV2FieldTypeSingleSelect, ProjectV2FieldTypeNumber, ProjectV2FieldTypeDate, ProjectV2FieldTypeIteration, ProjectV2FieldTypeTracks, ProjectV2FieldTypeTrackedBy:
		return true
	}
	return false
}

func (e ProjectV2FieldType) String() string {
	return string(e)
}

func (e *ProjectV2FieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2FieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2FieldType", str)
	}
	return nil
}

func (e ProjectV2FieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project v2 item field value connections can be ordered.
type ProjectV2ItemFieldValueOrderField string

const (
	// Order project v2 item field values by the their position in the project
	ProjectV2ItemFieldValueOrderFieldPosition ProjectV2ItemFieldValueOrderField = "POSITION"
)

var AllProjectV2ItemFieldValueOrderField = []ProjectV2ItemFieldValueOrderField{
	ProjectV2ItemFieldValueOrderFieldPosition,
}

func (e ProjectV2ItemFieldValueOrderField) IsValid() bool {
	switch e {
	case ProjectV2ItemFieldValueOrderFieldPosition:
		return true
	}
	return false
}

func (e ProjectV2ItemFieldValueOrderField) String() string {
	return string(e)
}

func (e *ProjectV2ItemFieldValueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2ItemFieldValueOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2ItemFieldValueOrderField", str)
	}
	return nil
}

func (e ProjectV2ItemFieldValueOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project v2 item connections can be ordered.
type ProjectV2ItemOrderField string

const (
	// Order project v2 items by the their position in the project
	ProjectV2ItemOrderFieldPosition ProjectV2ItemOrderField = "POSITION"
)

var AllProjectV2ItemOrderField = []ProjectV2ItemOrderField{
	ProjectV2ItemOrderFieldPosition,
}

func (e ProjectV2ItemOrderField) IsValid() bool {
	switch e {
	case ProjectV2ItemOrderFieldPosition:
		return true
	}
	return false
}

func (e ProjectV2ItemOrderField) String() string {
	return string(e)
}

func (e *ProjectV2ItemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2ItemOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2ItemOrderField", str)
	}
	return nil
}

func (e ProjectV2ItemOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of a project item.
type ProjectV2ItemType string

const (
	// Issue
	ProjectV2ItemTypeIssue ProjectV2ItemType = "ISSUE"
	// Pull Request
	ProjectV2ItemTypePullRequest ProjectV2ItemType = "PULL_REQUEST"
	// Draft Issue
	ProjectV2ItemTypeDraftIssue ProjectV2ItemType = "DRAFT_ISSUE"
	// Redacted Item
	ProjectV2ItemTypeRedacted ProjectV2ItemType = "REDACTED"
)

var AllProjectV2ItemType = []ProjectV2ItemType{
	ProjectV2ItemTypeIssue,
	ProjectV2ItemTypePullRequest,
	ProjectV2ItemTypeDraftIssue,
	ProjectV2ItemTypeRedacted,
}

func (e ProjectV2ItemType) IsValid() bool {
	switch e {
	case ProjectV2ItemTypeIssue, ProjectV2ItemTypePullRequest, ProjectV2ItemTypeDraftIssue, ProjectV2ItemTypeRedacted:
		return true
	}
	return false
}

func (e ProjectV2ItemType) String() string {
	return string(e)
}

func (e *ProjectV2ItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2ItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2ItemType", str)
	}
	return nil
}

func (e ProjectV2ItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which projects can be ordered.
type ProjectV2OrderField string

const (
	// The project's title
	ProjectV2OrderFieldTitle ProjectV2OrderField = "TITLE"
	// The project's number
	ProjectV2OrderFieldNumber ProjectV2OrderField = "NUMBER"
	// The project's date and time of update
	ProjectV2OrderFieldUpdatedAt ProjectV2OrderField = "UPDATED_AT"
	// The project's date and time of creation
	ProjectV2OrderFieldCreatedAt ProjectV2OrderField = "CREATED_AT"
)

var AllProjectV2OrderField = []ProjectV2OrderField{
	ProjectV2OrderFieldTitle,
	ProjectV2OrderFieldNumber,
	ProjectV2OrderFieldUpdatedAt,
	ProjectV2OrderFieldCreatedAt,
}

func (e ProjectV2OrderField) IsValid() bool {
	switch e {
	case ProjectV2OrderFieldTitle, ProjectV2OrderFieldNumber, ProjectV2OrderFieldUpdatedAt, ProjectV2OrderFieldCreatedAt:
		return true
	}
	return false
}

func (e ProjectV2OrderField) String() string {
	return string(e)
}

func (e *ProjectV2OrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2OrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2OrderField", str)
	}
	return nil
}

func (e ProjectV2OrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible roles of a collaborator on a project.
type ProjectV2PermissionLevel string

const (
	// The collaborator can view the project
	ProjectV2PermissionLevelRead ProjectV2PermissionLevel = "READ"
	// The collaborator can view and edit the project
	ProjectV2PermissionLevelWrite ProjectV2PermissionLevel = "WRITE"
	// The collaborator can view, edit, and maange the settings of the project
	ProjectV2PermissionLevelAdmin ProjectV2PermissionLevel = "ADMIN"
)

var AllProjectV2PermissionLevel = []ProjectV2PermissionLevel{
	ProjectV2PermissionLevelRead,
	ProjectV2PermissionLevelWrite,
	ProjectV2PermissionLevelAdmin,
}

func (e ProjectV2PermissionLevel) IsValid() bool {
	switch e {
	case ProjectV2PermissionLevelRead, ProjectV2PermissionLevelWrite, ProjectV2PermissionLevelAdmin:
		return true
	}
	return false
}

func (e ProjectV2PermissionLevel) String() string {
	return string(e)
}

func (e *ProjectV2PermissionLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2PermissionLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2PermissionLevel", str)
	}
	return nil
}

func (e ProjectV2PermissionLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible roles of a collaborator on a project.
type ProjectV2Roles string

const (
	// The collaborator has no direct access to the project
	ProjectV2RolesNone ProjectV2Roles = "NONE"
	// The collaborator can view the project
	ProjectV2RolesReader ProjectV2Roles = "READER"
	// The collaborator can view and edit the project
	ProjectV2RolesWriter ProjectV2Roles = "WRITER"
	// The collaborator can view, edit, and maange the settings of the project
	ProjectV2RolesAdmin ProjectV2Roles = "ADMIN"
)

var AllProjectV2Roles = []ProjectV2Roles{
	ProjectV2RolesNone,
	ProjectV2RolesReader,
	ProjectV2RolesWriter,
	ProjectV2RolesAdmin,
}

func (e ProjectV2Roles) IsValid() bool {
	switch e {
	case ProjectV2RolesNone, ProjectV2RolesReader, ProjectV2RolesWriter, ProjectV2RolesAdmin:
		return true
	}
	return false
}

func (e ProjectV2Roles) String() string {
	return string(e)
}

func (e *ProjectV2Roles) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2Roles(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2Roles", str)
	}
	return nil
}

func (e ProjectV2Roles) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The display color of a single-select field option.
type ProjectV2SingleSelectFieldOptionColor string

const (
	// GRAY
	ProjectV2SingleSelectFieldOptionColorGray ProjectV2SingleSelectFieldOptionColor = "GRAY"
	// BLUE
	ProjectV2SingleSelectFieldOptionColorBlue ProjectV2SingleSelectFieldOptionColor = "BLUE"
	// GREEN
	ProjectV2SingleSelectFieldOptionColorGreen ProjectV2SingleSelectFieldOptionColor = "GREEN"
	// YELLOW
	ProjectV2SingleSelectFieldOptionColorYellow ProjectV2SingleSelectFieldOptionColor = "YELLOW"
	// ORANGE
	ProjectV2SingleSelectFieldOptionColorOrange ProjectV2SingleSelectFieldOptionColor = "ORANGE"
	// RED
	ProjectV2SingleSelectFieldOptionColorRed ProjectV2SingleSelectFieldOptionColor = "RED"
	// PINK
	ProjectV2SingleSelectFieldOptionColorPink ProjectV2SingleSelectFieldOptionColor = "PINK"
	// PURPLE
	ProjectV2SingleSelectFieldOptionColorPurple ProjectV2SingleSelectFieldOptionColor = "PURPLE"
)

var AllProjectV2SingleSelectFieldOptionColor = []ProjectV2SingleSelectFieldOptionColor{
	ProjectV2SingleSelectFieldOptionColorGray,
	ProjectV2SingleSelectFieldOptionColorBlue,
	ProjectV2SingleSelectFieldOptionColorGreen,
	ProjectV2SingleSelectFieldOptionColorYellow,
	ProjectV2SingleSelectFieldOptionColorOrange,
	ProjectV2SingleSelectFieldOptionColorRed,
	ProjectV2SingleSelectFieldOptionColorPink,
	ProjectV2SingleSelectFieldOptionColorPurple,
}

func (e ProjectV2SingleSelectFieldOptionColor) IsValid() bool {
	switch e {
	case ProjectV2SingleSelectFieldOptionColorGray, ProjectV2SingleSelectFieldOptionColorBlue, ProjectV2SingleSelectFieldOptionColorGreen, ProjectV2SingleSelectFieldOptionColorYellow, ProjectV2SingleSelectFieldOptionColorOrange, ProjectV2SingleSelectFieldOptionColorRed, ProjectV2SingleSelectFieldOptionColorPink, ProjectV2SingleSelectFieldOptionColorPurple:
		return true
	}
	return false
}

func (e ProjectV2SingleSelectFieldOptionColor) String() string {
	return string(e)
}

func (e *ProjectV2SingleSelectFieldOptionColor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2SingleSelectFieldOptionColor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2SingleSelectFieldOptionColor", str)
	}
	return nil
}

func (e ProjectV2SingleSelectFieldOptionColor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a project v2.
type ProjectV2State string

const (
	// A project v2 that is still open
	ProjectV2StateOpen ProjectV2State = "OPEN"
	// A project v2 that has been closed
	ProjectV2StateClosed ProjectV2State = "CLOSED"
)

var AllProjectV2State = []ProjectV2State{
	ProjectV2StateOpen,
	ProjectV2StateClosed,
}

func (e ProjectV2State) IsValid() bool {
	switch e {
	case ProjectV2StateOpen, ProjectV2StateClosed:
		return true
	}
	return false
}

func (e ProjectV2State) String() string {
	return string(e)
}

func (e *ProjectV2State) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2State(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2State", str)
	}
	return nil
}

func (e ProjectV2State) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project v2 status updates can be ordered.
type ProjectV2StatusUpdateOrderField string

const (
	// Allows chronological ordering of project v2 status updates.
	ProjectV2StatusUpdateOrderFieldCreatedAt ProjectV2StatusUpdateOrderField = "CREATED_AT"
)

var AllProjectV2StatusUpdateOrderField = []ProjectV2StatusUpdateOrderField{
	ProjectV2StatusUpdateOrderFieldCreatedAt,
}

func (e ProjectV2StatusUpdateOrderField) IsValid() bool {
	switch e {
	case ProjectV2StatusUpdateOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e ProjectV2StatusUpdateOrderField) String() string {
	return string(e)
}

func (e *ProjectV2StatusUpdateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2StatusUpdateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2StatusUpdateOrderField", str)
	}
	return nil
}

func (e ProjectV2StatusUpdateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible statuses of a project v2.
type ProjectV2StatusUpdateStatus string

const (
	// A project v2 that is inactive.
	ProjectV2StatusUpdateStatusInactive ProjectV2StatusUpdateStatus = "INACTIVE"
	// A project v2 that is on track with no risks.
	ProjectV2StatusUpdateStatusOnTrack ProjectV2StatusUpdateStatus = "ON_TRACK"
	// A project v2 that is at risk and encountering some challenges.
	ProjectV2StatusUpdateStatusAtRisk ProjectV2StatusUpdateStatus = "AT_RISK"
	// A project v2 that is off track and needs attention.
	ProjectV2StatusUpdateStatusOffTrack ProjectV2StatusUpdateStatus = "OFF_TRACK"
	// A project v2 that is complete.
	ProjectV2StatusUpdateStatusComplete ProjectV2StatusUpdateStatus = "COMPLETE"
)

var AllProjectV2StatusUpdateStatus = []ProjectV2StatusUpdateStatus{
	ProjectV2StatusUpdateStatusInactive,
	ProjectV2StatusUpdateStatusOnTrack,
	ProjectV2StatusUpdateStatusAtRisk,
	ProjectV2StatusUpdateStatusOffTrack,
	ProjectV2StatusUpdateStatusComplete,
}

func (e ProjectV2StatusUpdateStatus) IsValid() bool {
	switch e {
	case ProjectV2StatusUpdateStatusInactive, ProjectV2StatusUpdateStatusOnTrack, ProjectV2StatusUpdateStatusAtRisk, ProjectV2StatusUpdateStatusOffTrack, ProjectV2StatusUpdateStatusComplete:
		return true
	}
	return false
}

func (e ProjectV2StatusUpdateStatus) String() string {
	return string(e)
}

func (e *ProjectV2StatusUpdateStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2StatusUpdateStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2StatusUpdateStatus", str)
	}
	return nil
}

func (e ProjectV2StatusUpdateStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The layout of a project v2 view.
type ProjectV2ViewLayout string

const (
	// Board layout
	ProjectV2ViewLayoutBoardLayout ProjectV2ViewLayout = "BOARD_LAYOUT"
	// Table layout
	ProjectV2ViewLayoutTableLayout ProjectV2ViewLayout = "TABLE_LAYOUT"
	// Roadmap layout
	ProjectV2ViewLayoutRoadmapLayout ProjectV2ViewLayout = "ROADMAP_LAYOUT"
)

var AllProjectV2ViewLayout = []ProjectV2ViewLayout{
	ProjectV2ViewLayoutBoardLayout,
	ProjectV2ViewLayoutTableLayout,
	ProjectV2ViewLayoutRoadmapLayout,
}

func (e ProjectV2ViewLayout) IsValid() bool {
	switch e {
	case ProjectV2ViewLayoutBoardLayout, ProjectV2ViewLayoutTableLayout, ProjectV2ViewLayoutRoadmapLayout:
		return true
	}
	return false
}

func (e ProjectV2ViewLayout) String() string {
	return string(e)
}

func (e *ProjectV2ViewLayout) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2ViewLayout(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2ViewLayout", str)
	}
	return nil
}

func (e ProjectV2ViewLayout) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project v2 view connections can be ordered.
type ProjectV2ViewOrderField string

const (
	// Order project v2 views by position
	ProjectV2ViewOrderFieldPosition ProjectV2ViewOrderField = "POSITION"
	// Order project v2 views by creation time
	ProjectV2ViewOrderFieldCreatedAt ProjectV2ViewOrderField = "CREATED_AT"
	// Order project v2 views by name
	ProjectV2ViewOrderFieldName ProjectV2ViewOrderField = "NAME"
)

var AllProjectV2ViewOrderField = []ProjectV2ViewOrderField{
	ProjectV2ViewOrderFieldPosition,
	ProjectV2ViewOrderFieldCreatedAt,
	ProjectV2ViewOrderFieldName,
}

func (e ProjectV2ViewOrderField) IsValid() bool {
	switch e {
	case ProjectV2ViewOrderFieldPosition, ProjectV2ViewOrderFieldCreatedAt, ProjectV2ViewOrderFieldName:
		return true
	}
	return false
}

func (e ProjectV2ViewOrderField) String() string {
	return string(e)
}

func (e *ProjectV2ViewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2ViewOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2ViewOrderField", str)
	}
	return nil
}

func (e ProjectV2ViewOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which project workflows can be ordered.
type ProjectV2WorkflowsOrderField string

const (
	// The name of the workflow
	ProjectV2WorkflowsOrderFieldName ProjectV2WorkflowsOrderField = "NAME"
	// The number of the workflow
	ProjectV2WorkflowsOrderFieldNumber ProjectV2WorkflowsOrderField = "NUMBER"
	// The date and time of the workflow update
	ProjectV2WorkflowsOrderFieldUpdatedAt ProjectV2WorkflowsOrderField = "UPDATED_AT"
	// The date and time of the workflow creation
	ProjectV2WorkflowsOrderFieldCreatedAt ProjectV2WorkflowsOrderField = "CREATED_AT"
)

var AllProjectV2WorkflowsOrderField = []ProjectV2WorkflowsOrderField{
	ProjectV2WorkflowsOrderFieldName,
	ProjectV2WorkflowsOrderFieldNumber,
	ProjectV2WorkflowsOrderFieldUpdatedAt,
	ProjectV2WorkflowsOrderFieldCreatedAt,
}

func (e ProjectV2WorkflowsOrderField) IsValid() bool {
	switch e {
	case ProjectV2WorkflowsOrderFieldName, ProjectV2WorkflowsOrderFieldNumber, ProjectV2WorkflowsOrderFieldUpdatedAt, ProjectV2WorkflowsOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e ProjectV2WorkflowsOrderField) String() string {
	return string(e)
}

func (e *ProjectV2WorkflowsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectV2WorkflowsOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectV2WorkflowsOrderField", str)
	}
	return nil
}

func (e ProjectV2WorkflowsOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible methods for updating a pull request's head branch with the base branch.
type PullRequestBranchUpdateMethod string

const (
	// Update branch via merge
	PullRequestBranchUpdateMethodMerge PullRequestBranchUpdateMethod = "MERGE"
	// Update branch via rebase
	PullRequestBranchUpdateMethodRebase PullRequestBranchUpdateMethod = "REBASE"
)

var AllPullRequestBranchUpdateMethod = []PullRequestBranchUpdateMethod{
	PullRequestBranchUpdateMethodMerge,
	PullRequestBranchUpdateMethodRebase,
}

func (e PullRequestBranchUpdateMethod) IsValid() bool {
	switch e {
	case PullRequestBranchUpdateMethodMerge, PullRequestBranchUpdateMethodRebase:
		return true
	}
	return false
}

func (e PullRequestBranchUpdateMethod) String() string {
	return string(e)
}

func (e *PullRequestBranchUpdateMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestBranchUpdateMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestBranchUpdateMethod", str)
	}
	return nil
}

func (e PullRequestBranchUpdateMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents available types of methods to use when merging a pull request.
type PullRequestMergeMethod string

const (
	// Add all commits from the head branch to the base branch with a merge commit.
	PullRequestMergeMethodMerge PullRequestMergeMethod = "MERGE"
	// Combine all commits from the head branch into a single commit in the base branch.
	PullRequestMergeMethodSquash PullRequestMergeMethod = "SQUASH"
	// Add all commits from the head branch onto the base branch individually.
	PullRequestMergeMethodRebase PullRequestMergeMethod = "REBASE"
)

var AllPullRequestMergeMethod = []PullRequestMergeMethod{
	PullRequestMergeMethodMerge,
	PullRequestMergeMethodSquash,
	PullRequestMergeMethodRebase,
}

func (e PullRequestMergeMethod) IsValid() bool {
	switch e {
	case PullRequestMergeMethodMerge, PullRequestMergeMethodSquash, PullRequestMergeMethodRebase:
		return true
	}
	return false
}

func (e PullRequestMergeMethod) String() string {
	return string(e)
}

func (e *PullRequestMergeMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestMergeMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestMergeMethod", str)
	}
	return nil
}

func (e PullRequestMergeMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which pull_requests connections can be ordered.
type PullRequestOrderField string

const (
	// Order pull_requests by creation time
	PullRequestOrderFieldCreatedAt PullRequestOrderField = "CREATED_AT"
	// Order pull_requests by update time
	PullRequestOrderFieldUpdatedAt PullRequestOrderField = "UPDATED_AT"
)

var AllPullRequestOrderField = []PullRequestOrderField{
	PullRequestOrderFieldCreatedAt,
	PullRequestOrderFieldUpdatedAt,
}

func (e PullRequestOrderField) IsValid() bool {
	switch e {
	case PullRequestOrderFieldCreatedAt, PullRequestOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e PullRequestOrderField) String() string {
	return string(e)
}

func (e *PullRequestOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestOrderField", str)
	}
	return nil
}

func (e PullRequestOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a pull request review comment.
type PullRequestReviewCommentState string

const (
	// A comment that is part of a pending review
	PullRequestReviewCommentStatePending PullRequestReviewCommentState = "PENDING"
	// A comment that is part of a submitted review
	PullRequestReviewCommentStateSubmitted PullRequestReviewCommentState = "SUBMITTED"
)

var AllPullRequestReviewCommentState = []PullRequestReviewCommentState{
	PullRequestReviewCommentStatePending,
	PullRequestReviewCommentStateSubmitted,
}

func (e PullRequestReviewCommentState) IsValid() bool {
	switch e {
	case PullRequestReviewCommentStatePending, PullRequestReviewCommentStateSubmitted:
		return true
	}
	return false
}

func (e PullRequestReviewCommentState) String() string {
	return string(e)
}

func (e *PullRequestReviewCommentState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestReviewCommentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestReviewCommentState", str)
	}
	return nil
}

func (e PullRequestReviewCommentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The review status of a pull request.
type PullRequestReviewDecision string

const (
	// Changes have been requested on the pull request.
	PullRequestReviewDecisionChangesRequested PullRequestReviewDecision = "CHANGES_REQUESTED"
	// The pull request has received an approving review.
	PullRequestReviewDecisionApproved PullRequestReviewDecision = "APPROVED"
	// A review is required before the pull request can be merged.
	PullRequestReviewDecisionReviewRequired PullRequestReviewDecision = "REVIEW_REQUIRED"
)

var AllPullRequestReviewDecision = []PullRequestReviewDecision{
	PullRequestReviewDecisionChangesRequested,
	PullRequestReviewDecisionApproved,
	PullRequestReviewDecisionReviewRequired,
}

func (e PullRequestReviewDecision) IsValid() bool {
	switch e {
	case PullRequestReviewDecisionChangesRequested, PullRequestReviewDecisionApproved, PullRequestReviewDecisionReviewRequired:
		return true
	}
	return false
}

func (e PullRequestReviewDecision) String() string {
	return string(e)
}

func (e *PullRequestReviewDecision) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestReviewDecision(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestReviewDecision", str)
	}
	return nil
}

func (e PullRequestReviewDecision) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible events to perform on a pull request review.
type PullRequestReviewEvent string

const (
	// Submit general feedback without explicit approval.
	PullRequestReviewEventComment PullRequestReviewEvent = "COMMENT"
	// Submit feedback and approve merging these changes.
	PullRequestReviewEventApprove PullRequestReviewEvent = "APPROVE"
	// Submit feedback that must be addressed before merging.
	PullRequestReviewEventRequestChanges PullRequestReviewEvent = "REQUEST_CHANGES"
	// Dismiss review so it now longer effects merging.
	PullRequestReviewEventDismiss PullRequestReviewEvent = "DISMISS"
)

var AllPullRequestReviewEvent = []PullRequestReviewEvent{
	PullRequestReviewEventComment,
	PullRequestReviewEventApprove,
	PullRequestReviewEventRequestChanges,
	PullRequestReviewEventDismiss,
}

func (e PullRequestReviewEvent) IsValid() bool {
	switch e {
	case PullRequestReviewEventComment, PullRequestReviewEventApprove, PullRequestReviewEventRequestChanges, PullRequestReviewEventDismiss:
		return true
	}
	return false
}

func (e PullRequestReviewEvent) String() string {
	return string(e)
}

func (e *PullRequestReviewEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestReviewEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestReviewEvent", str)
	}
	return nil
}

func (e PullRequestReviewEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a pull request review.
type PullRequestReviewState string

const (
	// A review that has not yet been submitted.
	PullRequestReviewStatePending PullRequestReviewState = "PENDING"
	// An informational review.
	PullRequestReviewStateCommented PullRequestReviewState = "COMMENTED"
	// A review allowing the pull request to merge.
	PullRequestReviewStateApproved PullRequestReviewState = "APPROVED"
	// A review blocking the pull request from merging.
	PullRequestReviewStateChangesRequested PullRequestReviewState = "CHANGES_REQUESTED"
	// A review that has been dismissed.
	PullRequestReviewStateDismissed PullRequestReviewState = "DISMISSED"
)

var AllPullRequestReviewState = []PullRequestReviewState{
	PullRequestReviewStatePending,
	PullRequestReviewStateCommented,
	PullRequestReviewStateApproved,
	PullRequestReviewStateChangesRequested,
	PullRequestReviewStateDismissed,
}

func (e PullRequestReviewState) IsValid() bool {
	switch e {
	case PullRequestReviewStatePending, PullRequestReviewStateCommented, PullRequestReviewStateApproved, PullRequestReviewStateChangesRequested, PullRequestReviewStateDismissed:
		return true
	}
	return false
}

func (e PullRequestReviewState) String() string {
	return string(e)
}

func (e *PullRequestReviewState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestReviewState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestReviewState", str)
	}
	return nil
}

func (e PullRequestReviewState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible subject types of a pull request review comment.
type PullRequestReviewThreadSubjectType string

const (
	// A comment that has been made against the line of a pull request
	PullRequestReviewThreadSubjectTypeLine PullRequestReviewThreadSubjectType = "LINE"
	// A comment that has been made against the file of a pull request
	PullRequestReviewThreadSubjectTypeFile PullRequestReviewThreadSubjectType = "FILE"
)

var AllPullRequestReviewThreadSubjectType = []PullRequestReviewThreadSubjectType{
	PullRequestReviewThreadSubjectTypeLine,
	PullRequestReviewThreadSubjectTypeFile,
}

func (e PullRequestReviewThreadSubjectType) IsValid() bool {
	switch e {
	case PullRequestReviewThreadSubjectTypeLine, PullRequestReviewThreadSubjectTypeFile:
		return true
	}
	return false
}

func (e PullRequestReviewThreadSubjectType) String() string {
	return string(e)
}

func (e *PullRequestReviewThreadSubjectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestReviewThreadSubjectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestReviewThreadSubjectType", str)
	}
	return nil
}

func (e PullRequestReviewThreadSubjectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a pull request.
type PullRequestState string

const (
	// A pull request that is still open.
	PullRequestStateOpen PullRequestState = "OPEN"
	// A pull request that has been closed without being merged.
	PullRequestStateClosed PullRequestState = "CLOSED"
	// A pull request that has been closed by being merged.
	PullRequestStateMerged PullRequestState = "MERGED"
)

var AllPullRequestState = []PullRequestState{
	PullRequestStateOpen,
	PullRequestStateClosed,
	PullRequestStateMerged,
}

func (e PullRequestState) IsValid() bool {
	switch e {
	case PullRequestStateOpen, PullRequestStateClosed, PullRequestStateMerged:
		return true
	}
	return false
}

func (e PullRequestState) String() string {
	return string(e)
}

func (e *PullRequestState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestState", str)
	}
	return nil
}

func (e PullRequestState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible item types found in a timeline.
type PullRequestTimelineItemsItemType string

const (
	// Represents a Git commit part of a pull request.
	PullRequestTimelineItemsItemTypePullRequestCommit PullRequestTimelineItemsItemType = "PULL_REQUEST_COMMIT"
	// Represents a commit comment thread part of a pull request.
	PullRequestTimelineItemsItemTypePullRequestCommitCommentThread PullRequestTimelineItemsItemType = "PULL_REQUEST_COMMIT_COMMENT_THREAD"
	// A review object for a given pull request.
	PullRequestTimelineItemsItemTypePullRequestReview PullRequestTimelineItemsItemType = "PULL_REQUEST_REVIEW"
	// A threaded list of comments for a given pull request.
	PullRequestTimelineItemsItemTypePullRequestReviewThread PullRequestTimelineItemsItemType = "PULL_REQUEST_REVIEW_THREAD"
	// Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits.
	PullRequestTimelineItemsItemTypePullRequestRevisionMarker PullRequestTimelineItemsItemType = "PULL_REQUEST_REVISION_MARKER"
	// Represents a 'automatic_base_change_failed' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeFailedEvent PullRequestTimelineItemsItemType = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT"
	// Represents a 'automatic_base_change_succeeded' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeSucceededEvent PullRequestTimelineItemsItemType = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT"
	// Represents a 'auto_merge_disabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoMergeDisabledEvent PullRequestTimelineItemsItemType = "AUTO_MERGE_DISABLED_EVENT"
	// Represents a 'auto_merge_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoMergeEnabledEvent PullRequestTimelineItemsItemType = "AUTO_MERGE_ENABLED_EVENT"
	// Represents a 'auto_rebase_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoRebaseEnabledEvent PullRequestTimelineItemsItemType = "AUTO_REBASE_ENABLED_EVENT"
	// Represents a 'auto_squash_enabled' event on a given pull request.
	PullRequestTimelineItemsItemTypeAutoSquashEnabledEvent PullRequestTimelineItemsItemType = "AUTO_SQUASH_ENABLED_EVENT"
	// Represents a 'base_ref_changed' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeBaseRefChangedEvent PullRequestTimelineItemsItemType = "BASE_REF_CHANGED_EVENT"
	// Represents a 'base_ref_force_pushed' event on a given pull request.
	PullRequestTimelineItemsItemTypeBaseRefForcePushedEvent PullRequestTimelineItemsItemType = "BASE_REF_FORCE_PUSHED_EVENT"
	// Represents a 'base_ref_deleted' event on a given pull request.
	PullRequestTimelineItemsItemTypeBaseRefDeletedEvent PullRequestTimelineItemsItemType = "BASE_REF_DELETED_EVENT"
	// Represents a 'deployed' event on a given pull request.
	PullRequestTimelineItemsItemTypeDeployedEvent PullRequestTimelineItemsItemType = "DEPLOYED_EVENT"
	// Represents a 'deployment_environment_changed' event on a given pull request.
	PullRequestTimelineItemsItemTypeDeploymentEnvironmentChangedEvent PullRequestTimelineItemsItemType = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT"
	// Represents a 'head_ref_deleted' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefDeletedEvent PullRequestTimelineItemsItemType = "HEAD_REF_DELETED_EVENT"
	// Represents a 'head_ref_force_pushed' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefForcePushedEvent PullRequestTimelineItemsItemType = "HEAD_REF_FORCE_PUSHED_EVENT"
	// Represents a 'head_ref_restored' event on a given pull request.
	PullRequestTimelineItemsItemTypeHeadRefRestoredEvent PullRequestTimelineItemsItemType = "HEAD_REF_RESTORED_EVENT"
	// Represents a 'merged' event on a given pull request.
	PullRequestTimelineItemsItemTypeMergedEvent PullRequestTimelineItemsItemType = "MERGED_EVENT"
	// Represents a 'review_dismissed' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeReviewDismissedEvent PullRequestTimelineItemsItemType = "REVIEW_DISMISSED_EVENT"
	// Represents an 'review_requested' event on a given pull request.
	PullRequestTimelineItemsItemTypeReviewRequestedEvent PullRequestTimelineItemsItemType = "REVIEW_REQUESTED_EVENT"
	// Represents an 'review_request_removed' event on a given pull request.
	PullRequestTimelineItemsItemTypeReviewRequestRemovedEvent PullRequestTimelineItemsItemType = "REVIEW_REQUEST_REMOVED_EVENT"
	// Represents a 'ready_for_review' event on a given pull request.
	PullRequestTimelineItemsItemTypeReadyForReviewEvent PullRequestTimelineItemsItemType = "READY_FOR_REVIEW_EVENT"
	// Represents a 'convert_to_draft' event on a given pull request.
	PullRequestTimelineItemsItemTypeConvertToDraftEvent PullRequestTimelineItemsItemType = "CONVERT_TO_DRAFT_EVENT"
	// Represents an 'added_to_merge_queue' event on a given pull request.
	PullRequestTimelineItemsItemTypeAddedToMergeQueueEvent PullRequestTimelineItemsItemType = "ADDED_TO_MERGE_QUEUE_EVENT"
	// Represents a 'removed_from_merge_queue' event on a given pull request.
	PullRequestTimelineItemsItemTypeRemovedFromMergeQueueEvent PullRequestTimelineItemsItemType = "REMOVED_FROM_MERGE_QUEUE_EVENT"
	// Represents a comment on an Issue.
	PullRequestTimelineItemsItemTypeIssueComment PullRequestTimelineItemsItemType = "ISSUE_COMMENT"
	// Represents a mention made by one issue or pull request to another.
	PullRequestTimelineItemsItemTypeCrossReferencedEvent PullRequestTimelineItemsItemType = "CROSS_REFERENCED_EVENT"
	// Represents a 'added_to_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeAddedToProjectEvent PullRequestTimelineItemsItemType = "ADDED_TO_PROJECT_EVENT"
	// Represents an 'assigned' event on any assignable object.
	PullRequestTimelineItemsItemTypeAssignedEvent PullRequestTimelineItemsItemType = "ASSIGNED_EVENT"
	// Represents a 'closed' event on any `Closable`.
	PullRequestTimelineItemsItemTypeClosedEvent PullRequestTimelineItemsItemType = "CLOSED_EVENT"
	// Represents a 'comment_deleted' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeCommentDeletedEvent PullRequestTimelineItemsItemType = "COMMENT_DELETED_EVENT"
	// Represents a 'connected' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeConnectedEvent PullRequestTimelineItemsItemType = "CONNECTED_EVENT"
	// Represents a 'converted_note_to_issue' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeConvertedNoteToIssueEvent PullRequestTimelineItemsItemType = "CONVERTED_NOTE_TO_ISSUE_EVENT"
	// Represents a 'converted_to_discussion' event on a given issue.
	PullRequestTimelineItemsItemTypeConvertedToDiscussionEvent PullRequestTimelineItemsItemType = "CONVERTED_TO_DISCUSSION_EVENT"
	// Represents a 'demilestoned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeDemilestonedEvent PullRequestTimelineItemsItemType = "DEMILESTONED_EVENT"
	// Represents a 'disconnected' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeDisconnectedEvent PullRequestTimelineItemsItemType = "DISCONNECTED_EVENT"
	// Represents a 'labeled' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeLabeledEvent PullRequestTimelineItemsItemType = "LABELED_EVENT"
	// Represents a 'locked' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeLockedEvent PullRequestTimelineItemsItemType = "LOCKED_EVENT"
	// Represents a 'marked_as_duplicate' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMarkedAsDuplicateEvent PullRequestTimelineItemsItemType = "MARKED_AS_DUPLICATE_EVENT"
	// Represents a 'mentioned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMentionedEvent PullRequestTimelineItemsItemType = "MENTIONED_EVENT"
	// Represents a 'milestoned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMilestonedEvent PullRequestTimelineItemsItemType = "MILESTONED_EVENT"
	// Represents a 'moved_columns_in_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeMovedColumnsInProjectEvent PullRequestTimelineItemsItemType = "MOVED_COLUMNS_IN_PROJECT_EVENT"
	// Represents a 'pinned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypePinnedEvent PullRequestTimelineItemsItemType = "PINNED_EVENT"
	// Represents a 'referenced' event on a given `ReferencedSubject`.
	PullRequestTimelineItemsItemTypeReferencedEvent PullRequestTimelineItemsItemType = "REFERENCED_EVENT"
	// Represents a 'removed_from_project' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeRemovedFromProjectEvent PullRequestTimelineItemsItemType = "REMOVED_FROM_PROJECT_EVENT"
	// Represents a 'renamed' event on a given issue or pull request
	PullRequestTimelineItemsItemTypeRenamedTitleEvent PullRequestTimelineItemsItemType = "RENAMED_TITLE_EVENT"
	// Represents a 'reopened' event on any `Closable`.
	PullRequestTimelineItemsItemTypeReopenedEvent PullRequestTimelineItemsItemType = "REOPENED_EVENT"
	// Represents a 'subscribed' event on a given `Subscribable`.
	PullRequestTimelineItemsItemTypeSubscribedEvent PullRequestTimelineItemsItemType = "SUBSCRIBED_EVENT"
	// Represents a 'transferred' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeTransferredEvent PullRequestTimelineItemsItemType = "TRANSFERRED_EVENT"
	// Represents an 'unassigned' event on any assignable object.
	PullRequestTimelineItemsItemTypeUnassignedEvent PullRequestTimelineItemsItemType = "UNASSIGNED_EVENT"
	// Represents an 'unlabeled' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnlabeledEvent PullRequestTimelineItemsItemType = "UNLABELED_EVENT"
	// Represents an 'unlocked' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnlockedEvent PullRequestTimelineItemsItemType = "UNLOCKED_EVENT"
	// Represents a 'user_blocked' event on a given user.
	PullRequestTimelineItemsItemTypeUserBlockedEvent PullRequestTimelineItemsItemType = "USER_BLOCKED_EVENT"
	// Represents an 'unmarked_as_duplicate' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnmarkedAsDuplicateEvent PullRequestTimelineItemsItemType = "UNMARKED_AS_DUPLICATE_EVENT"
	// Represents an 'unpinned' event on a given issue or pull request.
	PullRequestTimelineItemsItemTypeUnpinnedEvent PullRequestTimelineItemsItemType = "UNPINNED_EVENT"
	// Represents an 'unsubscribed' event on a given `Subscribable`.
	PullRequestTimelineItemsItemTypeUnsubscribedEvent PullRequestTimelineItemsItemType = "UNSUBSCRIBED_EVENT"
)

var AllPullRequestTimelineItemsItemType = []PullRequestTimelineItemsItemType{
	PullRequestTimelineItemsItemTypePullRequestCommit,
	PullRequestTimelineItemsItemTypePullRequestCommitCommentThread,
	PullRequestTimelineItemsItemTypePullRequestReview,
	PullRequestTimelineItemsItemTypePullRequestReviewThread,
	PullRequestTimelineItemsItemTypePullRequestRevisionMarker,
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeFailedEvent,
	PullRequestTimelineItemsItemTypeAutomaticBaseChangeSucceededEvent,
	PullRequestTimelineItemsItemTypeAutoMergeDisabledEvent,
	PullRequestTimelineItemsItemTypeAutoMergeEnabledEvent,
	PullRequestTimelineItemsItemTypeAutoRebaseEnabledEvent,
	PullRequestTimelineItemsItemTypeAutoSquashEnabledEvent,
	PullRequestTimelineItemsItemTypeBaseRefChangedEvent,
	PullRequestTimelineItemsItemTypeBaseRefForcePushedEvent,
	PullRequestTimelineItemsItemTypeBaseRefDeletedEvent,
	PullRequestTimelineItemsItemTypeDeployedEvent,
	PullRequestTimelineItemsItemTypeDeploymentEnvironmentChangedEvent,
	PullRequestTimelineItemsItemTypeHeadRefDeletedEvent,
	PullRequestTimelineItemsItemTypeHeadRefForcePushedEvent,
	PullRequestTimelineItemsItemTypeHeadRefRestoredEvent,
	PullRequestTimelineItemsItemTypeMergedEvent,
	PullRequestTimelineItemsItemTypeReviewDismissedEvent,
	PullRequestTimelineItemsItemTypeReviewRequestedEvent,
	PullRequestTimelineItemsItemTypeReviewRequestRemovedEvent,
	PullRequestTimelineItemsItemTypeReadyForReviewEvent,
	PullRequestTimelineItemsItemTypeConvertToDraftEvent,
	PullRequestTimelineItemsItemTypeAddedToMergeQueueEvent,
	PullRequestTimelineItemsItemTypeRemovedFromMergeQueueEvent,
	PullRequestTimelineItemsItemTypeIssueComment,
	PullRequestTimelineItemsItemTypeCrossReferencedEvent,
	PullRequestTimelineItemsItemTypeAddedToProjectEvent,
	PullRequestTimelineItemsItemTypeAssignedEvent,
	PullRequestTimelineItemsItemTypeClosedEvent,
	PullRequestTimelineItemsItemTypeCommentDeletedEvent,
	PullRequestTimelineItemsItemTypeConnectedEvent,
	PullRequestTimelineItemsItemTypeConvertedNoteToIssueEvent,
	PullRequestTimelineItemsItemTypeConvertedToDiscussionEvent,
	PullRequestTimelineItemsItemTypeDemilestonedEvent,
	PullRequestTimelineItemsItemTypeDisconnectedEvent,
	PullRequestTimelineItemsItemTypeLabeledEvent,
	PullRequestTimelineItemsItemTypeLockedEvent,
	PullRequestTimelineItemsItemTypeMarkedAsDuplicateEvent,
	PullRequestTimelineItemsItemTypeMentionedEvent,
	PullRequestTimelineItemsItemTypeMilestonedEvent,
	PullRequestTimelineItemsItemTypeMovedColumnsInProjectEvent,
	PullRequestTimelineItemsItemTypePinnedEvent,
	PullRequestTimelineItemsItemTypeReferencedEvent,
	PullRequestTimelineItemsItemTypeRemovedFromProjectEvent,
	PullRequestTimelineItemsItemTypeRenamedTitleEvent,
	PullRequestTimelineItemsItemTypeReopenedEvent,
	PullRequestTimelineItemsItemTypeSubscribedEvent,
	PullRequestTimelineItemsItemTypeTransferredEvent,
	PullRequestTimelineItemsItemTypeUnassignedEvent,
	PullRequestTimelineItemsItemTypeUnlabeledEvent,
	PullRequestTimelineItemsItemTypeUnlockedEvent,
	PullRequestTimelineItemsItemTypeUserBlockedEvent,
	PullRequestTimelineItemsItemTypeUnmarkedAsDuplicateEvent,
	PullRequestTimelineItemsItemTypeUnpinnedEvent,
	PullRequestTimelineItemsItemTypeUnsubscribedEvent,
}

func (e PullRequestTimelineItemsItemType) IsValid() bool {
	switch e {
	case PullRequestTimelineItemsItemTypePullRequestCommit, PullRequestTimelineItemsItemTypePullRequestCommitCommentThread, PullRequestTimelineItemsItemTypePullRequestReview, PullRequestTimelineItemsItemTypePullRequestReviewThread, PullRequestTimelineItemsItemTypePullRequestRevisionMarker, PullRequestTimelineItemsItemTypeAutomaticBaseChangeFailedEvent, PullRequestTimelineItemsItemTypeAutomaticBaseChangeSucceededEvent, PullRequestTimelineItemsItemTypeAutoMergeDisabledEvent, PullRequestTimelineItemsItemTypeAutoMergeEnabledEvent, PullRequestTimelineItemsItemTypeAutoRebaseEnabledEvent, PullRequestTimelineItemsItemTypeAutoSquashEnabledEvent, PullRequestTimelineItemsItemTypeBaseRefChangedEvent, PullRequestTimelineItemsItemTypeBaseRefForcePushedEvent, PullRequestTimelineItemsItemTypeBaseRefDeletedEvent, PullRequestTimelineItemsItemTypeDeployedEvent, PullRequestTimelineItemsItemTypeDeploymentEnvironmentChangedEvent, PullRequestTimelineItemsItemTypeHeadRefDeletedEvent, PullRequestTimelineItemsItemTypeHeadRefForcePushedEvent, PullRequestTimelineItemsItemTypeHeadRefRestoredEvent, PullRequestTimelineItemsItemTypeMergedEvent, PullRequestTimelineItemsItemTypeReviewDismissedEvent, PullRequestTimelineItemsItemTypeReviewRequestedEvent, PullRequestTimelineItemsItemTypeReviewRequestRemovedEvent, PullRequestTimelineItemsItemTypeReadyForReviewEvent, PullRequestTimelineItemsItemTypeConvertToDraftEvent, PullRequestTimelineItemsItemTypeAddedToMergeQueueEvent, PullRequestTimelineItemsItemTypeRemovedFromMergeQueueEvent, PullRequestTimelineItemsItemTypeIssueComment, PullRequestTimelineItemsItemTypeCrossReferencedEvent, PullRequestTimelineItemsItemTypeAddedToProjectEvent, PullRequestTimelineItemsItemTypeAssignedEvent, PullRequestTimelineItemsItemTypeClosedEvent, PullRequestTimelineItemsItemTypeCommentDeletedEvent, PullRequestTimelineItemsItemTypeConnectedEvent, PullRequestTimelineItemsItemTypeConvertedNoteToIssueEvent, PullRequestTimelineItemsItemTypeConvertedToDiscussionEvent, PullRequestTimelineItemsItemTypeDemilestonedEvent, PullRequestTimelineItemsItemTypeDisconnectedEvent, PullRequestTimelineItemsItemTypeLabeledEvent, PullRequestTimelineItemsItemTypeLockedEvent, PullRequestTimelineItemsItemTypeMarkedAsDuplicateEvent, PullRequestTimelineItemsItemTypeMentionedEvent, PullRequestTimelineItemsItemTypeMilestonedEvent, PullRequestTimelineItemsItemTypeMovedColumnsInProjectEvent, PullRequestTimelineItemsItemTypePinnedEvent, PullRequestTimelineItemsItemTypeReferencedEvent, PullRequestTimelineItemsItemTypeRemovedFromProjectEvent, PullRequestTimelineItemsItemTypeRenamedTitleEvent, PullRequestTimelineItemsItemTypeReopenedEvent, PullRequestTimelineItemsItemTypeSubscribedEvent, PullRequestTimelineItemsItemTypeTransferredEvent, PullRequestTimelineItemsItemTypeUnassignedEvent, PullRequestTimelineItemsItemTypeUnlabeledEvent, PullRequestTimelineItemsItemTypeUnlockedEvent, PullRequestTimelineItemsItemTypeUserBlockedEvent, PullRequestTimelineItemsItemTypeUnmarkedAsDuplicateEvent, PullRequestTimelineItemsItemTypeUnpinnedEvent, PullRequestTimelineItemsItemTypeUnsubscribedEvent:
		return true
	}
	return false
}

func (e PullRequestTimelineItemsItemType) String() string {
	return string(e)
}

func (e *PullRequestTimelineItemsItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestTimelineItemsItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestTimelineItemsItemType", str)
	}
	return nil
}

func (e PullRequestTimelineItemsItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible target states when updating a pull request.
type PullRequestUpdateState string

const (
	// A pull request that is still open.
	PullRequestUpdateStateOpen PullRequestUpdateState = "OPEN"
	// A pull request that has been closed without being merged.
	PullRequestUpdateStateClosed PullRequestUpdateState = "CLOSED"
)

var AllPullRequestUpdateState = []PullRequestUpdateState{
	PullRequestUpdateStateOpen,
	PullRequestUpdateStateClosed,
}

func (e PullRequestUpdateState) IsValid() bool {
	switch e {
	case PullRequestUpdateStateOpen, PullRequestUpdateStateClosed:
		return true
	}
	return false
}

func (e PullRequestUpdateState) String() string {
	return string(e)
}

func (e *PullRequestUpdateState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PullRequestUpdateState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PullRequestUpdateState", str)
	}
	return nil
}

func (e PullRequestUpdateState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Emojis that can be attached to Issues, Pull Requests and Comments.
type ReactionContent string

const (
	// Represents the `:+1:` emoji.
	ReactionContentThumbsUp ReactionContent = "THUMBS_UP"
	// Represents the `:-1:` emoji.
	ReactionContentThumbsDown ReactionContent = "THUMBS_DOWN"
	// Represents the `:laugh:` emoji.
	ReactionContentLaugh ReactionContent = "LAUGH"
	// Represents the `:hooray:` emoji.
	ReactionContentHooray ReactionContent = "HOORAY"
	// Represents the `:confused:` emoji.
	ReactionContentConfused ReactionContent = "CONFUSED"
	// Represents the `:heart:` emoji.
	ReactionContentHeart ReactionContent = "HEART"
	// Represents the `:rocket:` emoji.
	ReactionContentRocket ReactionContent = "ROCKET"
	// Represents the `:eyes:` emoji.
	ReactionContentEyes ReactionContent = "EYES"
)

var AllReactionContent = []ReactionContent{
	ReactionContentThumbsUp,
	ReactionContentThumbsDown,
	ReactionContentLaugh,
	ReactionContentHooray,
	ReactionContentConfused,
	ReactionContentHeart,
	ReactionContentRocket,
	ReactionContentEyes,
}

func (e ReactionContent) IsValid() bool {
	switch e {
	case ReactionContentThumbsUp, ReactionContentThumbsDown, ReactionContentLaugh, ReactionContentHooray, ReactionContentConfused, ReactionContentHeart, ReactionContentRocket, ReactionContentEyes:
		return true
	}
	return false
}

func (e ReactionContent) String() string {
	return string(e)
}

func (e *ReactionContent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReactionContent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReactionContent", str)
	}
	return nil
}

func (e ReactionContent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A list of fields that reactions can be ordered by.
type ReactionOrderField string

const (
	// Allows ordering a list of reactions by when they were created.
	ReactionOrderFieldCreatedAt ReactionOrderField = "CREATED_AT"
)

var AllReactionOrderField = []ReactionOrderField{
	ReactionOrderFieldCreatedAt,
}

func (e ReactionOrderField) IsValid() bool {
	switch e {
	case ReactionOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e ReactionOrderField) String() string {
	return string(e)
}

func (e *ReactionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReactionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReactionOrderField", str)
	}
	return nil
}

func (e ReactionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ref connections can be ordered.
type RefOrderField string

const (
	// Order refs by underlying commit date if the ref prefix is refs/tags/
	RefOrderFieldTagCommitDate RefOrderField = "TAG_COMMIT_DATE"
	// Order refs by their alphanumeric name
	RefOrderFieldAlphabetical RefOrderField = "ALPHABETICAL"
)

var AllRefOrderField = []RefOrderField{
	RefOrderFieldTagCommitDate,
	RefOrderFieldAlphabetical,
}

func (e RefOrderField) IsValid() bool {
	switch e {
	case RefOrderFieldTagCommitDate, RefOrderFieldAlphabetical:
		return true
	}
	return false
}

func (e RefOrderField) String() string {
	return string(e)
}

func (e *RefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefOrderField", str)
	}
	return nil
}

func (e RefOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which release connections can be ordered.
type ReleaseOrderField string

const (
	// Order releases by creation time
	ReleaseOrderFieldCreatedAt ReleaseOrderField = "CREATED_AT"
	// Order releases alphabetically by name
	ReleaseOrderFieldName ReleaseOrderField = "NAME"
)

var AllReleaseOrderField = []ReleaseOrderField{
	ReleaseOrderFieldCreatedAt,
	ReleaseOrderFieldName,
}

func (e ReleaseOrderField) IsValid() bool {
	switch e {
	case ReleaseOrderFieldCreatedAt, ReleaseOrderFieldName:
		return true
	}
	return false
}

func (e ReleaseOrderField) String() string {
	return string(e)
}

func (e *ReleaseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReleaseOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReleaseOrderField", str)
	}
	return nil
}

func (e ReleaseOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoAccessAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoAccessAuditEntryVisibilityInternal RepoAccessAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoAccessAuditEntryVisibilityPrivate RepoAccessAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoAccessAuditEntryVisibilityPublic RepoAccessAuditEntryVisibility = "PUBLIC"
)

var AllRepoAccessAuditEntryVisibility = []RepoAccessAuditEntryVisibility{
	RepoAccessAuditEntryVisibilityInternal,
	RepoAccessAuditEntryVisibilityPrivate,
	RepoAccessAuditEntryVisibilityPublic,
}

func (e RepoAccessAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoAccessAuditEntryVisibilityInternal, RepoAccessAuditEntryVisibilityPrivate, RepoAccessAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoAccessAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoAccessAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoAccessAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoAccessAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoAccessAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoAddMemberAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoAddMemberAuditEntryVisibilityInternal RepoAddMemberAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoAddMemberAuditEntryVisibilityPrivate RepoAddMemberAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoAddMemberAuditEntryVisibilityPublic RepoAddMemberAuditEntryVisibility = "PUBLIC"
)

var AllRepoAddMemberAuditEntryVisibility = []RepoAddMemberAuditEntryVisibility{
	RepoAddMemberAuditEntryVisibilityInternal,
	RepoAddMemberAuditEntryVisibilityPrivate,
	RepoAddMemberAuditEntryVisibilityPublic,
}

func (e RepoAddMemberAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoAddMemberAuditEntryVisibilityInternal, RepoAddMemberAuditEntryVisibilityPrivate, RepoAddMemberAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoAddMemberAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoAddMemberAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoAddMemberAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoAddMemberAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoAddMemberAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoArchivedAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoArchivedAuditEntryVisibilityInternal RepoArchivedAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoArchivedAuditEntryVisibilityPrivate RepoArchivedAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoArchivedAuditEntryVisibilityPublic RepoArchivedAuditEntryVisibility = "PUBLIC"
)

var AllRepoArchivedAuditEntryVisibility = []RepoArchivedAuditEntryVisibility{
	RepoArchivedAuditEntryVisibilityInternal,
	RepoArchivedAuditEntryVisibilityPrivate,
	RepoArchivedAuditEntryVisibilityPublic,
}

func (e RepoArchivedAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoArchivedAuditEntryVisibilityInternal, RepoArchivedAuditEntryVisibilityPrivate, RepoArchivedAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoArchivedAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoArchivedAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoArchivedAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoArchivedAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoArchivedAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The merge options available for pull requests to this repository.
type RepoChangeMergeSettingAuditEntryMergeType string

const (
	// The pull request is added to the base branch in a merge commit.
	RepoChangeMergeSettingAuditEntryMergeTypeMerge RepoChangeMergeSettingAuditEntryMergeType = "MERGE"
	// Commits from the pull request are added onto the base branch individually without a merge commit.
	RepoChangeMergeSettingAuditEntryMergeTypeRebase RepoChangeMergeSettingAuditEntryMergeType = "REBASE"
	// The pull request's commits are squashed into a single commit before they are merged to the base branch.
	RepoChangeMergeSettingAuditEntryMergeTypeSquash RepoChangeMergeSettingAuditEntryMergeType = "SQUASH"
)

var AllRepoChangeMergeSettingAuditEntryMergeType = []RepoChangeMergeSettingAuditEntryMergeType{
	RepoChangeMergeSettingAuditEntryMergeTypeMerge,
	RepoChangeMergeSettingAuditEntryMergeTypeRebase,
	RepoChangeMergeSettingAuditEntryMergeTypeSquash,
}

func (e RepoChangeMergeSettingAuditEntryMergeType) IsValid() bool {
	switch e {
	case RepoChangeMergeSettingAuditEntryMergeTypeMerge, RepoChangeMergeSettingAuditEntryMergeTypeRebase, RepoChangeMergeSettingAuditEntryMergeTypeSquash:
		return true
	}
	return false
}

func (e RepoChangeMergeSettingAuditEntryMergeType) String() string {
	return string(e)
}

func (e *RepoChangeMergeSettingAuditEntryMergeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoChangeMergeSettingAuditEntryMergeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoChangeMergeSettingAuditEntryMergeType", str)
	}
	return nil
}

func (e RepoChangeMergeSettingAuditEntryMergeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoCreateAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoCreateAuditEntryVisibilityInternal RepoCreateAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoCreateAuditEntryVisibilityPrivate RepoCreateAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoCreateAuditEntryVisibilityPublic RepoCreateAuditEntryVisibility = "PUBLIC"
)

var AllRepoCreateAuditEntryVisibility = []RepoCreateAuditEntryVisibility{
	RepoCreateAuditEntryVisibilityInternal,
	RepoCreateAuditEntryVisibilityPrivate,
	RepoCreateAuditEntryVisibilityPublic,
}

func (e RepoCreateAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoCreateAuditEntryVisibilityInternal, RepoCreateAuditEntryVisibilityPrivate, RepoCreateAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoCreateAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoCreateAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoCreateAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoCreateAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoCreateAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoDestroyAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoDestroyAuditEntryVisibilityInternal RepoDestroyAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoDestroyAuditEntryVisibilityPrivate RepoDestroyAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoDestroyAuditEntryVisibilityPublic RepoDestroyAuditEntryVisibility = "PUBLIC"
)

var AllRepoDestroyAuditEntryVisibility = []RepoDestroyAuditEntryVisibility{
	RepoDestroyAuditEntryVisibilityInternal,
	RepoDestroyAuditEntryVisibilityPrivate,
	RepoDestroyAuditEntryVisibilityPublic,
}

func (e RepoDestroyAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoDestroyAuditEntryVisibilityInternal, RepoDestroyAuditEntryVisibilityPrivate, RepoDestroyAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoDestroyAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoDestroyAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoDestroyAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoDestroyAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoDestroyAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepoRemoveMemberAuditEntryVisibility string

const (
	// The repository is visible only to users in the same business.
	RepoRemoveMemberAuditEntryVisibilityInternal RepoRemoveMemberAuditEntryVisibility = "INTERNAL"
	// The repository is visible only to those with explicit access.
	RepoRemoveMemberAuditEntryVisibilityPrivate RepoRemoveMemberAuditEntryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepoRemoveMemberAuditEntryVisibilityPublic RepoRemoveMemberAuditEntryVisibility = "PUBLIC"
)

var AllRepoRemoveMemberAuditEntryVisibility = []RepoRemoveMemberAuditEntryVisibility{
	RepoRemoveMemberAuditEntryVisibilityInternal,
	RepoRemoveMemberAuditEntryVisibilityPrivate,
	RepoRemoveMemberAuditEntryVisibilityPublic,
}

func (e RepoRemoveMemberAuditEntryVisibility) IsValid() bool {
	switch e {
	case RepoRemoveMemberAuditEntryVisibilityInternal, RepoRemoveMemberAuditEntryVisibilityPrivate, RepoRemoveMemberAuditEntryVisibilityPublic:
		return true
	}
	return false
}

func (e RepoRemoveMemberAuditEntryVisibility) String() string {
	return string(e)
}

func (e *RepoRemoveMemberAuditEntryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepoRemoveMemberAuditEntryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepoRemoveMemberAuditEntryVisibility", str)
	}
	return nil
}

func (e RepoRemoveMemberAuditEntryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reasons a piece of content can be reported or minimized.
type ReportedContentClassifiers string

const (
	// A spammy piece of content
	ReportedContentClassifiersSpam ReportedContentClassifiers = "SPAM"
	// An abusive or harassing piece of content
	ReportedContentClassifiersAbuse ReportedContentClassifiers = "ABUSE"
	// An irrelevant piece of content
	ReportedContentClassifiersOffTopic ReportedContentClassifiers = "OFF_TOPIC"
	// An outdated piece of content
	ReportedContentClassifiersOutdated ReportedContentClassifiers = "OUTDATED"
	// A duplicated piece of content
	ReportedContentClassifiersDuplicate ReportedContentClassifiers = "DUPLICATE"
	// The content has been resolved
	ReportedContentClassifiersResolved ReportedContentClassifiers = "RESOLVED"
)

var AllReportedContentClassifiers = []ReportedContentClassifiers{
	ReportedContentClassifiersSpam,
	ReportedContentClassifiersAbuse,
	ReportedContentClassifiersOffTopic,
	ReportedContentClassifiersOutdated,
	ReportedContentClassifiersDuplicate,
	ReportedContentClassifiersResolved,
}

func (e ReportedContentClassifiers) IsValid() bool {
	switch e {
	case ReportedContentClassifiersSpam, ReportedContentClassifiersAbuse, ReportedContentClassifiersOffTopic, ReportedContentClassifiersOutdated, ReportedContentClassifiersDuplicate, ReportedContentClassifiersResolved:
		return true
	}
	return false
}

func (e ReportedContentClassifiers) String() string {
	return string(e)
}

func (e *ReportedContentClassifiers) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportedContentClassifiers(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportedContentClassifiers", str)
	}
	return nil
}

func (e ReportedContentClassifiers) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The affiliation of a user to a repository
type RepositoryAffiliation string

const (
	// Repositories that are owned by the authenticated user.
	RepositoryAffiliationOwner RepositoryAffiliation = "OWNER"
	// Repositories that the user has been added to as a collaborator.
	RepositoryAffiliationCollaborator RepositoryAffiliation = "COLLABORATOR"
	// Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
	RepositoryAffiliationOrganizationMember RepositoryAffiliation = "ORGANIZATION_MEMBER"
)

var AllRepositoryAffiliation = []RepositoryAffiliation{
	RepositoryAffiliationOwner,
	RepositoryAffiliationCollaborator,
	RepositoryAffiliationOrganizationMember,
}

func (e RepositoryAffiliation) IsValid() bool {
	switch e {
	case RepositoryAffiliationOwner, RepositoryAffiliationCollaborator, RepositoryAffiliationOrganizationMember:
		return true
	}
	return false
}

func (e RepositoryAffiliation) String() string {
	return string(e)
}

func (e *RepositoryAffiliation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryAffiliation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryAffiliation", str)
	}
	return nil
}

func (e RepositoryAffiliation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason a repository is listed as 'contributed'.
type RepositoryContributionType string

const (
	// Created a commit
	RepositoryContributionTypeCommit RepositoryContributionType = "COMMIT"
	// Created an issue
	RepositoryContributionTypeIssue RepositoryContributionType = "ISSUE"
	// Created a pull request
	RepositoryContributionTypePullRequest RepositoryContributionType = "PULL_REQUEST"
	// Created the repository
	RepositoryContributionTypeRepository RepositoryContributionType = "REPOSITORY"
	// Reviewed a pull request
	RepositoryContributionTypePullRequestReview RepositoryContributionType = "PULL_REQUEST_REVIEW"
)

var AllRepositoryContributionType = []RepositoryContributionType{
	RepositoryContributionTypeCommit,
	RepositoryContributionTypeIssue,
	RepositoryContributionTypePullRequest,
	RepositoryContributionTypeRepository,
	RepositoryContributionTypePullRequestReview,
}

func (e RepositoryContributionType) IsValid() bool {
	switch e {
	case RepositoryContributionTypeCommit, RepositoryContributionTypeIssue, RepositoryContributionTypePullRequest, RepositoryContributionTypeRepository, RepositoryContributionTypePullRequestReview:
		return true
	}
	return false
}

func (e RepositoryContributionType) String() string {
	return string(e)
}

func (e *RepositoryContributionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryContributionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryContributionType", str)
	}
	return nil
}

func (e RepositoryContributionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A repository interaction limit.
type RepositoryInteractionLimit string

const (
	// Users that have recently created their account will be unable to interact with the repository.
	RepositoryInteractionLimitExistingUsers RepositoryInteractionLimit = "EXISTING_USERS"
	// Users that have not previously committed to a repositorys default branch will be unable to interact with the repository.
	RepositoryInteractionLimitContributorsOnly RepositoryInteractionLimit = "CONTRIBUTORS_ONLY"
	// Users that are not collaborators will not be able to interact with the repository.
	RepositoryInteractionLimitCollaboratorsOnly RepositoryInteractionLimit = "COLLABORATORS_ONLY"
	// No interaction limits are enabled.
	RepositoryInteractionLimitNoLimit RepositoryInteractionLimit = "NO_LIMIT"
)

var AllRepositoryInteractionLimit = []RepositoryInteractionLimit{
	RepositoryInteractionLimitExistingUsers,
	RepositoryInteractionLimitContributorsOnly,
	RepositoryInteractionLimitCollaboratorsOnly,
	RepositoryInteractionLimitNoLimit,
}

func (e RepositoryInteractionLimit) IsValid() bool {
	switch e {
	case RepositoryInteractionLimitExistingUsers, RepositoryInteractionLimitContributorsOnly, RepositoryInteractionLimitCollaboratorsOnly, RepositoryInteractionLimitNoLimit:
		return true
	}
	return false
}

func (e RepositoryInteractionLimit) String() string {
	return string(e)
}

func (e *RepositoryInteractionLimit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryInteractionLimit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryInteractionLimit", str)
	}
	return nil
}

func (e RepositoryInteractionLimit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The length for a repository interaction limit to be enabled for.
type RepositoryInteractionLimitExpiry string

const (
	// The interaction limit will expire after 1 day.
	RepositoryInteractionLimitExpiryOneDay RepositoryInteractionLimitExpiry = "ONE_DAY"
	// The interaction limit will expire after 3 days.
	RepositoryInteractionLimitExpiryThreeDays RepositoryInteractionLimitExpiry = "THREE_DAYS"
	// The interaction limit will expire after 1 week.
	RepositoryInteractionLimitExpiryOneWeek RepositoryInteractionLimitExpiry = "ONE_WEEK"
	// The interaction limit will expire after 1 month.
	RepositoryInteractionLimitExpiryOneMonth RepositoryInteractionLimitExpiry = "ONE_MONTH"
	// The interaction limit will expire after 6 months.
	RepositoryInteractionLimitExpirySixMonths RepositoryInteractionLimitExpiry = "SIX_MONTHS"
)

var AllRepositoryInteractionLimitExpiry = []RepositoryInteractionLimitExpiry{
	RepositoryInteractionLimitExpiryOneDay,
	RepositoryInteractionLimitExpiryThreeDays,
	RepositoryInteractionLimitExpiryOneWeek,
	RepositoryInteractionLimitExpiryOneMonth,
	RepositoryInteractionLimitExpirySixMonths,
}

func (e RepositoryInteractionLimitExpiry) IsValid() bool {
	switch e {
	case RepositoryInteractionLimitExpiryOneDay, RepositoryInteractionLimitExpiryThreeDays, RepositoryInteractionLimitExpiryOneWeek, RepositoryInteractionLimitExpiryOneMonth, RepositoryInteractionLimitExpirySixMonths:
		return true
	}
	return false
}

func (e RepositoryInteractionLimitExpiry) String() string {
	return string(e)
}

func (e *RepositoryInteractionLimitExpiry) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryInteractionLimitExpiry(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryInteractionLimitExpiry", str)
	}
	return nil
}

func (e RepositoryInteractionLimitExpiry) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates where an interaction limit is configured.
type RepositoryInteractionLimitOrigin string

const (
	// A limit that is configured at the repository level.
	RepositoryInteractionLimitOriginRepository RepositoryInteractionLimitOrigin = "REPOSITORY"
	// A limit that is configured at the organization level.
	RepositoryInteractionLimitOriginOrganization RepositoryInteractionLimitOrigin = "ORGANIZATION"
	// A limit that is configured at the user-wide level.
	RepositoryInteractionLimitOriginUser RepositoryInteractionLimitOrigin = "USER"
)

var AllRepositoryInteractionLimitOrigin = []RepositoryInteractionLimitOrigin{
	RepositoryInteractionLimitOriginRepository,
	RepositoryInteractionLimitOriginOrganization,
	RepositoryInteractionLimitOriginUser,
}

func (e RepositoryInteractionLimitOrigin) IsValid() bool {
	switch e {
	case RepositoryInteractionLimitOriginRepository, RepositoryInteractionLimitOriginOrganization, RepositoryInteractionLimitOriginUser:
		return true
	}
	return false
}

func (e RepositoryInteractionLimitOrigin) String() string {
	return string(e)
}

func (e *RepositoryInteractionLimitOrigin) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryInteractionLimitOrigin(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryInteractionLimitOrigin", str)
	}
	return nil
}

func (e RepositoryInteractionLimitOrigin) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which repository invitation connections can be ordered.
type RepositoryInvitationOrderField string

const (
	// Order repository invitations by creation time
	RepositoryInvitationOrderFieldCreatedAt RepositoryInvitationOrderField = "CREATED_AT"
)

var AllRepositoryInvitationOrderField = []RepositoryInvitationOrderField{
	RepositoryInvitationOrderFieldCreatedAt,
}

func (e RepositoryInvitationOrderField) IsValid() bool {
	switch e {
	case RepositoryInvitationOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e RepositoryInvitationOrderField) String() string {
	return string(e)
}

func (e *RepositoryInvitationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryInvitationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryInvitationOrderField", str)
	}
	return nil
}

func (e RepositoryInvitationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible reasons a given repository could be in a locked state.
type RepositoryLockReason string

const (
	// The repository is locked due to a move.
	RepositoryLockReasonMoving RepositoryLockReason = "MOVING"
	// The repository is locked due to a billing related reason.
	RepositoryLockReasonBilling RepositoryLockReason = "BILLING"
	// The repository is locked due to a rename.
	RepositoryLockReasonRename RepositoryLockReason = "RENAME"
	// The repository is locked due to a migration.
	RepositoryLockReasonMigrating RepositoryLockReason = "MIGRATING"
	// The repository is locked due to a trade controls related reason.
	RepositoryLockReasonTradeRestriction RepositoryLockReason = "TRADE_RESTRICTION"
	// The repository is locked due to an ownership transfer.
	RepositoryLockReasonTransferringOwnership RepositoryLockReason = "TRANSFERRING_OWNERSHIP"
)

var AllRepositoryLockReason = []RepositoryLockReason{
	RepositoryLockReasonMoving,
	RepositoryLockReasonBilling,
	RepositoryLockReasonRename,
	RepositoryLockReasonMigrating,
	RepositoryLockReasonTradeRestriction,
	RepositoryLockReasonTransferringOwnership,
}

func (e RepositoryLockReason) IsValid() bool {
	switch e {
	case RepositoryLockReasonMoving, RepositoryLockReasonBilling, RepositoryLockReasonRename, RepositoryLockReasonMigrating, RepositoryLockReasonTradeRestriction, RepositoryLockReasonTransferringOwnership:
		return true
	}
	return false
}

func (e RepositoryLockReason) String() string {
	return string(e)
}

func (e *RepositoryLockReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryLockReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryLockReason", str)
	}
	return nil
}

func (e RepositoryLockReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of repository migrations when provided an `orderBy` argument.
type RepositoryMigrationOrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	RepositoryMigrationOrderDirectionAsc RepositoryMigrationOrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	RepositoryMigrationOrderDirectionDesc RepositoryMigrationOrderDirection = "DESC"
)

var AllRepositoryMigrationOrderDirection = []RepositoryMigrationOrderDirection{
	RepositoryMigrationOrderDirectionAsc,
	RepositoryMigrationOrderDirectionDesc,
}

func (e RepositoryMigrationOrderDirection) IsValid() bool {
	switch e {
	case RepositoryMigrationOrderDirectionAsc, RepositoryMigrationOrderDirectionDesc:
		return true
	}
	return false
}

func (e RepositoryMigrationOrderDirection) String() string {
	return string(e)
}

func (e *RepositoryMigrationOrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryMigrationOrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryMigrationOrderDirection", str)
	}
	return nil
}

func (e RepositoryMigrationOrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which repository migrations can be ordered.
type RepositoryMigrationOrderField string

const (
	// Order mannequins why when they were created.
	RepositoryMigrationOrderFieldCreatedAt RepositoryMigrationOrderField = "CREATED_AT"
)

var AllRepositoryMigrationOrderField = []RepositoryMigrationOrderField{
	RepositoryMigrationOrderFieldCreatedAt,
}

func (e RepositoryMigrationOrderField) IsValid() bool {
	switch e {
	case RepositoryMigrationOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e RepositoryMigrationOrderField) String() string {
	return string(e)
}

func (e *RepositoryMigrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryMigrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryMigrationOrderField", str)
	}
	return nil
}

func (e RepositoryMigrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which repository connections can be ordered.
type RepositoryOrderField string

const (
	// Order repositories by creation time
	RepositoryOrderFieldCreatedAt RepositoryOrderField = "CREATED_AT"
	// Order repositories by update time
	RepositoryOrderFieldUpdatedAt RepositoryOrderField = "UPDATED_AT"
	// Order repositories by push time
	RepositoryOrderFieldPushedAt RepositoryOrderField = "PUSHED_AT"
	// Order repositories by name
	RepositoryOrderFieldName RepositoryOrderField = "NAME"
	// Order repositories by number of stargazers
	RepositoryOrderFieldStargazers RepositoryOrderField = "STARGAZERS"
)

var AllRepositoryOrderField = []RepositoryOrderField{
	RepositoryOrderFieldCreatedAt,
	RepositoryOrderFieldUpdatedAt,
	RepositoryOrderFieldPushedAt,
	RepositoryOrderFieldName,
	RepositoryOrderFieldStargazers,
}

func (e RepositoryOrderField) IsValid() bool {
	switch e {
	case RepositoryOrderFieldCreatedAt, RepositoryOrderFieldUpdatedAt, RepositoryOrderFieldPushedAt, RepositoryOrderFieldName, RepositoryOrderFieldStargazers:
		return true
	}
	return false
}

func (e RepositoryOrderField) String() string {
	return string(e)
}

func (e *RepositoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryOrderField", str)
	}
	return nil
}

func (e RepositoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The access level to a repository
type RepositoryPermission string

const (
	// Can read, clone, and push to this repository. Can also manage issues, pull requests, and repository settings, including adding collaborators
	RepositoryPermissionAdmin RepositoryPermission = "ADMIN"
	// Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings
	RepositoryPermissionMaintain RepositoryPermission = "MAINTAIN"
	// Can read, clone, and push to this repository. Can also manage issues and pull requests
	RepositoryPermissionWrite RepositoryPermission = "WRITE"
	// Can read and clone this repository. Can also manage issues and pull requests
	RepositoryPermissionTriage RepositoryPermission = "TRIAGE"
	// Can read and clone this repository. Can also open and comment on issues and pull requests
	RepositoryPermissionRead RepositoryPermission = "READ"
)

var AllRepositoryPermission = []RepositoryPermission{
	RepositoryPermissionAdmin,
	RepositoryPermissionMaintain,
	RepositoryPermissionWrite,
	RepositoryPermissionTriage,
	RepositoryPermissionRead,
}

func (e RepositoryPermission) IsValid() bool {
	switch e {
	case RepositoryPermissionAdmin, RepositoryPermissionMaintain, RepositoryPermissionWrite, RepositoryPermissionTriage, RepositoryPermissionRead:
		return true
	}
	return false
}

func (e RepositoryPermission) String() string {
	return string(e)
}

func (e *RepositoryPermission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryPermission", str)
	}
	return nil
}

func (e RepositoryPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a repository
type RepositoryPrivacy string

const (
	// Public
	RepositoryPrivacyPublic RepositoryPrivacy = "PUBLIC"
	// Private
	RepositoryPrivacyPrivate RepositoryPrivacy = "PRIVATE"
)

var AllRepositoryPrivacy = []RepositoryPrivacy{
	RepositoryPrivacyPublic,
	RepositoryPrivacyPrivate,
}

func (e RepositoryPrivacy) IsValid() bool {
	switch e {
	case RepositoryPrivacyPublic, RepositoryPrivacyPrivate:
		return true
	}
	return false
}

func (e RepositoryPrivacy) String() string {
	return string(e)
}

func (e *RepositoryPrivacy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryPrivacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryPrivacy", str)
	}
	return nil
}

func (e RepositoryPrivacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which repository rule connections can be ordered.
type RepositoryRuleOrderField string

const (
	// Order repository rules by updated time
	RepositoryRuleOrderFieldUpdatedAt RepositoryRuleOrderField = "UPDATED_AT"
	// Order repository rules by created time
	RepositoryRuleOrderFieldCreatedAt RepositoryRuleOrderField = "CREATED_AT"
	// Order repository rules by type
	RepositoryRuleOrderFieldType RepositoryRuleOrderField = "TYPE"
)

var AllRepositoryRuleOrderField = []RepositoryRuleOrderField{
	RepositoryRuleOrderFieldUpdatedAt,
	RepositoryRuleOrderFieldCreatedAt,
	RepositoryRuleOrderFieldType,
}

func (e RepositoryRuleOrderField) IsValid() bool {
	switch e {
	case RepositoryRuleOrderFieldUpdatedAt, RepositoryRuleOrderFieldCreatedAt, RepositoryRuleOrderFieldType:
		return true
	}
	return false
}

func (e RepositoryRuleOrderField) String() string {
	return string(e)
}

func (e *RepositoryRuleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryRuleOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryRuleOrderField", str)
	}
	return nil
}

func (e RepositoryRuleOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The rule types supported in rulesets
type RepositoryRuleType string

const (
	// Only allow users with bypass permission to create matching refs.
	RepositoryRuleTypeCreation RepositoryRuleType = "CREATION"
	// Only allow users with bypass permission to update matching refs.
	RepositoryRuleTypeUpdate RepositoryRuleType = "UPDATE"
	// Only allow users with bypass permissions to delete matching refs.
	RepositoryRuleTypeDeletion RepositoryRuleType = "DELETION"
	// Prevent merge commits from being pushed to matching refs.
	RepositoryRuleTypeRequiredLinearHistory RepositoryRuleType = "REQUIRED_LINEAR_HISTORY"
	// Merges must be performed via a merge queue.
	RepositoryRuleTypeMergeQueue RepositoryRuleType = "MERGE_QUEUE"
	// When enabled, all conversations on code must be resolved before a pull request can be merged into a branch that matches this rule.
	RepositoryRuleTypeRequiredReviewThreadResolution RepositoryRuleType = "REQUIRED_REVIEW_THREAD_RESOLUTION"
	// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
	RepositoryRuleTypeRequiredDeployments RepositoryRuleType = "REQUIRED_DEPLOYMENTS"
	// Commits pushed to matching refs must have verified signatures.
	RepositoryRuleTypeRequiredSignatures RepositoryRuleType = "REQUIRED_SIGNATURES"
	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	RepositoryRuleTypePullRequest RepositoryRuleType = "PULL_REQUEST"
	// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
	RepositoryRuleTypeRequiredStatusChecks RepositoryRuleType = "REQUIRED_STATUS_CHECKS"
	// Require all commits be made to a non-target branch and submitted via a pull request and required workflow checks to pass before they can be merged.
	RepositoryRuleTypeRequiredWorkflowStatusChecks RepositoryRuleType = "REQUIRED_WORKFLOW_STATUS_CHECKS"
	// Prevent users with push access from force pushing to refs.
	RepositoryRuleTypeNonFastForward RepositoryRuleType = "NON_FAST_FORWARD"
	// Authorization
	RepositoryRuleTypeAuthorization RepositoryRuleType = "AUTHORIZATION"
	// Tag
	RepositoryRuleTypeTag RepositoryRuleType = "TAG"
	// Merge queue locked ref
	RepositoryRuleTypeMergeQueueLockedRef RepositoryRuleType = "MERGE_QUEUE_LOCKED_REF"
	// Branch is read-only. Users cannot push to the branch.
	RepositoryRuleTypeLockBranch RepositoryRuleType = "LOCK_BRANCH"
	// Max ref updates
	RepositoryRuleTypeMaxRefUpdates RepositoryRuleType = "MAX_REF_UPDATES"
	// Commit message pattern
	RepositoryRuleTypeCommitMessagePattern RepositoryRuleType = "COMMIT_MESSAGE_PATTERN"
	// Commit author email pattern
	RepositoryRuleTypeCommitAuthorEmailPattern RepositoryRuleType = "COMMIT_AUTHOR_EMAIL_PATTERN"
	// Committer email pattern
	RepositoryRuleTypeCommitterEmailPattern RepositoryRuleType = "COMMITTER_EMAIL_PATTERN"
	// Branch name pattern
	RepositoryRuleTypeBranchNamePattern RepositoryRuleType = "BRANCH_NAME_PATTERN"
	// Tag name pattern
	RepositoryRuleTypeTagNamePattern RepositoryRuleType = "TAG_NAME_PATTERN"
	// Prevent commits that include changes in specified file paths from being pushed to the commit graph.
	RepositoryRuleTypeFilePathRestriction RepositoryRuleType = "FILE_PATH_RESTRICTION"
	// Prevent commits that include file paths that exceed a specified character limit from being pushed to the commit graph.
	RepositoryRuleTypeMaxFilePathLength RepositoryRuleType = "MAX_FILE_PATH_LENGTH"
	// Prevent commits that include files with specified file extensions from being pushed to the commit graph.
	RepositoryRuleTypeFileExtensionRestriction RepositoryRuleType = "FILE_EXTENSION_RESTRICTION"
	// Prevent commits that exceed a specified file size limit from being pushed to the commit.
	RepositoryRuleTypeMaxFileSize RepositoryRuleType = "MAX_FILE_SIZE"
	// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
	RepositoryRuleTypeWorkflows RepositoryRuleType = "WORKFLOWS"
	// Secret scanning
	RepositoryRuleTypeSecretScanning RepositoryRuleType = "SECRET_SCANNING"
	// Workflow files cannot be modified.
	RepositoryRuleTypeWorkflowUpdates RepositoryRuleType = "WORKFLOW_UPDATES"
	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	RepositoryRuleTypeCodeScanning RepositoryRuleType = "CODE_SCANNING"
)

var AllRepositoryRuleType = []RepositoryRuleType{
	RepositoryRuleTypeCreation,
	RepositoryRuleTypeUpdate,
	RepositoryRuleTypeDeletion,
	RepositoryRuleTypeRequiredLinearHistory,
	RepositoryRuleTypeMergeQueue,
	RepositoryRuleTypeRequiredReviewThreadResolution,
	RepositoryRuleTypeRequiredDeployments,
	RepositoryRuleTypeRequiredSignatures,
	RepositoryRuleTypePullRequest,
	RepositoryRuleTypeRequiredStatusChecks,
	RepositoryRuleTypeRequiredWorkflowStatusChecks,
	RepositoryRuleTypeNonFastForward,
	RepositoryRuleTypeAuthorization,
	RepositoryRuleTypeTag,
	RepositoryRuleTypeMergeQueueLockedRef,
	RepositoryRuleTypeLockBranch,
	RepositoryRuleTypeMaxRefUpdates,
	RepositoryRuleTypeCommitMessagePattern,
	RepositoryRuleTypeCommitAuthorEmailPattern,
	RepositoryRuleTypeCommitterEmailPattern,
	RepositoryRuleTypeBranchNamePattern,
	RepositoryRuleTypeTagNamePattern,
	RepositoryRuleTypeFilePathRestriction,
	RepositoryRuleTypeMaxFilePathLength,
	RepositoryRuleTypeFileExtensionRestriction,
	RepositoryRuleTypeMaxFileSize,
	RepositoryRuleTypeWorkflows,
	RepositoryRuleTypeSecretScanning,
	RepositoryRuleTypeWorkflowUpdates,
	RepositoryRuleTypeCodeScanning,
}

func (e RepositoryRuleType) IsValid() bool {
	switch e {
	case RepositoryRuleTypeCreation, RepositoryRuleTypeUpdate, RepositoryRuleTypeDeletion, RepositoryRuleTypeRequiredLinearHistory, RepositoryRuleTypeMergeQueue, RepositoryRuleTypeRequiredReviewThreadResolution, RepositoryRuleTypeRequiredDeployments, RepositoryRuleTypeRequiredSignatures, RepositoryRuleTypePullRequest, RepositoryRuleTypeRequiredStatusChecks, RepositoryRuleTypeRequiredWorkflowStatusChecks, RepositoryRuleTypeNonFastForward, RepositoryRuleTypeAuthorization, RepositoryRuleTypeTag, RepositoryRuleTypeMergeQueueLockedRef, RepositoryRuleTypeLockBranch, RepositoryRuleTypeMaxRefUpdates, RepositoryRuleTypeCommitMessagePattern, RepositoryRuleTypeCommitAuthorEmailPattern, RepositoryRuleTypeCommitterEmailPattern, RepositoryRuleTypeBranchNamePattern, RepositoryRuleTypeTagNamePattern, RepositoryRuleTypeFilePathRestriction, RepositoryRuleTypeMaxFilePathLength, RepositoryRuleTypeFileExtensionRestriction, RepositoryRuleTypeMaxFileSize, RepositoryRuleTypeWorkflows, RepositoryRuleTypeSecretScanning, RepositoryRuleTypeWorkflowUpdates, RepositoryRuleTypeCodeScanning:
		return true
	}
	return false
}

func (e RepositoryRuleType) String() string {
	return string(e)
}

func (e *RepositoryRuleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryRuleType", str)
	}
	return nil
}

func (e RepositoryRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The bypass mode for a specific actor on a ruleset.
type RepositoryRulesetBypassActorBypassMode string

const (
	// The actor can always bypass rules
	RepositoryRulesetBypassActorBypassModeAlways RepositoryRulesetBypassActorBypassMode = "ALWAYS"
	// The actor can only bypass rules via a pull request
	RepositoryRulesetBypassActorBypassModePullRequest RepositoryRulesetBypassActorBypassMode = "PULL_REQUEST"
)

var AllRepositoryRulesetBypassActorBypassMode = []RepositoryRulesetBypassActorBypassMode{
	RepositoryRulesetBypassActorBypassModeAlways,
	RepositoryRulesetBypassActorBypassModePullRequest,
}

func (e RepositoryRulesetBypassActorBypassMode) IsValid() bool {
	switch e {
	case RepositoryRulesetBypassActorBypassModeAlways, RepositoryRulesetBypassActorBypassModePullRequest:
		return true
	}
	return false
}

func (e RepositoryRulesetBypassActorBypassMode) String() string {
	return string(e)
}

func (e *RepositoryRulesetBypassActorBypassMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryRulesetBypassActorBypassMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryRulesetBypassActorBypassMode", str)
	}
	return nil
}

func (e RepositoryRulesetBypassActorBypassMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The targets supported for rulesets.
type RepositoryRulesetTarget string

const (
	// Branch
	RepositoryRulesetTargetBranch RepositoryRulesetTarget = "BRANCH"
	// Tag
	RepositoryRulesetTargetTag RepositoryRulesetTarget = "TAG"
	// Push
	RepositoryRulesetTargetPush RepositoryRulesetTarget = "PUSH"
)

var AllRepositoryRulesetTarget = []RepositoryRulesetTarget{
	RepositoryRulesetTargetBranch,
	RepositoryRulesetTargetTag,
	RepositoryRulesetTargetPush,
}

func (e RepositoryRulesetTarget) IsValid() bool {
	switch e {
	case RepositoryRulesetTargetBranch, RepositoryRulesetTargetTag, RepositoryRulesetTargetPush:
		return true
	}
	return false
}

func (e RepositoryRulesetTarget) String() string {
	return string(e)
}

func (e *RepositoryRulesetTarget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryRulesetTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryRulesetTarget", str)
	}
	return nil
}

func (e RepositoryRulesetTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The repository's visibility level.
type RepositoryVisibility string

const (
	// The repository is visible only to those with explicit access.
	RepositoryVisibilityPrivate RepositoryVisibility = "PRIVATE"
	// The repository is visible to everyone.
	RepositoryVisibilityPublic RepositoryVisibility = "PUBLIC"
	// The repository is visible only to users in the same business.
	RepositoryVisibilityInternal RepositoryVisibility = "INTERNAL"
)

var AllRepositoryVisibility = []RepositoryVisibility{
	RepositoryVisibilityPrivate,
	RepositoryVisibilityPublic,
	RepositoryVisibilityInternal,
}

func (e RepositoryVisibility) IsValid() bool {
	switch e {
	case RepositoryVisibilityPrivate, RepositoryVisibilityPublic, RepositoryVisibilityInternal:
		return true
	}
	return false
}

func (e RepositoryVisibility) String() string {
	return string(e)
}

func (e *RepositoryVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryVisibility", str)
	}
	return nil
}

func (e RepositoryVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible scopes of an alert's dependency.
type RepositoryVulnerabilityAlertDependencyScope string

const (
	// A dependency that is leveraged during application runtime
	RepositoryVulnerabilityAlertDependencyScopeRuntime RepositoryVulnerabilityAlertDependencyScope = "RUNTIME"
	// A dependency that is only used in development
	RepositoryVulnerabilityAlertDependencyScopeDevelopment RepositoryVulnerabilityAlertDependencyScope = "DEVELOPMENT"
)

var AllRepositoryVulnerabilityAlertDependencyScope = []RepositoryVulnerabilityAlertDependencyScope{
	RepositoryVulnerabilityAlertDependencyScopeRuntime,
	RepositoryVulnerabilityAlertDependencyScopeDevelopment,
}

func (e RepositoryVulnerabilityAlertDependencyScope) IsValid() bool {
	switch e {
	case RepositoryVulnerabilityAlertDependencyScopeRuntime, RepositoryVulnerabilityAlertDependencyScopeDevelopment:
		return true
	}
	return false
}

func (e RepositoryVulnerabilityAlertDependencyScope) String() string {
	return string(e)
}

func (e *RepositoryVulnerabilityAlertDependencyScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryVulnerabilityAlertDependencyScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryVulnerabilityAlertDependencyScope", str)
	}
	return nil
}

func (e RepositoryVulnerabilityAlertDependencyScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of an alert
type RepositoryVulnerabilityAlertState string

const (
	// An alert that is still open.
	RepositoryVulnerabilityAlertStateOpen RepositoryVulnerabilityAlertState = "OPEN"
	// An alert that has been resolved by a code change.
	RepositoryVulnerabilityAlertStateFixed RepositoryVulnerabilityAlertState = "FIXED"
	// An alert that has been manually closed by a user.
	RepositoryVulnerabilityAlertStateDismissed RepositoryVulnerabilityAlertState = "DISMISSED"
	// An alert that has been automatically closed by Dependabot.
	RepositoryVulnerabilityAlertStateAutoDismissed RepositoryVulnerabilityAlertState = "AUTO_DISMISSED"
)

var AllRepositoryVulnerabilityAlertState = []RepositoryVulnerabilityAlertState{
	RepositoryVulnerabilityAlertStateOpen,
	RepositoryVulnerabilityAlertStateFixed,
	RepositoryVulnerabilityAlertStateDismissed,
	RepositoryVulnerabilityAlertStateAutoDismissed,
}

func (e RepositoryVulnerabilityAlertState) IsValid() bool {
	switch e {
	case RepositoryVulnerabilityAlertStateOpen, RepositoryVulnerabilityAlertStateFixed, RepositoryVulnerabilityAlertStateDismissed, RepositoryVulnerabilityAlertStateAutoDismissed:
		return true
	}
	return false
}

func (e RepositoryVulnerabilityAlertState) String() string {
	return string(e)
}

func (e *RepositoryVulnerabilityAlertState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryVulnerabilityAlertState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryVulnerabilityAlertState", str)
	}
	return nil
}

func (e RepositoryVulnerabilityAlertState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states that can be requested when creating a check run.
type RequestableCheckStatusState string

const (
	// The check suite or run has been queued.
	RequestableCheckStatusStateQueued RequestableCheckStatusState = "QUEUED"
	// The check suite or run is in progress.
	RequestableCheckStatusStateInProgress RequestableCheckStatusState = "IN_PROGRESS"
	// The check suite or run has been completed.
	RequestableCheckStatusStateCompleted RequestableCheckStatusState = "COMPLETED"
	// The check suite or run is in waiting state.
	RequestableCheckStatusStateWaiting RequestableCheckStatusState = "WAITING"
	// The check suite or run is in pending state.
	RequestableCheckStatusStatePending RequestableCheckStatusState = "PENDING"
)

var AllRequestableCheckStatusState = []RequestableCheckStatusState{
	RequestableCheckStatusStateQueued,
	RequestableCheckStatusStateInProgress,
	RequestableCheckStatusStateCompleted,
	RequestableCheckStatusStateWaiting,
	RequestableCheckStatusStatePending,
}

func (e RequestableCheckStatusState) IsValid() bool {
	switch e {
	case RequestableCheckStatusStateQueued, RequestableCheckStatusStateInProgress, RequestableCheckStatusStateCompleted, RequestableCheckStatusStateWaiting, RequestableCheckStatusStatePending:
		return true
	}
	return false
}

func (e RequestableCheckStatusState) String() string {
	return string(e)
}

func (e *RequestableCheckStatusState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RequestableCheckStatusState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RequestableCheckStatusState", str)
	}
	return nil
}

func (e RequestableCheckStatusState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible roles a user may have in relation to an organization.
type RoleInOrganization string

const (
	// A user with full administrative access to the organization.
	RoleInOrganizationOwner RoleInOrganization = "OWNER"
	// A user who is a direct member of the organization.
	RoleInOrganizationDirectMember RoleInOrganization = "DIRECT_MEMBER"
	// A user who is unaffiliated with the organization.
	RoleInOrganizationUnaffiliated RoleInOrganization = "UNAFFILIATED"
)

var AllRoleInOrganization = []RoleInOrganization{
	RoleInOrganizationOwner,
	RoleInOrganizationDirectMember,
	RoleInOrganizationUnaffiliated,
}

func (e RoleInOrganization) IsValid() bool {
	switch e {
	case RoleInOrganizationOwner, RoleInOrganizationDirectMember, RoleInOrganizationUnaffiliated:
		return true
	}
	return false
}

func (e RoleInOrganization) String() string {
	return string(e)
}

func (e *RoleInOrganization) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleInOrganization(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleInOrganization", str)
	}
	return nil
}

func (e RoleInOrganization) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The level of enforcement for a rule or ruleset.
type RuleEnforcement string

const (
	// Do not evaluate or enforce rules
	RuleEnforcementDisabled RuleEnforcement = "DISABLED"
	// Rules will be enforced
	RuleEnforcementActive RuleEnforcement = "ACTIVE"
	// Allow admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
	RuleEnforcementEvaluate RuleEnforcement = "EVALUATE"
)

var AllRuleEnforcement = []RuleEnforcement{
	RuleEnforcementDisabled,
	RuleEnforcementActive,
	RuleEnforcementEvaluate,
}

func (e RuleEnforcement) IsValid() bool {
	switch e {
	case RuleEnforcementDisabled, RuleEnforcementActive, RuleEnforcementEvaluate:
		return true
	}
	return false
}

func (e RuleEnforcement) String() string {
	return string(e)
}

func (e *RuleEnforcement) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuleEnforcement(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuleEnforcement", str)
	}
	return nil
}

func (e RuleEnforcement) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible digest algorithms used to sign SAML requests for an identity provider.
type SamlDigestAlgorithm string

const (
	// SHA1
	SamlDigestAlgorithmSha1 SamlDigestAlgorithm = "SHA1"
	// SHA256
	SamlDigestAlgorithmSha256 SamlDigestAlgorithm = "SHA256"
	// SHA384
	SamlDigestAlgorithmSha384 SamlDigestAlgorithm = "SHA384"
	// SHA512
	SamlDigestAlgorithmSha512 SamlDigestAlgorithm = "SHA512"
)

var AllSamlDigestAlgorithm = []SamlDigestAlgorithm{
	SamlDigestAlgorithmSha1,
	SamlDigestAlgorithmSha256,
	SamlDigestAlgorithmSha384,
	SamlDigestAlgorithmSha512,
}

func (e SamlDigestAlgorithm) IsValid() bool {
	switch e {
	case SamlDigestAlgorithmSha1, SamlDigestAlgorithmSha256, SamlDigestAlgorithmSha384, SamlDigestAlgorithmSha512:
		return true
	}
	return false
}

func (e SamlDigestAlgorithm) String() string {
	return string(e)
}

func (e *SamlDigestAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SamlDigestAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SamlDigestAlgorithm", str)
	}
	return nil
}

func (e SamlDigestAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible signature algorithms used to sign SAML requests for a Identity Provider.
type SamlSignatureAlgorithm string

const (
	// RSA-SHA1
	SamlSignatureAlgorithmRsaSha1 SamlSignatureAlgorithm = "RSA_SHA1"
	// RSA-SHA256
	SamlSignatureAlgorithmRsaSha256 SamlSignatureAlgorithm = "RSA_SHA256"
	// RSA-SHA384
	SamlSignatureAlgorithmRsaSha384 SamlSignatureAlgorithm = "RSA_SHA384"
	// RSA-SHA512
	SamlSignatureAlgorithmRsaSha512 SamlSignatureAlgorithm = "RSA_SHA512"
)

var AllSamlSignatureAlgorithm = []SamlSignatureAlgorithm{
	SamlSignatureAlgorithmRsaSha1,
	SamlSignatureAlgorithmRsaSha256,
	SamlSignatureAlgorithmRsaSha384,
	SamlSignatureAlgorithmRsaSha512,
}

func (e SamlSignatureAlgorithm) IsValid() bool {
	switch e {
	case SamlSignatureAlgorithmRsaSha1, SamlSignatureAlgorithmRsaSha256, SamlSignatureAlgorithmRsaSha384, SamlSignatureAlgorithmRsaSha512:
		return true
	}
	return false
}

func (e SamlSignatureAlgorithm) String() string {
	return string(e)
}

func (e *SamlSignatureAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SamlSignatureAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SamlSignatureAlgorithm", str)
	}
	return nil
}

func (e SamlSignatureAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which saved reply connections can be ordered.
type SavedReplyOrderField string

const (
	// Order saved reply by when they were updated.
	SavedReplyOrderFieldUpdatedAt SavedReplyOrderField = "UPDATED_AT"
)

var AllSavedReplyOrderField = []SavedReplyOrderField{
	SavedReplyOrderFieldUpdatedAt,
}

func (e SavedReplyOrderField) IsValid() bool {
	switch e {
	case SavedReplyOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e SavedReplyOrderField) String() string {
	return string(e)
}

func (e *SavedReplyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SavedReplyOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SavedReplyOrderField", str)
	}
	return nil
}

func (e SavedReplyOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the individual results of a search.
type SearchType string

const (
	// Returns results matching issues in repositories.
	SearchTypeIssue SearchType = "ISSUE"
	// Returns results matching repositories.
	SearchTypeRepository SearchType = "REPOSITORY"
	// Returns results matching users and organizations on GitHub.
	SearchTypeUser SearchType = "USER"
	// Returns matching discussions in repositories.
	SearchTypeDiscussion SearchType = "DISCUSSION"
)

var AllSearchType = []SearchType{
	SearchTypeIssue,
	SearchTypeRepository,
	SearchTypeUser,
	SearchTypeDiscussion,
}

func (e SearchType) IsValid() bool {
	switch e {
	case SearchTypeIssue, SearchTypeRepository, SearchTypeUser, SearchTypeDiscussion:
		return true
	}
	return false
}

func (e SearchType) String() string {
	return string(e)
}

func (e *SearchType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchType", str)
	}
	return nil
}

func (e SearchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Classification of the advisory.
type SecurityAdvisoryClassification string

const (
	// Classification of general advisories.
	SecurityAdvisoryClassificationGeneral SecurityAdvisoryClassification = "GENERAL"
	// Classification of malware advisories.
	SecurityAdvisoryClassificationMalware SecurityAdvisoryClassification = "MALWARE"
)

var AllSecurityAdvisoryClassification = []SecurityAdvisoryClassification{
	SecurityAdvisoryClassificationGeneral,
	SecurityAdvisoryClassificationMalware,
}

func (e SecurityAdvisoryClassification) IsValid() bool {
	switch e {
	case SecurityAdvisoryClassificationGeneral, SecurityAdvisoryClassificationMalware:
		return true
	}
	return false
}

func (e SecurityAdvisoryClassification) String() string {
	return string(e)
}

func (e *SecurityAdvisoryClassification) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAdvisoryClassification(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAdvisoryClassification", str)
	}
	return nil
}

func (e SecurityAdvisoryClassification) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible ecosystems of a security vulnerability's package.
type SecurityAdvisoryEcosystem string

const (
	// PHP packages hosted at packagist.org
	SecurityAdvisoryEcosystemComposer SecurityAdvisoryEcosystem = "COMPOSER"
	// Erlang/Elixir packages hosted at hex.pm
	SecurityAdvisoryEcosystemErlang SecurityAdvisoryEcosystem = "ERLANG"
	// GitHub Actions
	SecurityAdvisoryEcosystemActions SecurityAdvisoryEcosystem = "ACTIONS"
	// Go modules
	SecurityAdvisoryEcosystemGo SecurityAdvisoryEcosystem = "GO"
	// Java artifacts hosted at the Maven central repository
	SecurityAdvisoryEcosystemMaven SecurityAdvisoryEcosystem = "MAVEN"
	// JavaScript packages hosted at npmjs.com
	SecurityAdvisoryEcosystemNpm SecurityAdvisoryEcosystem = "NPM"
	// .NET packages hosted at the NuGet Gallery
	SecurityAdvisoryEcosystemNuget SecurityAdvisoryEcosystem = "NUGET"
	// Python packages hosted at PyPI.org
	SecurityAdvisoryEcosystemPip SecurityAdvisoryEcosystem = "PIP"
	// Dart packages hosted at pub.dev
	SecurityAdvisoryEcosystemPub SecurityAdvisoryEcosystem = "PUB"
	// Ruby gems hosted at RubyGems.org
	SecurityAdvisoryEcosystemRubygems SecurityAdvisoryEcosystem = "RUBYGEMS"
	// Rust crates
	SecurityAdvisoryEcosystemRust SecurityAdvisoryEcosystem = "RUST"
	// Swift packages
	SecurityAdvisoryEcosystemSwift SecurityAdvisoryEcosystem = "SWIFT"
)

var AllSecurityAdvisoryEcosystem = []SecurityAdvisoryEcosystem{
	SecurityAdvisoryEcosystemComposer,
	SecurityAdvisoryEcosystemErlang,
	SecurityAdvisoryEcosystemActions,
	SecurityAdvisoryEcosystemGo,
	SecurityAdvisoryEcosystemMaven,
	SecurityAdvisoryEcosystemNpm,
	SecurityAdvisoryEcosystemNuget,
	SecurityAdvisoryEcosystemPip,
	SecurityAdvisoryEcosystemPub,
	SecurityAdvisoryEcosystemRubygems,
	SecurityAdvisoryEcosystemRust,
	SecurityAdvisoryEcosystemSwift,
}

func (e SecurityAdvisoryEcosystem) IsValid() bool {
	switch e {
	case SecurityAdvisoryEcosystemComposer, SecurityAdvisoryEcosystemErlang, SecurityAdvisoryEcosystemActions, SecurityAdvisoryEcosystemGo, SecurityAdvisoryEcosystemMaven, SecurityAdvisoryEcosystemNpm, SecurityAdvisoryEcosystemNuget, SecurityAdvisoryEcosystemPip, SecurityAdvisoryEcosystemPub, SecurityAdvisoryEcosystemRubygems, SecurityAdvisoryEcosystemRust, SecurityAdvisoryEcosystemSwift:
		return true
	}
	return false
}

func (e SecurityAdvisoryEcosystem) String() string {
	return string(e)
}

func (e *SecurityAdvisoryEcosystem) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAdvisoryEcosystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAdvisoryEcosystem", str)
	}
	return nil
}

func (e SecurityAdvisoryEcosystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Identifier formats available for advisories.
type SecurityAdvisoryIdentifierType string

const (
	// Common Vulnerabilities and Exposures Identifier.
	SecurityAdvisoryIdentifierTypeCve SecurityAdvisoryIdentifierType = "CVE"
	// GitHub Security Advisory ID.
	SecurityAdvisoryIdentifierTypeGhsa SecurityAdvisoryIdentifierType = "GHSA"
)

var AllSecurityAdvisoryIdentifierType = []SecurityAdvisoryIdentifierType{
	SecurityAdvisoryIdentifierTypeCve,
	SecurityAdvisoryIdentifierTypeGhsa,
}

func (e SecurityAdvisoryIdentifierType) IsValid() bool {
	switch e {
	case SecurityAdvisoryIdentifierTypeCve, SecurityAdvisoryIdentifierTypeGhsa:
		return true
	}
	return false
}

func (e SecurityAdvisoryIdentifierType) String() string {
	return string(e)
}

func (e *SecurityAdvisoryIdentifierType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAdvisoryIdentifierType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAdvisoryIdentifierType", str)
	}
	return nil
}

func (e SecurityAdvisoryIdentifierType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which security advisory connections can be ordered.
type SecurityAdvisoryOrderField string

const (
	// Order advisories by publication time
	SecurityAdvisoryOrderFieldPublishedAt SecurityAdvisoryOrderField = "PUBLISHED_AT"
	// Order advisories by update time
	SecurityAdvisoryOrderFieldUpdatedAt SecurityAdvisoryOrderField = "UPDATED_AT"
	// Order advisories by EPSS percentage
	SecurityAdvisoryOrderFieldEpssPercentage SecurityAdvisoryOrderField = "EPSS_PERCENTAGE"
	// Order advisories by EPSS percentile
	SecurityAdvisoryOrderFieldEpssPercentile SecurityAdvisoryOrderField = "EPSS_PERCENTILE"
)

var AllSecurityAdvisoryOrderField = []SecurityAdvisoryOrderField{
	SecurityAdvisoryOrderFieldPublishedAt,
	SecurityAdvisoryOrderFieldUpdatedAt,
	SecurityAdvisoryOrderFieldEpssPercentage,
	SecurityAdvisoryOrderFieldEpssPercentile,
}

func (e SecurityAdvisoryOrderField) IsValid() bool {
	switch e {
	case SecurityAdvisoryOrderFieldPublishedAt, SecurityAdvisoryOrderFieldUpdatedAt, SecurityAdvisoryOrderFieldEpssPercentage, SecurityAdvisoryOrderFieldEpssPercentile:
		return true
	}
	return false
}

func (e SecurityAdvisoryOrderField) String() string {
	return string(e)
}

func (e *SecurityAdvisoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAdvisoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAdvisoryOrderField", str)
	}
	return nil
}

func (e SecurityAdvisoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity of the vulnerability.
type SecurityAdvisorySeverity string

const (
	// Low.
	SecurityAdvisorySeverityLow SecurityAdvisorySeverity = "LOW"
	// Moderate.
	SecurityAdvisorySeverityModerate SecurityAdvisorySeverity = "MODERATE"
	// High.
	SecurityAdvisorySeverityHigh SecurityAdvisorySeverity = "HIGH"
	// Critical.
	SecurityAdvisorySeverityCritical SecurityAdvisorySeverity = "CRITICAL"
)

var AllSecurityAdvisorySeverity = []SecurityAdvisorySeverity{
	SecurityAdvisorySeverityLow,
	SecurityAdvisorySeverityModerate,
	SecurityAdvisorySeverityHigh,
	SecurityAdvisorySeverityCritical,
}

func (e SecurityAdvisorySeverity) IsValid() bool {
	switch e {
	case SecurityAdvisorySeverityLow, SecurityAdvisorySeverityModerate, SecurityAdvisorySeverityHigh, SecurityAdvisorySeverityCritical:
		return true
	}
	return false
}

func (e SecurityAdvisorySeverity) String() string {
	return string(e)
}

func (e *SecurityAdvisorySeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityAdvisorySeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityAdvisorySeverity", str)
	}
	return nil
}

func (e SecurityAdvisorySeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which security vulnerability connections can be ordered.
type SecurityVulnerabilityOrderField string

const (
	// Order vulnerability by update time
	SecurityVulnerabilityOrderFieldUpdatedAt SecurityVulnerabilityOrderField = "UPDATED_AT"
)

var AllSecurityVulnerabilityOrderField = []SecurityVulnerabilityOrderField{
	SecurityVulnerabilityOrderFieldUpdatedAt,
}

func (e SecurityVulnerabilityOrderField) IsValid() bool {
	switch e {
	case SecurityVulnerabilityOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e SecurityVulnerabilityOrderField) String() string {
	return string(e)
}

func (e *SecurityVulnerabilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SecurityVulnerabilityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SecurityVulnerabilityOrderField", str)
	}
	return nil
}

func (e SecurityVulnerabilityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Software or company that hosts social media accounts.
type SocialAccountProvider string

const (
	// Catch-all for social media providers that do not yet have specific handling.
	SocialAccountProviderGeneric SocialAccountProvider = "GENERIC"
	// Social media and networking website.
	SocialAccountProviderFacebook SocialAccountProvider = "FACEBOOK"
	// Fork of Mastodon with a greater focus on local posting.
	SocialAccountProviderHometown SocialAccountProvider = "HOMETOWN"
	// Social media website with a focus on photo and video sharing.
	SocialAccountProviderInstagram SocialAccountProvider = "INSTAGRAM"
	// Professional networking website.
	SocialAccountProviderLinkedin SocialAccountProvider = "LINKEDIN"
	// Open-source federated microblogging service.
	SocialAccountProviderMastodon SocialAccountProvider = "MASTODON"
	// Social news aggregation and discussion website.
	SocialAccountProviderReddit SocialAccountProvider = "REDDIT"
	// Live-streaming service.
	SocialAccountProviderTwitch SocialAccountProvider = "TWITCH"
	// Microblogging website.
	SocialAccountProviderTwitter SocialAccountProvider = "TWITTER"
	// Online video platform.
	SocialAccountProviderYoutube SocialAccountProvider = "YOUTUBE"
	// Decentralized microblogging social platform.
	SocialAccountProviderBluesky SocialAccountProvider = "BLUESKY"
	// JavaScript package registry.
	SocialAccountProviderNpm SocialAccountProvider = "NPM"
)

var AllSocialAccountProvider = []SocialAccountProvider{
	SocialAccountProviderGeneric,
	SocialAccountProviderFacebook,
	SocialAccountProviderHometown,
	SocialAccountProviderInstagram,
	SocialAccountProviderLinkedin,
	SocialAccountProviderMastodon,
	SocialAccountProviderReddit,
	SocialAccountProviderTwitch,
	SocialAccountProviderTwitter,
	SocialAccountProviderYoutube,
	SocialAccountProviderBluesky,
	SocialAccountProviderNpm,
}

func (e SocialAccountProvider) IsValid() bool {
	switch e {
	case SocialAccountProviderGeneric, SocialAccountProviderFacebook, SocialAccountProviderHometown, SocialAccountProviderInstagram, SocialAccountProviderLinkedin, SocialAccountProviderMastodon, SocialAccountProviderReddit, SocialAccountProviderTwitch, SocialAccountProviderTwitter, SocialAccountProviderYoutube, SocialAccountProviderBluesky, SocialAccountProviderNpm:
		return true
	}
	return false
}

func (e SocialAccountProvider) String() string {
	return string(e)
}

func (e *SocialAccountProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocialAccountProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocialAccountProvider", str)
	}
	return nil
}

func (e SocialAccountProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which sponsor and lifetime value connections can be ordered.
type SponsorAndLifetimeValueOrderField string

const (
	// Order results by the sponsor's login (username).
	SponsorAndLifetimeValueOrderFieldSponsorLogin SponsorAndLifetimeValueOrderField = "SPONSOR_LOGIN"
	// Order results by the sponsor's relevance to the viewer.
	SponsorAndLifetimeValueOrderFieldSponsorRelevance SponsorAndLifetimeValueOrderField = "SPONSOR_RELEVANCE"
	// Order results by how much money the sponsor has paid in total.
	SponsorAndLifetimeValueOrderFieldLifetimeValue SponsorAndLifetimeValueOrderField = "LIFETIME_VALUE"
)

var AllSponsorAndLifetimeValueOrderField = []SponsorAndLifetimeValueOrderField{
	SponsorAndLifetimeValueOrderFieldSponsorLogin,
	SponsorAndLifetimeValueOrderFieldSponsorRelevance,
	SponsorAndLifetimeValueOrderFieldLifetimeValue,
}

func (e SponsorAndLifetimeValueOrderField) IsValid() bool {
	switch e {
	case SponsorAndLifetimeValueOrderFieldSponsorLogin, SponsorAndLifetimeValueOrderFieldSponsorRelevance, SponsorAndLifetimeValueOrderFieldLifetimeValue:
		return true
	}
	return false
}

func (e SponsorAndLifetimeValueOrderField) String() string {
	return string(e)
}

func (e *SponsorAndLifetimeValueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorAndLifetimeValueOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorAndLifetimeValueOrderField", str)
	}
	return nil
}

func (e SponsorAndLifetimeValueOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which sponsor connections can be ordered.
type SponsorOrderField string

const (
	// Order sponsorable entities by login (username).
	SponsorOrderFieldLogin SponsorOrderField = "LOGIN"
	// Order sponsors by their relevance to the viewer.
	SponsorOrderFieldRelevance SponsorOrderField = "RELEVANCE"
)

var AllSponsorOrderField = []SponsorOrderField{
	SponsorOrderFieldLogin,
	SponsorOrderFieldRelevance,
}

func (e SponsorOrderField) IsValid() bool {
	switch e {
	case SponsorOrderFieldLogin, SponsorOrderFieldRelevance:
		return true
	}
	return false
}

func (e SponsorOrderField) String() string {
	return string(e)
}

func (e *SponsorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorOrderField", str)
	}
	return nil
}

func (e SponsorOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which sponsorable connections can be ordered.
type SponsorableOrderField string

const (
	// Order sponsorable entities by login (username).
	SponsorableOrderFieldLogin SponsorableOrderField = "LOGIN"
)

var AllSponsorableOrderField = []SponsorableOrderField{
	SponsorableOrderFieldLogin,
}

func (e SponsorableOrderField) IsValid() bool {
	switch e {
	case SponsorableOrderFieldLogin:
		return true
	}
	return false
}

func (e SponsorableOrderField) String() string {
	return string(e)
}

func (e *SponsorableOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorableOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorableOrderField", str)
	}
	return nil
}

func (e SponsorableOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible actions that GitHub Sponsors activities can represent.
type SponsorsActivityAction string

const (
	// The activity was starting a sponsorship.
	SponsorsActivityActionNewSponsorship SponsorsActivityAction = "NEW_SPONSORSHIP"
	// The activity was cancelling a sponsorship.
	SponsorsActivityActionCancelledSponsorship SponsorsActivityAction = "CANCELLED_SPONSORSHIP"
	// The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change.
	SponsorsActivityActionTierChange SponsorsActivityAction = "TIER_CHANGE"
	// The activity was funds being refunded to the sponsor or GitHub.
	SponsorsActivityActionRefund SponsorsActivityAction = "REFUND"
	// The activity was scheduling a downgrade or cancellation.
	SponsorsActivityActionPendingChange SponsorsActivityAction = "PENDING_CHANGE"
	// The activity was disabling matching for a previously matched sponsorship.
	SponsorsActivityActionSponsorMatchDisabled SponsorsActivityAction = "SPONSOR_MATCH_DISABLED"
)

var AllSponsorsActivityAction = []SponsorsActivityAction{
	SponsorsActivityActionNewSponsorship,
	SponsorsActivityActionCancelledSponsorship,
	SponsorsActivityActionTierChange,
	SponsorsActivityActionRefund,
	SponsorsActivityActionPendingChange,
	SponsorsActivityActionSponsorMatchDisabled,
}

func (e SponsorsActivityAction) IsValid() bool {
	switch e {
	case SponsorsActivityActionNewSponsorship, SponsorsActivityActionCancelledSponsorship, SponsorsActivityActionTierChange, SponsorsActivityActionRefund, SponsorsActivityActionPendingChange, SponsorsActivityActionSponsorMatchDisabled:
		return true
	}
	return false
}

func (e SponsorsActivityAction) String() string {
	return string(e)
}

func (e *SponsorsActivityAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsActivityAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsActivityAction", str)
	}
	return nil
}

func (e SponsorsActivityAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GitHub Sponsors activity connections can be ordered.
type SponsorsActivityOrderField string

const (
	// Order activities by when they happened.
	SponsorsActivityOrderFieldTimestamp SponsorsActivityOrderField = "TIMESTAMP"
)

var AllSponsorsActivityOrderField = []SponsorsActivityOrderField{
	SponsorsActivityOrderFieldTimestamp,
}

func (e SponsorsActivityOrderField) IsValid() bool {
	switch e {
	case SponsorsActivityOrderFieldTimestamp:
		return true
	}
	return false
}

func (e SponsorsActivityOrderField) String() string {
	return string(e)
}

func (e *SponsorsActivityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsActivityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsActivityOrderField", str)
	}
	return nil
}

func (e SponsorsActivityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible time periods for which Sponsors activities can be requested.
type SponsorsActivityPeriod string

const (
	// The previous calendar day.
	SponsorsActivityPeriodDay SponsorsActivityPeriod = "DAY"
	// The previous seven days.
	SponsorsActivityPeriodWeek SponsorsActivityPeriod = "WEEK"
	// The previous thirty days.
	SponsorsActivityPeriodMonth SponsorsActivityPeriod = "MONTH"
	// Don't restrict the activity to any date range, include all activity.
	SponsorsActivityPeriodAll SponsorsActivityPeriod = "ALL"
)

var AllSponsorsActivityPeriod = []SponsorsActivityPeriod{
	SponsorsActivityPeriodDay,
	SponsorsActivityPeriodWeek,
	SponsorsActivityPeriodMonth,
	SponsorsActivityPeriodAll,
}

func (e SponsorsActivityPeriod) IsValid() bool {
	switch e {
	case SponsorsActivityPeriodDay, SponsorsActivityPeriodWeek, SponsorsActivityPeriodMonth, SponsorsActivityPeriodAll:
		return true
	}
	return false
}

func (e SponsorsActivityPeriod) String() string {
	return string(e)
}

func (e *SponsorsActivityPeriod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsActivityPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsActivityPeriod", str)
	}
	return nil
}

func (e SponsorsActivityPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents countries or regions for billing and residence for a GitHub Sponsors profile.
type SponsorsCountryOrRegionCode string

const (
	// Afghanistan
	SponsorsCountryOrRegionCodeAf SponsorsCountryOrRegionCode = "AF"
	// land
	SponsorsCountryOrRegionCodeAx SponsorsCountryOrRegionCode = "AX"
	// Albania
	SponsorsCountryOrRegionCodeAl SponsorsCountryOrRegionCode = "AL"
	// Algeria
	SponsorsCountryOrRegionCodeDz SponsorsCountryOrRegionCode = "DZ"
	// American Samoa
	SponsorsCountryOrRegionCodeAs SponsorsCountryOrRegionCode = "AS"
	// Andorra
	SponsorsCountryOrRegionCodeAd SponsorsCountryOrRegionCode = "AD"
	// Angola
	SponsorsCountryOrRegionCodeAo SponsorsCountryOrRegionCode = "AO"
	// Anguilla
	SponsorsCountryOrRegionCodeAi SponsorsCountryOrRegionCode = "AI"
	// Antarctica
	SponsorsCountryOrRegionCodeAq SponsorsCountryOrRegionCode = "AQ"
	// Antigua and Barbuda
	SponsorsCountryOrRegionCodeAg SponsorsCountryOrRegionCode = "AG"
	// Argentina
	SponsorsCountryOrRegionCodeAr SponsorsCountryOrRegionCode = "AR"
	// Armenia
	SponsorsCountryOrRegionCodeAm SponsorsCountryOrRegionCode = "AM"
	// Aruba
	SponsorsCountryOrRegionCodeAw SponsorsCountryOrRegionCode = "AW"
	// Australia
	SponsorsCountryOrRegionCodeAu SponsorsCountryOrRegionCode = "AU"
	// Austria
	SponsorsCountryOrRegionCodeAt SponsorsCountryOrRegionCode = "AT"
	// Azerbaijan
	SponsorsCountryOrRegionCodeAz SponsorsCountryOrRegionCode = "AZ"
	// Bahamas
	SponsorsCountryOrRegionCodeBs SponsorsCountryOrRegionCode = "BS"
	// Bahrain
	SponsorsCountryOrRegionCodeBh SponsorsCountryOrRegionCode = "BH"
	// Bangladesh
	SponsorsCountryOrRegionCodeBd SponsorsCountryOrRegionCode = "BD"
	// Barbados
	SponsorsCountryOrRegionCodeBb SponsorsCountryOrRegionCode = "BB"
	// Belarus
	SponsorsCountryOrRegionCodeBy SponsorsCountryOrRegionCode = "BY"
	// Belgium
	SponsorsCountryOrRegionCodeBe SponsorsCountryOrRegionCode = "BE"
	// Belize
	SponsorsCountryOrRegionCodeBz SponsorsCountryOrRegionCode = "BZ"
	// Benin
	SponsorsCountryOrRegionCodeBj SponsorsCountryOrRegionCode = "BJ"
	// Bermuda
	SponsorsCountryOrRegionCodeBm SponsorsCountryOrRegionCode = "BM"
	// Bhutan
	SponsorsCountryOrRegionCodeBt SponsorsCountryOrRegionCode = "BT"
	// Bolivia
	SponsorsCountryOrRegionCodeBo SponsorsCountryOrRegionCode = "BO"
	// Bonaire, Sint Eustatius and Saba
	SponsorsCountryOrRegionCodeBq SponsorsCountryOrRegionCode = "BQ"
	// Bosnia and Herzegovina
	SponsorsCountryOrRegionCodeBa SponsorsCountryOrRegionCode = "BA"
	// Botswana
	SponsorsCountryOrRegionCodeBw SponsorsCountryOrRegionCode = "BW"
	// Bouvet Island
	SponsorsCountryOrRegionCodeBv SponsorsCountryOrRegionCode = "BV"
	// Brazil
	SponsorsCountryOrRegionCodeBr SponsorsCountryOrRegionCode = "BR"
	// British Indian Ocean Territory
	SponsorsCountryOrRegionCodeIo SponsorsCountryOrRegionCode = "IO"
	// Brunei Darussalam
	SponsorsCountryOrRegionCodeBn SponsorsCountryOrRegionCode = "BN"
	// Bulgaria
	SponsorsCountryOrRegionCodeBg SponsorsCountryOrRegionCode = "BG"
	// Burkina Faso
	SponsorsCountryOrRegionCodeBf SponsorsCountryOrRegionCode = "BF"
	// Burundi
	SponsorsCountryOrRegionCodeBi SponsorsCountryOrRegionCode = "BI"
	// Cambodia
	SponsorsCountryOrRegionCodeKh SponsorsCountryOrRegionCode = "KH"
	// Cameroon
	SponsorsCountryOrRegionCodeCm SponsorsCountryOrRegionCode = "CM"
	// Canada
	SponsorsCountryOrRegionCodeCa SponsorsCountryOrRegionCode = "CA"
	// Cape Verde
	SponsorsCountryOrRegionCodeCv SponsorsCountryOrRegionCode = "CV"
	// Cayman Islands
	SponsorsCountryOrRegionCodeKy SponsorsCountryOrRegionCode = "KY"
	// Central African Republic
	SponsorsCountryOrRegionCodeCf SponsorsCountryOrRegionCode = "CF"
	// Chad
	SponsorsCountryOrRegionCodeTd SponsorsCountryOrRegionCode = "TD"
	// Chile
	SponsorsCountryOrRegionCodeCl SponsorsCountryOrRegionCode = "CL"
	// China
	SponsorsCountryOrRegionCodeCn SponsorsCountryOrRegionCode = "CN"
	// Christmas Island
	SponsorsCountryOrRegionCodeCx SponsorsCountryOrRegionCode = "CX"
	// Cocos (Keeling) Islands
	SponsorsCountryOrRegionCodeCc SponsorsCountryOrRegionCode = "CC"
	// Colombia
	SponsorsCountryOrRegionCodeCo SponsorsCountryOrRegionCode = "CO"
	// Comoros
	SponsorsCountryOrRegionCodeKm SponsorsCountryOrRegionCode = "KM"
	// Congo (Brazzaville)
	SponsorsCountryOrRegionCodeCg SponsorsCountryOrRegionCode = "CG"
	// Congo (Kinshasa)
	SponsorsCountryOrRegionCodeCd SponsorsCountryOrRegionCode = "CD"
	// Cook Islands
	SponsorsCountryOrRegionCodeCk SponsorsCountryOrRegionCode = "CK"
	// Costa Rica
	SponsorsCountryOrRegionCodeCr SponsorsCountryOrRegionCode = "CR"
	// Cte d'Ivoire
	SponsorsCountryOrRegionCodeCi SponsorsCountryOrRegionCode = "CI"
	// Croatia
	SponsorsCountryOrRegionCodeHr SponsorsCountryOrRegionCode = "HR"
	// Curaao
	SponsorsCountryOrRegionCodeCw SponsorsCountryOrRegionCode = "CW"
	// Cyprus
	SponsorsCountryOrRegionCodeCy SponsorsCountryOrRegionCode = "CY"
	// Czech Republic
	SponsorsCountryOrRegionCodeCz SponsorsCountryOrRegionCode = "CZ"
	// Denmark
	SponsorsCountryOrRegionCodeDk SponsorsCountryOrRegionCode = "DK"
	// Djibouti
	SponsorsCountryOrRegionCodeDj SponsorsCountryOrRegionCode = "DJ"
	// Dominica
	SponsorsCountryOrRegionCodeDm SponsorsCountryOrRegionCode = "DM"
	// Dominican Republic
	SponsorsCountryOrRegionCodeDo SponsorsCountryOrRegionCode = "DO"
	// Ecuador
	SponsorsCountryOrRegionCodeEc SponsorsCountryOrRegionCode = "EC"
	// Egypt
	SponsorsCountryOrRegionCodeEg SponsorsCountryOrRegionCode = "EG"
	// El Salvador
	SponsorsCountryOrRegionCodeSv SponsorsCountryOrRegionCode = "SV"
	// Equatorial Guinea
	SponsorsCountryOrRegionCodeGq SponsorsCountryOrRegionCode = "GQ"
	// Eritrea
	SponsorsCountryOrRegionCodeEr SponsorsCountryOrRegionCode = "ER"
	// Estonia
	SponsorsCountryOrRegionCodeEe SponsorsCountryOrRegionCode = "EE"
	// Ethiopia
	SponsorsCountryOrRegionCodeEt SponsorsCountryOrRegionCode = "ET"
	// Falkland Islands
	SponsorsCountryOrRegionCodeFk SponsorsCountryOrRegionCode = "FK"
	// Faroe Islands
	SponsorsCountryOrRegionCodeFo SponsorsCountryOrRegionCode = "FO"
	// Fiji
	SponsorsCountryOrRegionCodeFj SponsorsCountryOrRegionCode = "FJ"
	// Finland
	SponsorsCountryOrRegionCodeFi SponsorsCountryOrRegionCode = "FI"
	// France
	SponsorsCountryOrRegionCodeFr SponsorsCountryOrRegionCode = "FR"
	// French Guiana
	SponsorsCountryOrRegionCodeGf SponsorsCountryOrRegionCode = "GF"
	// French Polynesia
	SponsorsCountryOrRegionCodePf SponsorsCountryOrRegionCode = "PF"
	// French Southern Lands
	SponsorsCountryOrRegionCodeTf SponsorsCountryOrRegionCode = "TF"
	// Gabon
	SponsorsCountryOrRegionCodeGa SponsorsCountryOrRegionCode = "GA"
	// Gambia
	SponsorsCountryOrRegionCodeGm SponsorsCountryOrRegionCode = "GM"
	// Georgia
	SponsorsCountryOrRegionCodeGe SponsorsCountryOrRegionCode = "GE"
	// Germany
	SponsorsCountryOrRegionCodeDe SponsorsCountryOrRegionCode = "DE"
	// Ghana
	SponsorsCountryOrRegionCodeGh SponsorsCountryOrRegionCode = "GH"
	// Gibraltar
	SponsorsCountryOrRegionCodeGi SponsorsCountryOrRegionCode = "GI"
	// Greece
	SponsorsCountryOrRegionCodeGr SponsorsCountryOrRegionCode = "GR"
	// Greenland
	SponsorsCountryOrRegionCodeGl SponsorsCountryOrRegionCode = "GL"
	// Grenada
	SponsorsCountryOrRegionCodeGd SponsorsCountryOrRegionCode = "GD"
	// Guadeloupe
	SponsorsCountryOrRegionCodeGp SponsorsCountryOrRegionCode = "GP"
	// Guam
	SponsorsCountryOrRegionCodeGu SponsorsCountryOrRegionCode = "GU"
	// Guatemala
	SponsorsCountryOrRegionCodeGt SponsorsCountryOrRegionCode = "GT"
	// Guernsey
	SponsorsCountryOrRegionCodeGg SponsorsCountryOrRegionCode = "GG"
	// Guinea
	SponsorsCountryOrRegionCodeGn SponsorsCountryOrRegionCode = "GN"
	// Guinea-Bissau
	SponsorsCountryOrRegionCodeGw SponsorsCountryOrRegionCode = "GW"
	// Guyana
	SponsorsCountryOrRegionCodeGy SponsorsCountryOrRegionCode = "GY"
	// Haiti
	SponsorsCountryOrRegionCodeHt SponsorsCountryOrRegionCode = "HT"
	// Heard and McDonald Islands
	SponsorsCountryOrRegionCodeHm SponsorsCountryOrRegionCode = "HM"
	// Honduras
	SponsorsCountryOrRegionCodeHn SponsorsCountryOrRegionCode = "HN"
	// Hong Kong
	SponsorsCountryOrRegionCodeHk SponsorsCountryOrRegionCode = "HK"
	// Hungary
	SponsorsCountryOrRegionCodeHu SponsorsCountryOrRegionCode = "HU"
	// Iceland
	SponsorsCountryOrRegionCodeIs SponsorsCountryOrRegionCode = "IS"
	// India
	SponsorsCountryOrRegionCodeIn SponsorsCountryOrRegionCode = "IN"
	// Indonesia
	SponsorsCountryOrRegionCodeID SponsorsCountryOrRegionCode = "ID"
	// Iran
	SponsorsCountryOrRegionCodeIr SponsorsCountryOrRegionCode = "IR"
	// Iraq
	SponsorsCountryOrRegionCodeIq SponsorsCountryOrRegionCode = "IQ"
	// Ireland
	SponsorsCountryOrRegionCodeIe SponsorsCountryOrRegionCode = "IE"
	// Isle of Man
	SponsorsCountryOrRegionCodeIm SponsorsCountryOrRegionCode = "IM"
	// Israel
	SponsorsCountryOrRegionCodeIl SponsorsCountryOrRegionCode = "IL"
	// Italy
	SponsorsCountryOrRegionCodeIt SponsorsCountryOrRegionCode = "IT"
	// Jamaica
	SponsorsCountryOrRegionCodeJm SponsorsCountryOrRegionCode = "JM"
	// Japan
	SponsorsCountryOrRegionCodeJp SponsorsCountryOrRegionCode = "JP"
	// Jersey
	SponsorsCountryOrRegionCodeJe SponsorsCountryOrRegionCode = "JE"
	// Jordan
	SponsorsCountryOrRegionCodeJo SponsorsCountryOrRegionCode = "JO"
	// Kazakhstan
	SponsorsCountryOrRegionCodeKz SponsorsCountryOrRegionCode = "KZ"
	// Kenya
	SponsorsCountryOrRegionCodeKe SponsorsCountryOrRegionCode = "KE"
	// Kiribati
	SponsorsCountryOrRegionCodeKi SponsorsCountryOrRegionCode = "KI"
	// Korea, South
	SponsorsCountryOrRegionCodeKr SponsorsCountryOrRegionCode = "KR"
	// Kuwait
	SponsorsCountryOrRegionCodeKw SponsorsCountryOrRegionCode = "KW"
	// Kyrgyzstan
	SponsorsCountryOrRegionCodeKg SponsorsCountryOrRegionCode = "KG"
	// Laos
	SponsorsCountryOrRegionCodeLa SponsorsCountryOrRegionCode = "LA"
	// Latvia
	SponsorsCountryOrRegionCodeLv SponsorsCountryOrRegionCode = "LV"
	// Lebanon
	SponsorsCountryOrRegionCodeLb SponsorsCountryOrRegionCode = "LB"
	// Lesotho
	SponsorsCountryOrRegionCodeLs SponsorsCountryOrRegionCode = "LS"
	// Liberia
	SponsorsCountryOrRegionCodeLr SponsorsCountryOrRegionCode = "LR"
	// Libya
	SponsorsCountryOrRegionCodeLy SponsorsCountryOrRegionCode = "LY"
	// Liechtenstein
	SponsorsCountryOrRegionCodeLi SponsorsCountryOrRegionCode = "LI"
	// Lithuania
	SponsorsCountryOrRegionCodeLt SponsorsCountryOrRegionCode = "LT"
	// Luxembourg
	SponsorsCountryOrRegionCodeLu SponsorsCountryOrRegionCode = "LU"
	// Macau
	SponsorsCountryOrRegionCodeMo SponsorsCountryOrRegionCode = "MO"
	// Macedonia
	SponsorsCountryOrRegionCodeMk SponsorsCountryOrRegionCode = "MK"
	// Madagascar
	SponsorsCountryOrRegionCodeMg SponsorsCountryOrRegionCode = "MG"
	// Malawi
	SponsorsCountryOrRegionCodeMw SponsorsCountryOrRegionCode = "MW"
	// Malaysia
	SponsorsCountryOrRegionCodeMy SponsorsCountryOrRegionCode = "MY"
	// Maldives
	SponsorsCountryOrRegionCodeMv SponsorsCountryOrRegionCode = "MV"
	// Mali
	SponsorsCountryOrRegionCodeMl SponsorsCountryOrRegionCode = "ML"
	// Malta
	SponsorsCountryOrRegionCodeMt SponsorsCountryOrRegionCode = "MT"
	// Marshall Islands
	SponsorsCountryOrRegionCodeMh SponsorsCountryOrRegionCode = "MH"
	// Martinique
	SponsorsCountryOrRegionCodeMq SponsorsCountryOrRegionCode = "MQ"
	// Mauritania
	SponsorsCountryOrRegionCodeMr SponsorsCountryOrRegionCode = "MR"
	// Mauritius
	SponsorsCountryOrRegionCodeMu SponsorsCountryOrRegionCode = "MU"
	// Mayotte
	SponsorsCountryOrRegionCodeYt SponsorsCountryOrRegionCode = "YT"
	// Mexico
	SponsorsCountryOrRegionCodeMx SponsorsCountryOrRegionCode = "MX"
	// Micronesia
	SponsorsCountryOrRegionCodeFm SponsorsCountryOrRegionCode = "FM"
	// Moldova
	SponsorsCountryOrRegionCodeMd SponsorsCountryOrRegionCode = "MD"
	// Monaco
	SponsorsCountryOrRegionCodeMc SponsorsCountryOrRegionCode = "MC"
	// Mongolia
	SponsorsCountryOrRegionCodeMn SponsorsCountryOrRegionCode = "MN"
	// Montenegro
	SponsorsCountryOrRegionCodeMe SponsorsCountryOrRegionCode = "ME"
	// Montserrat
	SponsorsCountryOrRegionCodeMs SponsorsCountryOrRegionCode = "MS"
	// Morocco
	SponsorsCountryOrRegionCodeMa SponsorsCountryOrRegionCode = "MA"
	// Mozambique
	SponsorsCountryOrRegionCodeMz SponsorsCountryOrRegionCode = "MZ"
	// Myanmar
	SponsorsCountryOrRegionCodeMm SponsorsCountryOrRegionCode = "MM"
	// Namibia
	SponsorsCountryOrRegionCodeNa SponsorsCountryOrRegionCode = "NA"
	// Nauru
	SponsorsCountryOrRegionCodeNr SponsorsCountryOrRegionCode = "NR"
	// Nepal
	SponsorsCountryOrRegionCodeNp SponsorsCountryOrRegionCode = "NP"
	// Netherlands
	SponsorsCountryOrRegionCodeNl SponsorsCountryOrRegionCode = "NL"
	// New Caledonia
	SponsorsCountryOrRegionCodeNc SponsorsCountryOrRegionCode = "NC"
	// New Zealand
	SponsorsCountryOrRegionCodeNz SponsorsCountryOrRegionCode = "NZ"
	// Nicaragua
	SponsorsCountryOrRegionCodeNi SponsorsCountryOrRegionCode = "NI"
	// Niger
	SponsorsCountryOrRegionCodeNe SponsorsCountryOrRegionCode = "NE"
	// Nigeria
	SponsorsCountryOrRegionCodeNg SponsorsCountryOrRegionCode = "NG"
	// Niue
	SponsorsCountryOrRegionCodeNu SponsorsCountryOrRegionCode = "NU"
	// Norfolk Island
	SponsorsCountryOrRegionCodeNf SponsorsCountryOrRegionCode = "NF"
	// Northern Mariana Islands
	SponsorsCountryOrRegionCodeMp SponsorsCountryOrRegionCode = "MP"
	// Norway
	SponsorsCountryOrRegionCodeNo SponsorsCountryOrRegionCode = "NO"
	// Oman
	SponsorsCountryOrRegionCodeOm SponsorsCountryOrRegionCode = "OM"
	// Pakistan
	SponsorsCountryOrRegionCodePk SponsorsCountryOrRegionCode = "PK"
	// Palau
	SponsorsCountryOrRegionCodePw SponsorsCountryOrRegionCode = "PW"
	// Palestine
	SponsorsCountryOrRegionCodePs SponsorsCountryOrRegionCode = "PS"
	// Panama
	SponsorsCountryOrRegionCodePa SponsorsCountryOrRegionCode = "PA"
	// Papua New Guinea
	SponsorsCountryOrRegionCodePg SponsorsCountryOrRegionCode = "PG"
	// Paraguay
	SponsorsCountryOrRegionCodePy SponsorsCountryOrRegionCode = "PY"
	// Peru
	SponsorsCountryOrRegionCodePe SponsorsCountryOrRegionCode = "PE"
	// Philippines
	SponsorsCountryOrRegionCodePh SponsorsCountryOrRegionCode = "PH"
	// Pitcairn
	SponsorsCountryOrRegionCodePn SponsorsCountryOrRegionCode = "PN"
	// Poland
	SponsorsCountryOrRegionCodePl SponsorsCountryOrRegionCode = "PL"
	// Portugal
	SponsorsCountryOrRegionCodePt SponsorsCountryOrRegionCode = "PT"
	// Puerto Rico
	SponsorsCountryOrRegionCodePr SponsorsCountryOrRegionCode = "PR"
	// Qatar
	SponsorsCountryOrRegionCodeQa SponsorsCountryOrRegionCode = "QA"
	// Reunion
	SponsorsCountryOrRegionCodeRe SponsorsCountryOrRegionCode = "RE"
	// Romania
	SponsorsCountryOrRegionCodeRo SponsorsCountryOrRegionCode = "RO"
	// Russian Federation
	SponsorsCountryOrRegionCodeRu SponsorsCountryOrRegionCode = "RU"
	// Rwanda
	SponsorsCountryOrRegionCodeRw SponsorsCountryOrRegionCode = "RW"
	// Saint Barthlemy
	SponsorsCountryOrRegionCodeBl SponsorsCountryOrRegionCode = "BL"
	// Saint Helena
	SponsorsCountryOrRegionCodeSh SponsorsCountryOrRegionCode = "SH"
	// Saint Kitts and Nevis
	SponsorsCountryOrRegionCodeKn SponsorsCountryOrRegionCode = "KN"
	// Saint Lucia
	SponsorsCountryOrRegionCodeLc SponsorsCountryOrRegionCode = "LC"
	// Saint Martin (French part)
	SponsorsCountryOrRegionCodeMf SponsorsCountryOrRegionCode = "MF"
	// Saint Pierre and Miquelon
	SponsorsCountryOrRegionCodePm SponsorsCountryOrRegionCode = "PM"
	// Saint Vincent and the Grenadines
	SponsorsCountryOrRegionCodeVc SponsorsCountryOrRegionCode = "VC"
	// Samoa
	SponsorsCountryOrRegionCodeWs SponsorsCountryOrRegionCode = "WS"
	// San Marino
	SponsorsCountryOrRegionCodeSm SponsorsCountryOrRegionCode = "SM"
	// Sao Tome and Principe
	SponsorsCountryOrRegionCodeSt SponsorsCountryOrRegionCode = "ST"
	// Saudi Arabia
	SponsorsCountryOrRegionCodeSa SponsorsCountryOrRegionCode = "SA"
	// Senegal
	SponsorsCountryOrRegionCodeSn SponsorsCountryOrRegionCode = "SN"
	// Serbia
	SponsorsCountryOrRegionCodeRs SponsorsCountryOrRegionCode = "RS"
	// Seychelles
	SponsorsCountryOrRegionCodeSc SponsorsCountryOrRegionCode = "SC"
	// Sierra Leone
	SponsorsCountryOrRegionCodeSl SponsorsCountryOrRegionCode = "SL"
	// Singapore
	SponsorsCountryOrRegionCodeSg SponsorsCountryOrRegionCode = "SG"
	// Sint Maarten (Dutch part)
	SponsorsCountryOrRegionCodeSx SponsorsCountryOrRegionCode = "SX"
	// Slovakia
	SponsorsCountryOrRegionCodeSk SponsorsCountryOrRegionCode = "SK"
	// Slovenia
	SponsorsCountryOrRegionCodeSi SponsorsCountryOrRegionCode = "SI"
	// Solomon Islands
	SponsorsCountryOrRegionCodeSb SponsorsCountryOrRegionCode = "SB"
	// Somalia
	SponsorsCountryOrRegionCodeSo SponsorsCountryOrRegionCode = "SO"
	// South Africa
	SponsorsCountryOrRegionCodeZa SponsorsCountryOrRegionCode = "ZA"
	// South Georgia and South Sandwich Islands
	SponsorsCountryOrRegionCodeGs SponsorsCountryOrRegionCode = "GS"
	// South Sudan
	SponsorsCountryOrRegionCodeSs SponsorsCountryOrRegionCode = "SS"
	// Spain
	SponsorsCountryOrRegionCodeEs SponsorsCountryOrRegionCode = "ES"
	// Sri Lanka
	SponsorsCountryOrRegionCodeLk SponsorsCountryOrRegionCode = "LK"
	// Sudan
	SponsorsCountryOrRegionCodeSd SponsorsCountryOrRegionCode = "SD"
	// Suriname
	SponsorsCountryOrRegionCodeSr SponsorsCountryOrRegionCode = "SR"
	// Svalbard and Jan Mayen Islands
	SponsorsCountryOrRegionCodeSj SponsorsCountryOrRegionCode = "SJ"
	// Swaziland
	SponsorsCountryOrRegionCodeSz SponsorsCountryOrRegionCode = "SZ"
	// Sweden
	SponsorsCountryOrRegionCodeSe SponsorsCountryOrRegionCode = "SE"
	// Switzerland
	SponsorsCountryOrRegionCodeCh SponsorsCountryOrRegionCode = "CH"
	// Taiwan
	SponsorsCountryOrRegionCodeTw SponsorsCountryOrRegionCode = "TW"
	// Tajikistan
	SponsorsCountryOrRegionCodeTj SponsorsCountryOrRegionCode = "TJ"
	// Tanzania
	SponsorsCountryOrRegionCodeTz SponsorsCountryOrRegionCode = "TZ"
	// Thailand
	SponsorsCountryOrRegionCodeTh SponsorsCountryOrRegionCode = "TH"
	// Timor-Leste
	SponsorsCountryOrRegionCodeTl SponsorsCountryOrRegionCode = "TL"
	// Togo
	SponsorsCountryOrRegionCodeTg SponsorsCountryOrRegionCode = "TG"
	// Tokelau
	SponsorsCountryOrRegionCodeTk SponsorsCountryOrRegionCode = "TK"
	// Tonga
	SponsorsCountryOrRegionCodeTo SponsorsCountryOrRegionCode = "TO"
	// Trinidad and Tobago
	SponsorsCountryOrRegionCodeTt SponsorsCountryOrRegionCode = "TT"
	// Tunisia
	SponsorsCountryOrRegionCodeTn SponsorsCountryOrRegionCode = "TN"
	// Trkiye
	SponsorsCountryOrRegionCodeTr SponsorsCountryOrRegionCode = "TR"
	// Turkmenistan
	SponsorsCountryOrRegionCodeTm SponsorsCountryOrRegionCode = "TM"
	// Turks and Caicos Islands
	SponsorsCountryOrRegionCodeTc SponsorsCountryOrRegionCode = "TC"
	// Tuvalu
	SponsorsCountryOrRegionCodeTv SponsorsCountryOrRegionCode = "TV"
	// Uganda
	SponsorsCountryOrRegionCodeUg SponsorsCountryOrRegionCode = "UG"
	// Ukraine
	SponsorsCountryOrRegionCodeUa SponsorsCountryOrRegionCode = "UA"
	// United Arab Emirates
	SponsorsCountryOrRegionCodeAe SponsorsCountryOrRegionCode = "AE"
	// United Kingdom
	SponsorsCountryOrRegionCodeGb SponsorsCountryOrRegionCode = "GB"
	// United States Minor Outlying Islands
	SponsorsCountryOrRegionCodeUm SponsorsCountryOrRegionCode = "UM"
	// United States of America
	SponsorsCountryOrRegionCodeUs SponsorsCountryOrRegionCode = "US"
	// Uruguay
	SponsorsCountryOrRegionCodeUy SponsorsCountryOrRegionCode = "UY"
	// Uzbekistan
	SponsorsCountryOrRegionCodeUz SponsorsCountryOrRegionCode = "UZ"
	// Vanuatu
	SponsorsCountryOrRegionCodeVu SponsorsCountryOrRegionCode = "VU"
	// Vatican City
	SponsorsCountryOrRegionCodeVa SponsorsCountryOrRegionCode = "VA"
	// Venezuela
	SponsorsCountryOrRegionCodeVe SponsorsCountryOrRegionCode = "VE"
	// Vietnam
	SponsorsCountryOrRegionCodeVn SponsorsCountryOrRegionCode = "VN"
	// Virgin Islands, British
	SponsorsCountryOrRegionCodeVg SponsorsCountryOrRegionCode = "VG"
	// Virgin Islands, U.S.
	SponsorsCountryOrRegionCodeVi SponsorsCountryOrRegionCode = "VI"
	// Wallis and Futuna Islands
	SponsorsCountryOrRegionCodeWf SponsorsCountryOrRegionCode = "WF"
	// Western Sahara
	SponsorsCountryOrRegionCodeEh SponsorsCountryOrRegionCode = "EH"
	// Yemen
	SponsorsCountryOrRegionCodeYe SponsorsCountryOrRegionCode = "YE"
	// Zambia
	SponsorsCountryOrRegionCodeZm SponsorsCountryOrRegionCode = "ZM"
	// Zimbabwe
	SponsorsCountryOrRegionCodeZw SponsorsCountryOrRegionCode = "ZW"
)

var AllSponsorsCountryOrRegionCode = []SponsorsCountryOrRegionCode{
	SponsorsCountryOrRegionCodeAf,
	SponsorsCountryOrRegionCodeAx,
	SponsorsCountryOrRegionCodeAl,
	SponsorsCountryOrRegionCodeDz,
	SponsorsCountryOrRegionCodeAs,
	SponsorsCountryOrRegionCodeAd,
	SponsorsCountryOrRegionCodeAo,
	SponsorsCountryOrRegionCodeAi,
	SponsorsCountryOrRegionCodeAq,
	SponsorsCountryOrRegionCodeAg,
	SponsorsCountryOrRegionCodeAr,
	SponsorsCountryOrRegionCodeAm,
	SponsorsCountryOrRegionCodeAw,
	SponsorsCountryOrRegionCodeAu,
	SponsorsCountryOrRegionCodeAt,
	SponsorsCountryOrRegionCodeAz,
	SponsorsCountryOrRegionCodeBs,
	SponsorsCountryOrRegionCodeBh,
	SponsorsCountryOrRegionCodeBd,
	SponsorsCountryOrRegionCodeBb,
	SponsorsCountryOrRegionCodeBy,
	SponsorsCountryOrRegionCodeBe,
	SponsorsCountryOrRegionCodeBz,
	SponsorsCountryOrRegionCodeBj,
	SponsorsCountryOrRegionCodeBm,
	SponsorsCountryOrRegionCodeBt,
	SponsorsCountryOrRegionCodeBo,
	SponsorsCountryOrRegionCodeBq,
	SponsorsCountryOrRegionCodeBa,
	SponsorsCountryOrRegionCodeBw,
	SponsorsCountryOrRegionCodeBv,
	SponsorsCountryOrRegionCodeBr,
	SponsorsCountryOrRegionCodeIo,
	SponsorsCountryOrRegionCodeBn,
	SponsorsCountryOrRegionCodeBg,
	SponsorsCountryOrRegionCodeBf,
	SponsorsCountryOrRegionCodeBi,
	SponsorsCountryOrRegionCodeKh,
	SponsorsCountryOrRegionCodeCm,
	SponsorsCountryOrRegionCodeCa,
	SponsorsCountryOrRegionCodeCv,
	SponsorsCountryOrRegionCodeKy,
	SponsorsCountryOrRegionCodeCf,
	SponsorsCountryOrRegionCodeTd,
	SponsorsCountryOrRegionCodeCl,
	SponsorsCountryOrRegionCodeCn,
	SponsorsCountryOrRegionCodeCx,
	SponsorsCountryOrRegionCodeCc,
	SponsorsCountryOrRegionCodeCo,
	SponsorsCountryOrRegionCodeKm,
	SponsorsCountryOrRegionCodeCg,
	SponsorsCountryOrRegionCodeCd,
	SponsorsCountryOrRegionCodeCk,
	SponsorsCountryOrRegionCodeCr,
	SponsorsCountryOrRegionCodeCi,
	SponsorsCountryOrRegionCodeHr,
	SponsorsCountryOrRegionCodeCw,
	SponsorsCountryOrRegionCodeCy,
	SponsorsCountryOrRegionCodeCz,
	SponsorsCountryOrRegionCodeDk,
	SponsorsCountryOrRegionCodeDj,
	SponsorsCountryOrRegionCodeDm,
	SponsorsCountryOrRegionCodeDo,
	SponsorsCountryOrRegionCodeEc,
	SponsorsCountryOrRegionCodeEg,
	SponsorsCountryOrRegionCodeSv,
	SponsorsCountryOrRegionCodeGq,
	SponsorsCountryOrRegionCodeEr,
	SponsorsCountryOrRegionCodeEe,
	SponsorsCountryOrRegionCodeEt,
	SponsorsCountryOrRegionCodeFk,
	SponsorsCountryOrRegionCodeFo,
	SponsorsCountryOrRegionCodeFj,
	SponsorsCountryOrRegionCodeFi,
	SponsorsCountryOrRegionCodeFr,
	SponsorsCountryOrRegionCodeGf,
	SponsorsCountryOrRegionCodePf,
	SponsorsCountryOrRegionCodeTf,
	SponsorsCountryOrRegionCodeGa,
	SponsorsCountryOrRegionCodeGm,
	SponsorsCountryOrRegionCodeGe,
	SponsorsCountryOrRegionCodeDe,
	SponsorsCountryOrRegionCodeGh,
	SponsorsCountryOrRegionCodeGi,
	SponsorsCountryOrRegionCodeGr,
	SponsorsCountryOrRegionCodeGl,
	SponsorsCountryOrRegionCodeGd,
	SponsorsCountryOrRegionCodeGp,
	SponsorsCountryOrRegionCodeGu,
	SponsorsCountryOrRegionCodeGt,
	SponsorsCountryOrRegionCodeGg,
	SponsorsCountryOrRegionCodeGn,
	SponsorsCountryOrRegionCodeGw,
	SponsorsCountryOrRegionCodeGy,
	SponsorsCountryOrRegionCodeHt,
	SponsorsCountryOrRegionCodeHm,
	SponsorsCountryOrRegionCodeHn,
	SponsorsCountryOrRegionCodeHk,
	SponsorsCountryOrRegionCodeHu,
	SponsorsCountryOrRegionCodeIs,
	SponsorsCountryOrRegionCodeIn,
	SponsorsCountryOrRegionCodeID,
	SponsorsCountryOrRegionCodeIr,
	SponsorsCountryOrRegionCodeIq,
	SponsorsCountryOrRegionCodeIe,
	SponsorsCountryOrRegionCodeIm,
	SponsorsCountryOrRegionCodeIl,
	SponsorsCountryOrRegionCodeIt,
	SponsorsCountryOrRegionCodeJm,
	SponsorsCountryOrRegionCodeJp,
	SponsorsCountryOrRegionCodeJe,
	SponsorsCountryOrRegionCodeJo,
	SponsorsCountryOrRegionCodeKz,
	SponsorsCountryOrRegionCodeKe,
	SponsorsCountryOrRegionCodeKi,
	SponsorsCountryOrRegionCodeKr,
	SponsorsCountryOrRegionCodeKw,
	SponsorsCountryOrRegionCodeKg,
	SponsorsCountryOrRegionCodeLa,
	SponsorsCountryOrRegionCodeLv,
	SponsorsCountryOrRegionCodeLb,
	SponsorsCountryOrRegionCodeLs,
	SponsorsCountryOrRegionCodeLr,
	SponsorsCountryOrRegionCodeLy,
	SponsorsCountryOrRegionCodeLi,
	SponsorsCountryOrRegionCodeLt,
	SponsorsCountryOrRegionCodeLu,
	SponsorsCountryOrRegionCodeMo,
	SponsorsCountryOrRegionCodeMk,
	SponsorsCountryOrRegionCodeMg,
	SponsorsCountryOrRegionCodeMw,
	SponsorsCountryOrRegionCodeMy,
	SponsorsCountryOrRegionCodeMv,
	SponsorsCountryOrRegionCodeMl,
	SponsorsCountryOrRegionCodeMt,
	SponsorsCountryOrRegionCodeMh,
	SponsorsCountryOrRegionCodeMq,
	SponsorsCountryOrRegionCodeMr,
	SponsorsCountryOrRegionCodeMu,
	SponsorsCountryOrRegionCodeYt,
	SponsorsCountryOrRegionCodeMx,
	SponsorsCountryOrRegionCodeFm,
	SponsorsCountryOrRegionCodeMd,
	SponsorsCountryOrRegionCodeMc,
	SponsorsCountryOrRegionCodeMn,
	SponsorsCountryOrRegionCodeMe,
	SponsorsCountryOrRegionCodeMs,
	SponsorsCountryOrRegionCodeMa,
	SponsorsCountryOrRegionCodeMz,
	SponsorsCountryOrRegionCodeMm,
	SponsorsCountryOrRegionCodeNa,
	SponsorsCountryOrRegionCodeNr,
	SponsorsCountryOrRegionCodeNp,
	SponsorsCountryOrRegionCodeNl,
	SponsorsCountryOrRegionCodeNc,
	SponsorsCountryOrRegionCodeNz,
	SponsorsCountryOrRegionCodeNi,
	SponsorsCountryOrRegionCodeNe,
	SponsorsCountryOrRegionCodeNg,
	SponsorsCountryOrRegionCodeNu,
	SponsorsCountryOrRegionCodeNf,
	SponsorsCountryOrRegionCodeMp,
	SponsorsCountryOrRegionCodeNo,
	SponsorsCountryOrRegionCodeOm,
	SponsorsCountryOrRegionCodePk,
	SponsorsCountryOrRegionCodePw,
	SponsorsCountryOrRegionCodePs,
	SponsorsCountryOrRegionCodePa,
	SponsorsCountryOrRegionCodePg,
	SponsorsCountryOrRegionCodePy,
	SponsorsCountryOrRegionCodePe,
	SponsorsCountryOrRegionCodePh,
	SponsorsCountryOrRegionCodePn,
	SponsorsCountryOrRegionCodePl,
	SponsorsCountryOrRegionCodePt,
	SponsorsCountryOrRegionCodePr,
	SponsorsCountryOrRegionCodeQa,
	SponsorsCountryOrRegionCodeRe,
	SponsorsCountryOrRegionCodeRo,
	SponsorsCountryOrRegionCodeRu,
	SponsorsCountryOrRegionCodeRw,
	SponsorsCountryOrRegionCodeBl,
	SponsorsCountryOrRegionCodeSh,
	SponsorsCountryOrRegionCodeKn,
	SponsorsCountryOrRegionCodeLc,
	SponsorsCountryOrRegionCodeMf,
	SponsorsCountryOrRegionCodePm,
	SponsorsCountryOrRegionCodeVc,
	SponsorsCountryOrRegionCodeWs,
	SponsorsCountryOrRegionCodeSm,
	SponsorsCountryOrRegionCodeSt,
	SponsorsCountryOrRegionCodeSa,
	SponsorsCountryOrRegionCodeSn,
	SponsorsCountryOrRegionCodeRs,
	SponsorsCountryOrRegionCodeSc,
	SponsorsCountryOrRegionCodeSl,
	SponsorsCountryOrRegionCodeSg,
	SponsorsCountryOrRegionCodeSx,
	SponsorsCountryOrRegionCodeSk,
	SponsorsCountryOrRegionCodeSi,
	SponsorsCountryOrRegionCodeSb,
	SponsorsCountryOrRegionCodeSo,
	SponsorsCountryOrRegionCodeZa,
	SponsorsCountryOrRegionCodeGs,
	SponsorsCountryOrRegionCodeSs,
	SponsorsCountryOrRegionCodeEs,
	SponsorsCountryOrRegionCodeLk,
	SponsorsCountryOrRegionCodeSd,
	SponsorsCountryOrRegionCodeSr,
	SponsorsCountryOrRegionCodeSj,
	SponsorsCountryOrRegionCodeSz,
	SponsorsCountryOrRegionCodeSe,
	SponsorsCountryOrRegionCodeCh,
	SponsorsCountryOrRegionCodeTw,
	SponsorsCountryOrRegionCodeTj,
	SponsorsCountryOrRegionCodeTz,
	SponsorsCountryOrRegionCodeTh,
	SponsorsCountryOrRegionCodeTl,
	SponsorsCountryOrRegionCodeTg,
	SponsorsCountryOrRegionCodeTk,
	SponsorsCountryOrRegionCodeTo,
	SponsorsCountryOrRegionCodeTt,
	SponsorsCountryOrRegionCodeTn,
	SponsorsCountryOrRegionCodeTr,
	SponsorsCountryOrRegionCodeTm,
	SponsorsCountryOrRegionCodeTc,
	SponsorsCountryOrRegionCodeTv,
	SponsorsCountryOrRegionCodeUg,
	SponsorsCountryOrRegionCodeUa,
	SponsorsCountryOrRegionCodeAe,
	SponsorsCountryOrRegionCodeGb,
	SponsorsCountryOrRegionCodeUm,
	SponsorsCountryOrRegionCodeUs,
	SponsorsCountryOrRegionCodeUy,
	SponsorsCountryOrRegionCodeUz,
	SponsorsCountryOrRegionCodeVu,
	SponsorsCountryOrRegionCodeVa,
	SponsorsCountryOrRegionCodeVe,
	SponsorsCountryOrRegionCodeVn,
	SponsorsCountryOrRegionCodeVg,
	SponsorsCountryOrRegionCodeVi,
	SponsorsCountryOrRegionCodeWf,
	SponsorsCountryOrRegionCodeEh,
	SponsorsCountryOrRegionCodeYe,
	SponsorsCountryOrRegionCodeZm,
	SponsorsCountryOrRegionCodeZw,
}

func (e SponsorsCountryOrRegionCode) IsValid() bool {
	switch e {
	case SponsorsCountryOrRegionCodeAf, SponsorsCountryOrRegionCodeAx, SponsorsCountryOrRegionCodeAl, SponsorsCountryOrRegionCodeDz, SponsorsCountryOrRegionCodeAs, SponsorsCountryOrRegionCodeAd, SponsorsCountryOrRegionCodeAo, SponsorsCountryOrRegionCodeAi, SponsorsCountryOrRegionCodeAq, SponsorsCountryOrRegionCodeAg, SponsorsCountryOrRegionCodeAr, SponsorsCountryOrRegionCodeAm, SponsorsCountryOrRegionCodeAw, SponsorsCountryOrRegionCodeAu, SponsorsCountryOrRegionCodeAt, SponsorsCountryOrRegionCodeAz, SponsorsCountryOrRegionCodeBs, SponsorsCountryOrRegionCodeBh, SponsorsCountryOrRegionCodeBd, SponsorsCountryOrRegionCodeBb, SponsorsCountryOrRegionCodeBy, SponsorsCountryOrRegionCodeBe, SponsorsCountryOrRegionCodeBz, SponsorsCountryOrRegionCodeBj, SponsorsCountryOrRegionCodeBm, SponsorsCountryOrRegionCodeBt, SponsorsCountryOrRegionCodeBo, SponsorsCountryOrRegionCodeBq, SponsorsCountryOrRegionCodeBa, SponsorsCountryOrRegionCodeBw, SponsorsCountryOrRegionCodeBv, SponsorsCountryOrRegionCodeBr, SponsorsCountryOrRegionCodeIo, SponsorsCountryOrRegionCodeBn, SponsorsCountryOrRegionCodeBg, SponsorsCountryOrRegionCodeBf, SponsorsCountryOrRegionCodeBi, SponsorsCountryOrRegionCodeKh, SponsorsCountryOrRegionCodeCm, SponsorsCountryOrRegionCodeCa, SponsorsCountryOrRegionCodeCv, SponsorsCountryOrRegionCodeKy, SponsorsCountryOrRegionCodeCf, SponsorsCountryOrRegionCodeTd, SponsorsCountryOrRegionCodeCl, SponsorsCountryOrRegionCodeCn, SponsorsCountryOrRegionCodeCx, SponsorsCountryOrRegionCodeCc, SponsorsCountryOrRegionCodeCo, SponsorsCountryOrRegionCodeKm, SponsorsCountryOrRegionCodeCg, SponsorsCountryOrRegionCodeCd, SponsorsCountryOrRegionCodeCk, SponsorsCountryOrRegionCodeCr, SponsorsCountryOrRegionCodeCi, SponsorsCountryOrRegionCodeHr, SponsorsCountryOrRegionCodeCw, SponsorsCountryOrRegionCodeCy, SponsorsCountryOrRegionCodeCz, SponsorsCountryOrRegionCodeDk, SponsorsCountryOrRegionCodeDj, SponsorsCountryOrRegionCodeDm, SponsorsCountryOrRegionCodeDo, SponsorsCountryOrRegionCodeEc, SponsorsCountryOrRegionCodeEg, SponsorsCountryOrRegionCodeSv, SponsorsCountryOrRegionCodeGq, SponsorsCountryOrRegionCodeEr, SponsorsCountryOrRegionCodeEe, SponsorsCountryOrRegionCodeEt, SponsorsCountryOrRegionCodeFk, SponsorsCountryOrRegionCodeFo, SponsorsCountryOrRegionCodeFj, SponsorsCountryOrRegionCodeFi, SponsorsCountryOrRegionCodeFr, SponsorsCountryOrRegionCodeGf, SponsorsCountryOrRegionCodePf, SponsorsCountryOrRegionCodeTf, SponsorsCountryOrRegionCodeGa, SponsorsCountryOrRegionCodeGm, SponsorsCountryOrRegionCodeGe, SponsorsCountryOrRegionCodeDe, SponsorsCountryOrRegionCodeGh, SponsorsCountryOrRegionCodeGi, SponsorsCountryOrRegionCodeGr, SponsorsCountryOrRegionCodeGl, SponsorsCountryOrRegionCodeGd, SponsorsCountryOrRegionCodeGp, SponsorsCountryOrRegionCodeGu, SponsorsCountryOrRegionCodeGt, SponsorsCountryOrRegionCodeGg, SponsorsCountryOrRegionCodeGn, SponsorsCountryOrRegionCodeGw, SponsorsCountryOrRegionCodeGy, SponsorsCountryOrRegionCodeHt, SponsorsCountryOrRegionCodeHm, SponsorsCountryOrRegionCodeHn, SponsorsCountryOrRegionCodeHk, SponsorsCountryOrRegionCodeHu, SponsorsCountryOrRegionCodeIs, SponsorsCountryOrRegionCodeIn, SponsorsCountryOrRegionCodeID, SponsorsCountryOrRegionCodeIr, SponsorsCountryOrRegionCodeIq, SponsorsCountryOrRegionCodeIe, SponsorsCountryOrRegionCodeIm, SponsorsCountryOrRegionCodeIl, SponsorsCountryOrRegionCodeIt, SponsorsCountryOrRegionCodeJm, SponsorsCountryOrRegionCodeJp, SponsorsCountryOrRegionCodeJe, SponsorsCountryOrRegionCodeJo, SponsorsCountryOrRegionCodeKz, SponsorsCountryOrRegionCodeKe, SponsorsCountryOrRegionCodeKi, SponsorsCountryOrRegionCodeKr, SponsorsCountryOrRegionCodeKw, SponsorsCountryOrRegionCodeKg, SponsorsCountryOrRegionCodeLa, SponsorsCountryOrRegionCodeLv, SponsorsCountryOrRegionCodeLb, SponsorsCountryOrRegionCodeLs, SponsorsCountryOrRegionCodeLr, SponsorsCountryOrRegionCodeLy, SponsorsCountryOrRegionCodeLi, SponsorsCountryOrRegionCodeLt, SponsorsCountryOrRegionCodeLu, SponsorsCountryOrRegionCodeMo, SponsorsCountryOrRegionCodeMk, SponsorsCountryOrRegionCodeMg, SponsorsCountryOrRegionCodeMw, SponsorsCountryOrRegionCodeMy, SponsorsCountryOrRegionCodeMv, SponsorsCountryOrRegionCodeMl, SponsorsCountryOrRegionCodeMt, SponsorsCountryOrRegionCodeMh, SponsorsCountryOrRegionCodeMq, SponsorsCountryOrRegionCodeMr, SponsorsCountryOrRegionCodeMu, SponsorsCountryOrRegionCodeYt, SponsorsCountryOrRegionCodeMx, SponsorsCountryOrRegionCodeFm, SponsorsCountryOrRegionCodeMd, SponsorsCountryOrRegionCodeMc, SponsorsCountryOrRegionCodeMn, SponsorsCountryOrRegionCodeMe, SponsorsCountryOrRegionCodeMs, SponsorsCountryOrRegionCodeMa, SponsorsCountryOrRegionCodeMz, SponsorsCountryOrRegionCodeMm, SponsorsCountryOrRegionCodeNa, SponsorsCountryOrRegionCodeNr, SponsorsCountryOrRegionCodeNp, SponsorsCountryOrRegionCodeNl, SponsorsCountryOrRegionCodeNc, SponsorsCountryOrRegionCodeNz, SponsorsCountryOrRegionCodeNi, SponsorsCountryOrRegionCodeNe, SponsorsCountryOrRegionCodeNg, SponsorsCountryOrRegionCodeNu, SponsorsCountryOrRegionCodeNf, SponsorsCountryOrRegionCodeMp, SponsorsCountryOrRegionCodeNo, SponsorsCountryOrRegionCodeOm, SponsorsCountryOrRegionCodePk, SponsorsCountryOrRegionCodePw, SponsorsCountryOrRegionCodePs, SponsorsCountryOrRegionCodePa, SponsorsCountryOrRegionCodePg, SponsorsCountryOrRegionCodePy, SponsorsCountryOrRegionCodePe, SponsorsCountryOrRegionCodePh, SponsorsCountryOrRegionCodePn, SponsorsCountryOrRegionCodePl, SponsorsCountryOrRegionCodePt, SponsorsCountryOrRegionCodePr, SponsorsCountryOrRegionCodeQa, SponsorsCountryOrRegionCodeRe, SponsorsCountryOrRegionCodeRo, SponsorsCountryOrRegionCodeRu, SponsorsCountryOrRegionCodeRw, SponsorsCountryOrRegionCodeBl, SponsorsCountryOrRegionCodeSh, SponsorsCountryOrRegionCodeKn, SponsorsCountryOrRegionCodeLc, SponsorsCountryOrRegionCodeMf, SponsorsCountryOrRegionCodePm, SponsorsCountryOrRegionCodeVc, SponsorsCountryOrRegionCodeWs, SponsorsCountryOrRegionCodeSm, SponsorsCountryOrRegionCodeSt, SponsorsCountryOrRegionCodeSa, SponsorsCountryOrRegionCodeSn, SponsorsCountryOrRegionCodeRs, SponsorsCountryOrRegionCodeSc, SponsorsCountryOrRegionCodeSl, SponsorsCountryOrRegionCodeSg, SponsorsCountryOrRegionCodeSx, SponsorsCountryOrRegionCodeSk, SponsorsCountryOrRegionCodeSi, SponsorsCountryOrRegionCodeSb, SponsorsCountryOrRegionCodeSo, SponsorsCountryOrRegionCodeZa, SponsorsCountryOrRegionCodeGs, SponsorsCountryOrRegionCodeSs, SponsorsCountryOrRegionCodeEs, SponsorsCountryOrRegionCodeLk, SponsorsCountryOrRegionCodeSd, SponsorsCountryOrRegionCodeSr, SponsorsCountryOrRegionCodeSj, SponsorsCountryOrRegionCodeSz, SponsorsCountryOrRegionCodeSe, SponsorsCountryOrRegionCodeCh, SponsorsCountryOrRegionCodeTw, SponsorsCountryOrRegionCodeTj, SponsorsCountryOrRegionCodeTz, SponsorsCountryOrRegionCodeTh, SponsorsCountryOrRegionCodeTl, SponsorsCountryOrRegionCodeTg, SponsorsCountryOrRegionCodeTk, SponsorsCountryOrRegionCodeTo, SponsorsCountryOrRegionCodeTt, SponsorsCountryOrRegionCodeTn, SponsorsCountryOrRegionCodeTr, SponsorsCountryOrRegionCodeTm, SponsorsCountryOrRegionCodeTc, SponsorsCountryOrRegionCodeTv, SponsorsCountryOrRegionCodeUg, SponsorsCountryOrRegionCodeUa, SponsorsCountryOrRegionCodeAe, SponsorsCountryOrRegionCodeGb, SponsorsCountryOrRegionCodeUm, SponsorsCountryOrRegionCodeUs, SponsorsCountryOrRegionCodeUy, SponsorsCountryOrRegionCodeUz, SponsorsCountryOrRegionCodeVu, SponsorsCountryOrRegionCodeVa, SponsorsCountryOrRegionCodeVe, SponsorsCountryOrRegionCodeVn, SponsorsCountryOrRegionCodeVg, SponsorsCountryOrRegionCodeVi, SponsorsCountryOrRegionCodeWf, SponsorsCountryOrRegionCodeEh, SponsorsCountryOrRegionCodeYe, SponsorsCountryOrRegionCodeZm, SponsorsCountryOrRegionCodeZw:
		return true
	}
	return false
}

func (e SponsorsCountryOrRegionCode) String() string {
	return string(e)
}

func (e *SponsorsCountryOrRegionCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsCountryOrRegionCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsCountryOrRegionCode", str)
	}
	return nil
}

func (e SponsorsCountryOrRegionCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different kinds of goals a GitHub Sponsors member can have.
type SponsorsGoalKind string

const (
	// The goal is about reaching a certain number of sponsors.
	SponsorsGoalKindTotalSponsorsCount SponsorsGoalKind = "TOTAL_SPONSORS_COUNT"
	// The goal is about getting a certain amount in USD from sponsorships each month.
	SponsorsGoalKindMonthlySponsorshipAmount SponsorsGoalKind = "MONTHLY_SPONSORSHIP_AMOUNT"
)

var AllSponsorsGoalKind = []SponsorsGoalKind{
	SponsorsGoalKindTotalSponsorsCount,
	SponsorsGoalKindMonthlySponsorshipAmount,
}

func (e SponsorsGoalKind) IsValid() bool {
	switch e {
	case SponsorsGoalKindTotalSponsorsCount, SponsorsGoalKindMonthlySponsorshipAmount:
		return true
	}
	return false
}

func (e SponsorsGoalKind) String() string {
	return string(e)
}

func (e *SponsorsGoalKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsGoalKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsGoalKind", str)
	}
	return nil
}

func (e SponsorsGoalKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different kinds of records that can be featured on a GitHub Sponsors profile page.
type SponsorsListingFeaturedItemFeatureableType string

const (
	// A repository owned by the user or organization with the GitHub Sponsors profile.
	SponsorsListingFeaturedItemFeatureableTypeRepository SponsorsListingFeaturedItemFeatureableType = "REPOSITORY"
	// A user who belongs to the organization with the GitHub Sponsors profile.
	SponsorsListingFeaturedItemFeatureableTypeUser SponsorsListingFeaturedItemFeatureableType = "USER"
)

var AllSponsorsListingFeaturedItemFeatureableType = []SponsorsListingFeaturedItemFeatureableType{
	SponsorsListingFeaturedItemFeatureableTypeRepository,
	SponsorsListingFeaturedItemFeatureableTypeUser,
}

func (e SponsorsListingFeaturedItemFeatureableType) IsValid() bool {
	switch e {
	case SponsorsListingFeaturedItemFeatureableTypeRepository, SponsorsListingFeaturedItemFeatureableTypeUser:
		return true
	}
	return false
}

func (e SponsorsListingFeaturedItemFeatureableType) String() string {
	return string(e)
}

func (e *SponsorsListingFeaturedItemFeatureableType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsListingFeaturedItemFeatureableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsListingFeaturedItemFeatureableType", str)
	}
	return nil
}

func (e SponsorsListingFeaturedItemFeatureableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Sponsors tiers connections can be ordered.
type SponsorsTierOrderField string

const (
	// Order tiers by creation time.
	SponsorsTierOrderFieldCreatedAt SponsorsTierOrderField = "CREATED_AT"
	// Order tiers by their monthly price in cents
	SponsorsTierOrderFieldMonthlyPriceInCents SponsorsTierOrderField = "MONTHLY_PRICE_IN_CENTS"
)

var AllSponsorsTierOrderField = []SponsorsTierOrderField{
	SponsorsTierOrderFieldCreatedAt,
	SponsorsTierOrderFieldMonthlyPriceInCents,
}

func (e SponsorsTierOrderField) IsValid() bool {
	switch e {
	case SponsorsTierOrderFieldCreatedAt, SponsorsTierOrderFieldMonthlyPriceInCents:
		return true
	}
	return false
}

func (e SponsorsTierOrderField) String() string {
	return string(e)
}

func (e *SponsorsTierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorsTierOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorsTierOrderField", str)
	}
	return nil
}

func (e SponsorsTierOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which sponsorship update connections can be ordered.
type SponsorshipNewsletterOrderField string

const (
	// Order sponsorship newsletters by when they were created.
	SponsorshipNewsletterOrderFieldCreatedAt SponsorshipNewsletterOrderField = "CREATED_AT"
)

var AllSponsorshipNewsletterOrderField = []SponsorshipNewsletterOrderField{
	SponsorshipNewsletterOrderFieldCreatedAt,
}

func (e SponsorshipNewsletterOrderField) IsValid() bool {
	switch e {
	case SponsorshipNewsletterOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e SponsorshipNewsletterOrderField) String() string {
	return string(e)
}

func (e *SponsorshipNewsletterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorshipNewsletterOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorshipNewsletterOrderField", str)
	}
	return nil
}

func (e SponsorshipNewsletterOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which sponsorship connections can be ordered.
type SponsorshipOrderField string

const (
	// Order sponsorship by creation time.
	SponsorshipOrderFieldCreatedAt SponsorshipOrderField = "CREATED_AT"
)

var AllSponsorshipOrderField = []SponsorshipOrderField{
	SponsorshipOrderFieldCreatedAt,
}

func (e SponsorshipOrderField) IsValid() bool {
	switch e {
	case SponsorshipOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e SponsorshipOrderField) String() string {
	return string(e)
}

func (e *SponsorshipOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorshipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorshipOrderField", str)
	}
	return nil
}

func (e SponsorshipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// How payment was made for funding a GitHub Sponsors sponsorship.
type SponsorshipPaymentSource string

const (
	// Payment was made through GitHub.
	SponsorshipPaymentSourceGithub SponsorshipPaymentSource = "GITHUB"
	// Payment was made through Patreon.
	SponsorshipPaymentSourcePatreon SponsorshipPaymentSource = "PATREON"
)

var AllSponsorshipPaymentSource = []SponsorshipPaymentSource{
	SponsorshipPaymentSourceGithub,
	SponsorshipPaymentSourcePatreon,
}

func (e SponsorshipPaymentSource) IsValid() bool {
	switch e {
	case SponsorshipPaymentSourceGithub, SponsorshipPaymentSourcePatreon:
		return true
	}
	return false
}

func (e SponsorshipPaymentSource) String() string {
	return string(e)
}

func (e *SponsorshipPaymentSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorshipPaymentSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorshipPaymentSource", str)
	}
	return nil
}

func (e SponsorshipPaymentSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The privacy of a sponsorship
type SponsorshipPrivacy string

const (
	// Public
	SponsorshipPrivacyPublic SponsorshipPrivacy = "PUBLIC"
	// Private
	SponsorshipPrivacyPrivate SponsorshipPrivacy = "PRIVATE"
)

var AllSponsorshipPrivacy = []SponsorshipPrivacy{
	SponsorshipPrivacyPublic,
	SponsorshipPrivacyPrivate,
}

func (e SponsorshipPrivacy) IsValid() bool {
	switch e {
	case SponsorshipPrivacyPublic, SponsorshipPrivacyPrivate:
		return true
	}
	return false
}

func (e SponsorshipPrivacy) String() string {
	return string(e)
}

func (e *SponsorshipPrivacy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SponsorshipPrivacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SponsorshipPrivacy", str)
	}
	return nil
}

func (e SponsorshipPrivacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible default commit messages for squash merges.
type SquashMergeCommitMessage string

const (
	// Default to the pull request's body.
	SquashMergeCommitMessagePrBody SquashMergeCommitMessage = "PR_BODY"
	// Default to the branch's commit messages.
	SquashMergeCommitMessageCommitMessages SquashMergeCommitMessage = "COMMIT_MESSAGES"
	// Default to a blank commit message.
	SquashMergeCommitMessageBlank SquashMergeCommitMessage = "BLANK"
)

var AllSquashMergeCommitMessage = []SquashMergeCommitMessage{
	SquashMergeCommitMessagePrBody,
	SquashMergeCommitMessageCommitMessages,
	SquashMergeCommitMessageBlank,
}

func (e SquashMergeCommitMessage) IsValid() bool {
	switch e {
	case SquashMergeCommitMessagePrBody, SquashMergeCommitMessageCommitMessages, SquashMergeCommitMessageBlank:
		return true
	}
	return false
}

func (e SquashMergeCommitMessage) String() string {
	return string(e)
}

func (e *SquashMergeCommitMessage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquashMergeCommitMessage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquashMergeCommitMessage", str)
	}
	return nil
}

func (e SquashMergeCommitMessage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible default commit titles for squash merges.
type SquashMergeCommitTitle string

const (
	// Default to the pull request's title.
	SquashMergeCommitTitlePrTitle SquashMergeCommitTitle = "PR_TITLE"
	// Default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
	SquashMergeCommitTitleCommitOrPrTitle SquashMergeCommitTitle = "COMMIT_OR_PR_TITLE"
)

var AllSquashMergeCommitTitle = []SquashMergeCommitTitle{
	SquashMergeCommitTitlePrTitle,
	SquashMergeCommitTitleCommitOrPrTitle,
}

func (e SquashMergeCommitTitle) IsValid() bool {
	switch e {
	case SquashMergeCommitTitlePrTitle, SquashMergeCommitTitleCommitOrPrTitle:
		return true
	}
	return false
}

func (e SquashMergeCommitTitle) String() string {
	return string(e)
}

func (e *SquashMergeCommitTitle) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SquashMergeCommitTitle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SquashMergeCommitTitle", str)
	}
	return nil
}

func (e SquashMergeCommitTitle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which star connections can be ordered.
type StarOrderField string

const (
	// Allows ordering a list of stars by when they were created.
	StarOrderFieldStarredAt StarOrderField = "STARRED_AT"
)

var AllStarOrderField = []StarOrderField{
	StarOrderFieldStarredAt,
}

func (e StarOrderField) IsValid() bool {
	switch e {
	case StarOrderFieldStarredAt:
		return true
	}
	return false
}

func (e StarOrderField) String() string {
	return string(e)
}

func (e *StarOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StarOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StarOrderField", str)
	}
	return nil
}

func (e StarOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible commit status states.
type StatusState string

const (
	// Status is expected.
	StatusStateExpected StatusState = "EXPECTED"
	// Status is errored.
	StatusStateError StatusState = "ERROR"
	// Status is failing.
	StatusStateFailure StatusState = "FAILURE"
	// Status is pending.
	StatusStatePending StatusState = "PENDING"
	// Status is successful.
	StatusStateSuccess StatusState = "SUCCESS"
)

var AllStatusState = []StatusState{
	StatusStateExpected,
	StatusStateError,
	StatusStateFailure,
	StatusStatePending,
	StatusStateSuccess,
}

func (e StatusState) IsValid() bool {
	switch e {
	case StatusStateExpected, StatusStateError, StatusStateFailure, StatusStatePending, StatusStateSuccess:
		return true
	}
	return false
}

func (e StatusState) String() string {
	return string(e)
}

func (e *StatusState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatusState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatusState", str)
	}
	return nil
}

func (e StatusState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a subscription.
type SubscriptionState string

const (
	// The User is only notified when participating or @mentioned.
	SubscriptionStateUnsubscribed SubscriptionState = "UNSUBSCRIBED"
	// The User is notified of all conversations.
	SubscriptionStateSubscribed SubscriptionState = "SUBSCRIBED"
	// The User is never notified.
	SubscriptionStateIgnored SubscriptionState = "IGNORED"
)

var AllSubscriptionState = []SubscriptionState{
	SubscriptionStateUnsubscribed,
	SubscriptionStateSubscribed,
	SubscriptionStateIgnored,
}

func (e SubscriptionState) IsValid() bool {
	switch e {
	case SubscriptionStateUnsubscribed, SubscriptionStateSubscribed, SubscriptionStateIgnored:
		return true
	}
	return false
}

func (e SubscriptionState) String() string {
	return string(e)
}

func (e *SubscriptionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionState", str)
	}
	return nil
}

func (e SubscriptionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which team discussion comment connections can be ordered.
type TeamDiscussionCommentOrderField string

const (
	// Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering).
	TeamDiscussionCommentOrderFieldNumber TeamDiscussionCommentOrderField = "NUMBER"
)

var AllTeamDiscussionCommentOrderField = []TeamDiscussionCommentOrderField{
	TeamDiscussionCommentOrderFieldNumber,
}

func (e TeamDiscussionCommentOrderField) IsValid() bool {
	switch e {
	case TeamDiscussionCommentOrderFieldNumber:
		return true
	}
	return false
}

func (e TeamDiscussionCommentOrderField) String() string {
	return string(e)
}

func (e *TeamDiscussionCommentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamDiscussionCommentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamDiscussionCommentOrderField", str)
	}
	return nil
}

func (e TeamDiscussionCommentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which team discussion connections can be ordered.
type TeamDiscussionOrderField string

const (
	// Allows chronological ordering of team discussions.
	TeamDiscussionOrderFieldCreatedAt TeamDiscussionOrderField = "CREATED_AT"
)

var AllTeamDiscussionOrderField = []TeamDiscussionOrderField{
	TeamDiscussionOrderFieldCreatedAt,
}

func (e TeamDiscussionOrderField) IsValid() bool {
	switch e {
	case TeamDiscussionOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e TeamDiscussionOrderField) String() string {
	return string(e)
}

func (e *TeamDiscussionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamDiscussionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamDiscussionOrderField", str)
	}
	return nil
}

func (e TeamDiscussionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which team member connections can be ordered.
type TeamMemberOrderField string

const (
	// Order team members by login
	TeamMemberOrderFieldLogin TeamMemberOrderField = "LOGIN"
	// Order team members by creation time
	TeamMemberOrderFieldCreatedAt TeamMemberOrderField = "CREATED_AT"
)

var AllTeamMemberOrderField = []TeamMemberOrderField{
	TeamMemberOrderFieldLogin,
	TeamMemberOrderFieldCreatedAt,
}

func (e TeamMemberOrderField) IsValid() bool {
	switch e {
	case TeamMemberOrderFieldLogin, TeamMemberOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e TeamMemberOrderField) String() string {
	return string(e)
}

func (e *TeamMemberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamMemberOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamMemberOrderField", str)
	}
	return nil
}

func (e TeamMemberOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible team member roles; either 'maintainer' or 'member'.
type TeamMemberRole string

const (
	// A team maintainer has permission to add and remove team members.
	TeamMemberRoleMaintainer TeamMemberRole = "MAINTAINER"
	// A team member has no administrative permissions on the team.
	TeamMemberRoleMember TeamMemberRole = "MEMBER"
)

var AllTeamMemberRole = []TeamMemberRole{
	TeamMemberRoleMaintainer,
	TeamMemberRoleMember,
}

func (e TeamMemberRole) IsValid() bool {
	switch e {
	case TeamMemberRoleMaintainer, TeamMemberRoleMember:
		return true
	}
	return false
}

func (e TeamMemberRole) String() string {
	return string(e)
}

func (e *TeamMemberRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamMemberRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamMemberRole", str)
	}
	return nil
}

func (e TeamMemberRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL.
type TeamMembershipType string

const (
	// Includes only immediate members of the team.
	TeamMembershipTypeImmediate TeamMembershipType = "IMMEDIATE"
	// Includes only child team members for the team.
	TeamMembershipTypeChildTeam TeamMembershipType = "CHILD_TEAM"
	// Includes immediate and child team members for the team.
	TeamMembershipTypeAll TeamMembershipType = "ALL"
)

var AllTeamMembershipType = []TeamMembershipType{
	TeamMembershipTypeImmediate,
	TeamMembershipTypeChildTeam,
	TeamMembershipTypeAll,
}

func (e TeamMembershipType) IsValid() bool {
	switch e {
	case TeamMembershipTypeImmediate, TeamMembershipTypeChildTeam, TeamMembershipTypeAll:
		return true
	}
	return false
}

func (e TeamMembershipType) String() string {
	return string(e)
}

func (e *TeamMembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamMembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamMembershipType", str)
	}
	return nil
}

func (e TeamMembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible team notification values.
type TeamNotificationSetting string

const (
	// Everyone will receive notifications when the team is @mentioned.
	TeamNotificationSettingNotificationsEnabled TeamNotificationSetting = "NOTIFICATIONS_ENABLED"
	// No one will receive notifications.
	TeamNotificationSettingNotificationsDisabled TeamNotificationSetting = "NOTIFICATIONS_DISABLED"
)

var AllTeamNotificationSetting = []TeamNotificationSetting{
	TeamNotificationSettingNotificationsEnabled,
	TeamNotificationSettingNotificationsDisabled,
}

func (e TeamNotificationSetting) IsValid() bool {
	switch e {
	case TeamNotificationSettingNotificationsEnabled, TeamNotificationSettingNotificationsDisabled:
		return true
	}
	return false
}

func (e TeamNotificationSetting) String() string {
	return string(e)
}

func (e *TeamNotificationSetting) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamNotificationSetting(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamNotificationSetting", str)
	}
	return nil
}

func (e TeamNotificationSetting) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which team connections can be ordered.
type TeamOrderField string

const (
	// Allows ordering a list of teams by name.
	TeamOrderFieldName TeamOrderField = "NAME"
)

var AllTeamOrderField = []TeamOrderField{
	TeamOrderFieldName,
}

func (e TeamOrderField) IsValid() bool {
	switch e {
	case TeamOrderFieldName:
		return true
	}
	return false
}

func (e TeamOrderField) String() string {
	return string(e)
}

func (e *TeamOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamOrderField", str)
	}
	return nil
}

func (e TeamOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible team privacy values.
type TeamPrivacy string

const (
	// A secret team can only be seen by its members.
	TeamPrivacySecret TeamPrivacy = "SECRET"
	// A visible team can be seen and @mentioned by every member of the organization.
	TeamPrivacyVisible TeamPrivacy = "VISIBLE"
)

var AllTeamPrivacy = []TeamPrivacy{
	TeamPrivacySecret,
	TeamPrivacyVisible,
}

func (e TeamPrivacy) IsValid() bool {
	switch e {
	case TeamPrivacySecret, TeamPrivacyVisible:
		return true
	}
	return false
}

func (e TeamPrivacy) String() string {
	return string(e)
}

func (e *TeamPrivacy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamPrivacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamPrivacy", str)
	}
	return nil
}

func (e TeamPrivacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which team repository connections can be ordered.
type TeamRepositoryOrderField string

const (
	// Order repositories by creation time
	TeamRepositoryOrderFieldCreatedAt TeamRepositoryOrderField = "CREATED_AT"
	// Order repositories by update time
	TeamRepositoryOrderFieldUpdatedAt TeamRepositoryOrderField = "UPDATED_AT"
	// Order repositories by push time
	TeamRepositoryOrderFieldPushedAt TeamRepositoryOrderField = "PUSHED_AT"
	// Order repositories by name
	TeamRepositoryOrderFieldName TeamRepositoryOrderField = "NAME"
	// Order repositories by permission
	TeamRepositoryOrderFieldPermission TeamRepositoryOrderField = "PERMISSION"
	// Order repositories by number of stargazers
	TeamRepositoryOrderFieldStargazers TeamRepositoryOrderField = "STARGAZERS"
)

var AllTeamRepositoryOrderField = []TeamRepositoryOrderField{
	TeamRepositoryOrderFieldCreatedAt,
	TeamRepositoryOrderFieldUpdatedAt,
	TeamRepositoryOrderFieldPushedAt,
	TeamRepositoryOrderFieldName,
	TeamRepositoryOrderFieldPermission,
	TeamRepositoryOrderFieldStargazers,
}

func (e TeamRepositoryOrderField) IsValid() bool {
	switch e {
	case TeamRepositoryOrderFieldCreatedAt, TeamRepositoryOrderFieldUpdatedAt, TeamRepositoryOrderFieldPushedAt, TeamRepositoryOrderFieldName, TeamRepositoryOrderFieldPermission, TeamRepositoryOrderFieldStargazers:
		return true
	}
	return false
}

func (e TeamRepositoryOrderField) String() string {
	return string(e)
}

func (e *TeamRepositoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamRepositoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamRepositoryOrderField", str)
	}
	return nil
}

func (e TeamRepositoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible team review assignment algorithms
type TeamReviewAssignmentAlgorithm string

const (
	// Alternate reviews between each team member
	TeamReviewAssignmentAlgorithmRoundRobin TeamReviewAssignmentAlgorithm = "ROUND_ROBIN"
	// Balance review load across the entire team
	TeamReviewAssignmentAlgorithmLoadBalance TeamReviewAssignmentAlgorithm = "LOAD_BALANCE"
)

var AllTeamReviewAssignmentAlgorithm = []TeamReviewAssignmentAlgorithm{
	TeamReviewAssignmentAlgorithmRoundRobin,
	TeamReviewAssignmentAlgorithmLoadBalance,
}

func (e TeamReviewAssignmentAlgorithm) IsValid() bool {
	switch e {
	case TeamReviewAssignmentAlgorithmRoundRobin, TeamReviewAssignmentAlgorithmLoadBalance:
		return true
	}
	return false
}

func (e TeamReviewAssignmentAlgorithm) String() string {
	return string(e)
}

func (e *TeamReviewAssignmentAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamReviewAssignmentAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamReviewAssignmentAlgorithm", str)
	}
	return nil
}

func (e TeamReviewAssignmentAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The role of a user on a team.
type TeamRole string

const (
	// User has admin rights on the team.
	TeamRoleAdmin TeamRole = "ADMIN"
	// User is a member of the team.
	TeamRoleMember TeamRole = "MEMBER"
)

var AllTeamRole = []TeamRole{
	TeamRoleAdmin,
	TeamRoleMember,
}

func (e TeamRole) IsValid() bool {
	switch e {
	case TeamRoleAdmin, TeamRoleMember:
		return true
	}
	return false
}

func (e TeamRole) String() string {
	return string(e)
}

func (e *TeamRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamRole", str)
	}
	return nil
}

func (e TeamRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a thread subscription form action
type ThreadSubscriptionFormAction string

const (
	// The User cannot subscribe or unsubscribe to the thread
	ThreadSubscriptionFormActionNone ThreadSubscriptionFormAction = "NONE"
	// The User can subscribe to the thread
	ThreadSubscriptionFormActionSubscribe ThreadSubscriptionFormAction = "SUBSCRIBE"
	// The User can unsubscribe to the thread
	ThreadSubscriptionFormActionUnsubscribe ThreadSubscriptionFormAction = "UNSUBSCRIBE"
)

var AllThreadSubscriptionFormAction = []ThreadSubscriptionFormAction{
	ThreadSubscriptionFormActionNone,
	ThreadSubscriptionFormActionSubscribe,
	ThreadSubscriptionFormActionUnsubscribe,
}

func (e ThreadSubscriptionFormAction) IsValid() bool {
	switch e {
	case ThreadSubscriptionFormActionNone, ThreadSubscriptionFormActionSubscribe, ThreadSubscriptionFormActionUnsubscribe:
		return true
	}
	return false
}

func (e ThreadSubscriptionFormAction) String() string {
	return string(e)
}

func (e *ThreadSubscriptionFormAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ThreadSubscriptionFormAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ThreadSubscriptionFormAction", str)
	}
	return nil
}

func (e ThreadSubscriptionFormAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a subscription.
type ThreadSubscriptionState string

const (
	// The subscription status is currently unavailable.
	ThreadSubscriptionStateUnavailable ThreadSubscriptionState = "UNAVAILABLE"
	// The subscription status is currently disabled.
	ThreadSubscriptionStateDisabled ThreadSubscriptionState = "DISABLED"
	// The User is never notified because they are ignoring the list
	ThreadSubscriptionStateIgnoringList ThreadSubscriptionState = "IGNORING_LIST"
	// The User is notified because they chose custom settings for this thread.
	ThreadSubscriptionStateSubscribedToThreadEvents ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD_EVENTS"
	// The User is never notified because they are ignoring the thread
	ThreadSubscriptionStateIgnoringThread ThreadSubscriptionState = "IGNORING_THREAD"
	// The User is notified becuase they are watching the list
	ThreadSubscriptionStateSubscribedToList ThreadSubscriptionState = "SUBSCRIBED_TO_LIST"
	// The User is notified because they chose custom settings for this thread.
	ThreadSubscriptionStateSubscribedToThreadType ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD_TYPE"
	// The User is notified because they are subscribed to the thread
	ThreadSubscriptionStateSubscribedToThread ThreadSubscriptionState = "SUBSCRIBED_TO_THREAD"
	// The User is not recieving notifications from this thread
	ThreadSubscriptionStateNone ThreadSubscriptionState = "NONE"
)

var AllThreadSubscriptionState = []ThreadSubscriptionState{
	ThreadSubscriptionStateUnavailable,
	ThreadSubscriptionStateDisabled,
	ThreadSubscriptionStateIgnoringList,
	ThreadSubscriptionStateSubscribedToThreadEvents,
	ThreadSubscriptionStateIgnoringThread,
	ThreadSubscriptionStateSubscribedToList,
	ThreadSubscriptionStateSubscribedToThreadType,
	ThreadSubscriptionStateSubscribedToThread,
	ThreadSubscriptionStateNone,
}

func (e ThreadSubscriptionState) IsValid() bool {
	switch e {
	case ThreadSubscriptionStateUnavailable, ThreadSubscriptionStateDisabled, ThreadSubscriptionStateIgnoringList, ThreadSubscriptionStateSubscribedToThreadEvents, ThreadSubscriptionStateIgnoringThread, ThreadSubscriptionStateSubscribedToList, ThreadSubscriptionStateSubscribedToThreadType, ThreadSubscriptionStateSubscribedToThread, ThreadSubscriptionStateNone:
		return true
	}
	return false
}

func (e ThreadSubscriptionState) String() string {
	return string(e)
}

func (e *ThreadSubscriptionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ThreadSubscriptionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ThreadSubscriptionState", str)
	}
	return nil
}

func (e ThreadSubscriptionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason that the suggested topic is declined.
type TopicSuggestionDeclineReason string

const (
	// The suggested topic is not relevant to the repository.
	TopicSuggestionDeclineReasonNotRelevant TopicSuggestionDeclineReason = "NOT_RELEVANT"
	// The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1).
	TopicSuggestionDeclineReasonTooSpecific TopicSuggestionDeclineReason = "TOO_SPECIFIC"
	// The viewer does not like the suggested topic.
	TopicSuggestionDeclineReasonPersonalPreference TopicSuggestionDeclineReason = "PERSONAL_PREFERENCE"
	// The suggested topic is too general for the repository.
	TopicSuggestionDeclineReasonTooGeneral TopicSuggestionDeclineReason = "TOO_GENERAL"
)

var AllTopicSuggestionDeclineReason = []TopicSuggestionDeclineReason{
	TopicSuggestionDeclineReasonNotRelevant,
	TopicSuggestionDeclineReasonTooSpecific,
	TopicSuggestionDeclineReasonPersonalPreference,
	TopicSuggestionDeclineReasonTooGeneral,
}

func (e TopicSuggestionDeclineReason) IsValid() bool {
	switch e {
	case TopicSuggestionDeclineReasonNotRelevant, TopicSuggestionDeclineReasonTooSpecific, TopicSuggestionDeclineReasonPersonalPreference, TopicSuggestionDeclineReasonTooGeneral:
		return true
	}
	return false
}

func (e TopicSuggestionDeclineReason) String() string {
	return string(e)
}

func (e *TopicSuggestionDeclineReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TopicSuggestionDeclineReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TopicSuggestionDeclineReason", str)
	}
	return nil
}

func (e TopicSuggestionDeclineReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states of a tracked issue.
type TrackedIssueStates string

const (
	// The tracked issue is open
	TrackedIssueStatesOpen TrackedIssueStates = "OPEN"
	// The tracked issue is closed
	TrackedIssueStatesClosed TrackedIssueStates = "CLOSED"
)

var AllTrackedIssueStates = []TrackedIssueStates{
	TrackedIssueStatesOpen,
	TrackedIssueStatesClosed,
}

func (e TrackedIssueStates) IsValid() bool {
	switch e {
	case TrackedIssueStatesOpen, TrackedIssueStatesClosed:
		return true
	}
	return false
}

func (e TrackedIssueStates) String() string {
	return string(e)
}

func (e *TrackedIssueStates) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackedIssueStates(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrackedIssueStates", str)
	}
	return nil
}

func (e TrackedIssueStates) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Filters by whether or not 2FA is enabled and if the method configured is considered secure or insecure.
type TwoFactorCredentialSecurityType string

const (
	// Has only secure methods of two-factor authentication.
	TwoFactorCredentialSecurityTypeSecure TwoFactorCredentialSecurityType = "SECURE"
	// Has an insecure method of two-factor authentication. GitHub currently defines this as SMS two-factor authentication.
	TwoFactorCredentialSecurityTypeInsecure TwoFactorCredentialSecurityType = "INSECURE"
	// No method of two-factor authentication.
	TwoFactorCredentialSecurityTypeDisabled TwoFactorCredentialSecurityType = "DISABLED"
)

var AllTwoFactorCredentialSecurityType = []TwoFactorCredentialSecurityType{
	TwoFactorCredentialSecurityTypeSecure,
	TwoFactorCredentialSecurityTypeInsecure,
	TwoFactorCredentialSecurityTypeDisabled,
}

func (e TwoFactorCredentialSecurityType) IsValid() bool {
	switch e {
	case TwoFactorCredentialSecurityTypeSecure, TwoFactorCredentialSecurityTypeInsecure, TwoFactorCredentialSecurityTypeDisabled:
		return true
	}
	return false
}

func (e TwoFactorCredentialSecurityType) String() string {
	return string(e)
}

func (e *TwoFactorCredentialSecurityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TwoFactorCredentialSecurityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TwoFactorCredentialSecurityType", str)
	}
	return nil
}

func (e TwoFactorCredentialSecurityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible durations that a user can be blocked for.
type UserBlockDuration string

const (
	// The user was blocked for 1 day
	UserBlockDurationOneDay UserBlockDuration = "ONE_DAY"
	// The user was blocked for 3 days
	UserBlockDurationThreeDays UserBlockDuration = "THREE_DAYS"
	// The user was blocked for 7 days
	UserBlockDurationOneWeek UserBlockDuration = "ONE_WEEK"
	// The user was blocked for 30 days
	UserBlockDurationOneMonth UserBlockDuration = "ONE_MONTH"
	// The user was blocked permanently
	UserBlockDurationPermanent UserBlockDuration = "PERMANENT"
)

var AllUserBlockDuration = []UserBlockDuration{
	UserBlockDurationOneDay,
	UserBlockDurationThreeDays,
	UserBlockDurationOneWeek,
	UserBlockDurationOneMonth,
	UserBlockDurationPermanent,
}

func (e UserBlockDuration) IsValid() bool {
	switch e {
	case UserBlockDurationOneDay, UserBlockDurationThreeDays, UserBlockDurationOneWeek, UserBlockDurationOneMonth, UserBlockDurationPermanent:
		return true
	}
	return false
}

func (e UserBlockDuration) String() string {
	return string(e)
}

func (e *UserBlockDuration) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserBlockDuration(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserBlockDuration", str)
	}
	return nil
}

func (e UserBlockDuration) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which user status connections can be ordered.
type UserStatusOrderField string

const (
	// Order user statuses by when they were updated.
	UserStatusOrderFieldUpdatedAt UserStatusOrderField = "UPDATED_AT"
)

var AllUserStatusOrderField = []UserStatusOrderField{
	UserStatusOrderFieldUpdatedAt,
}

func (e UserStatusOrderField) IsValid() bool {
	switch e {
	case UserStatusOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e UserStatusOrderField) String() string {
	return string(e)
}

func (e *UserStatusOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStatusOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStatusOrderField", str)
	}
	return nil
}

func (e UserStatusOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether a user being viewed contains public or private information.
type UserViewType string

const (
	// A user that is publicly visible.
	UserViewTypePublic UserViewType = "PUBLIC"
	// A user containing information only visible to the authenticated user.
	UserViewTypePrivate UserViewType = "PRIVATE"
)

var AllUserViewType = []UserViewType{
	UserViewTypePublic,
	UserViewTypePrivate,
}

func (e UserViewType) IsValid() bool {
	switch e {
	case UserViewTypePublic, UserViewTypePrivate:
		return true
	}
	return false
}

func (e UserViewType) String() string {
	return string(e)
}

func (e *UserViewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserViewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserViewType", str)
	}
	return nil
}

func (e UserViewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which verifiable domain connections can be ordered.
type VerifiableDomainOrderField string

const (
	// Order verifiable domains by the domain name.
	VerifiableDomainOrderFieldDomain VerifiableDomainOrderField = "DOMAIN"
	// Order verifiable domains by their creation date.
	VerifiableDomainOrderFieldCreatedAt VerifiableDomainOrderField = "CREATED_AT"
)

var AllVerifiableDomainOrderField = []VerifiableDomainOrderField{
	VerifiableDomainOrderFieldDomain,
	VerifiableDomainOrderFieldCreatedAt,
}

func (e VerifiableDomainOrderField) IsValid() bool {
	switch e {
	case VerifiableDomainOrderFieldDomain, VerifiableDomainOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e VerifiableDomainOrderField) String() string {
	return string(e)
}

func (e *VerifiableDomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerifiableDomainOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerifiableDomainOrderField", str)
	}
	return nil
}

func (e VerifiableDomainOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which workflow run connections can be ordered.
type WorkflowRunOrderField string

const (
	// Order workflow runs by most recently created
	WorkflowRunOrderFieldCreatedAt WorkflowRunOrderField = "CREATED_AT"
)

var AllWorkflowRunOrderField = []WorkflowRunOrderField{
	WorkflowRunOrderFieldCreatedAt,
}

func (e WorkflowRunOrderField) IsValid() bool {
	switch e {
	case WorkflowRunOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e WorkflowRunOrderField) String() string {
	return string(e)
}

func (e *WorkflowRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowRunOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowRunOrderField", str)
	}
	return nil
}

func (e WorkflowRunOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible states for a workflow.
type WorkflowState string

const (
	// The workflow is active.
	WorkflowStateActive WorkflowState = "ACTIVE"
	// The workflow was deleted from the git repository.
	WorkflowStateDeleted WorkflowState = "DELETED"
	// The workflow was disabled by default on a fork.
	WorkflowStateDisabledFork WorkflowState = "DISABLED_FORK"
	// The workflow was disabled for inactivity in the repository.
	WorkflowStateDisabledInactivity WorkflowState = "DISABLED_INACTIVITY"
	// The workflow was disabled manually.
	WorkflowStateDisabledManually WorkflowState = "DISABLED_MANUALLY"
)

var AllWorkflowState = []WorkflowState{
	WorkflowStateActive,
	WorkflowStateDeleted,
	WorkflowStateDisabledFork,
	WorkflowStateDisabledInactivity,
	WorkflowStateDisabledManually,
}

func (e WorkflowState) IsValid() bool {
	switch e {
	case WorkflowStateActive, WorkflowStateDeleted, WorkflowStateDisabledFork, WorkflowStateDisabledInactivity, WorkflowStateDisabledManually:
		return true
	}
	return false
}

func (e WorkflowState) String() string {
	return string(e)
}

func (e *WorkflowState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowState", str)
	}
	return nil
}

func (e WorkflowState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
