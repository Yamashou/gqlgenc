package clientgenv2

import (
	"bytes"
	_ "embed" // used to load template file
	"fmt"
	"go/types"
	"strings"

	"github.com/99designs/gqlgen/codegen/config"
	"github.com/99designs/gqlgen/codegen/templates"
	gqlgencConfig "github.com/Yamashou/gqlgenc/config"
)

//go:embed template.gotpl
var template string

func RenderTemplate(cfg *config.Config, fragments []*Fragment, operations []*Operation, operationResponses []*OperationResponse, structSources []*StructSource, generateCfg *gqlgencConfig.GenerateConfig, client config.PackageConfig) error {
	genGettersGenerator := &GenGettersGenerator{
		ClientPackageName: client.Package,
	}
	if err := templates.Render(templates.Options{
		PackageName: client.Package,
		Filename:    client.Filename,
		Template:    template,
		Data: map[string]any{
			"Fragment":            fragments,
			"Operation":           operations,
			"OperationResponse":   operationResponses,
			"GenerateClient":      generateCfg.ShouldGenerateClient(),
			"StructSources":       structSources,
			"ClientInterfaceName": generateCfg.GetClientInterfaceName(),
		},
		Packages:   cfg.Packages,
		PackageDoc: "// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.\n",
		Funcs: map[string]any{
			"genGetters": genGettersGenerator.GenFunc(),
		},
	}); err != nil {
		return fmt.Errorf("%s generating failed: %w", client.Filename, err)
	}

	return nil
}

type GenGettersGenerator struct {
	ClientPackageName string
}

func (g *GenGettersGenerator) returnTypeName(t types.Type, nested bool) string {
	switch it := t.(type) {
	case *types.Basic:
		return it.String()
	case *types.Pointer:
		return "*" + g.returnTypeName(it.Elem(), true)
	case *types.Slice:
		return "[]" + g.returnTypeName(it.Elem(), true)
	case *types.Named:
		s := strings.Split(it.String(), ".")
		name := s[len(s)-1]

		isImported := it.Obj().Parent() != nil && it.Obj().Pkg().Name() != g.ClientPackageName
		if isImported {
			name = namedTypeString(it)
		}

		if nested {
			return name
		}

		return "*" + name
	case *types.Interface:
		return "any"
	case *types.Map:
		return "map[" + g.returnTypeName(it.Key(), true) + "]" + g.returnTypeName(it.Elem(), true)
	case *types.Alias:
		return g.returnTypeName(it.Underlying(), nested)
	default:
		return fmt.Sprintf("%T----", it)
	}
}

func (g *GenGettersGenerator) GenFunc() func(name string, p types.Type) string {
	// This method returns a string of getters for a struct.
	// The idea is to be able to chain calls safely without having to check for nil.
	// To make this work we need to return a pointer to the struct if the field is a struct.
	return func(name string, p types.Type) string {
		var it *types.Struct
		it, ok := p.(*types.Struct)
		if !ok {
			return ""
		}
		var buf bytes.Buffer

		for i := range it.NumFields() {
			field := it.Field(i)

			returns := g.returnTypeName(field.Type(), false)

			fmt.Fprintf(&buf, "func (t *%s) Get%s() %s{\n", name, field.Name(), returns)
			fmt.Fprintf(&buf, "if t == nil {\n t = &%s{}\n}\n", name)

			pointerOrNot := ""
			if _, ok := field.Type().(*types.Named); ok {
				pointerOrNot = "&"
			}

			fmt.Fprintf(&buf, "return %st.%s\n}\n", pointerOrNot, field.Name())
		}

		return buf.String()
	}
}

func namedTypeString(named *types.Named) string {
	// オブジェクトからパッケージ情報を取得
	pkg := named.Obj().Pkg()

	// パッケージ情報がない場合、型名のみを返す
	if pkg == nil {
		return named.Obj().Name()
	}

	// パッケージ名と型名を結合して返す
	return fmt.Sprintf("%s.%s", pkg.Name(), named.Obj().Name())
}
